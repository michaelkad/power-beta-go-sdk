/**
 * (C) Copyright IBM Corp. 2024.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * IBM OpenAPI SDK Code Generator Version: 3.85.0-75c38f8f-20240206-210220
 */

// Package powervsv1 : Operations and models for the PowervsV1 service
package powervsv1

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/IBM/go-sdk-core/v5/core"
	"github.com/go-openapi/strfmt"
	common "github.com/michaelkad/power-beta-go-sdk/common"
)

// PowervsV1 : Power IAAS API
//
// API Version: 1.0.0
// See: https://github.ibm.com/power-iaas/service-broker
type PowervsV1 struct {
	Service *core.BaseService
}

// DefaultServiceName is the default key used to find external configuration information.
const DefaultServiceName = "powervs"

// PowervsV1Options : Service options
type PowervsV1Options struct {
	ServiceName   string
	URL           string
	Authenticator core.Authenticator
}

// NewPowervsV1UsingExternalConfig : constructs an instance of PowervsV1 with passed in options and external configuration.
func NewPowervsV1UsingExternalConfig(options *PowervsV1Options) (powervs *PowervsV1, err error) {
	if options.ServiceName == "" {
		options.ServiceName = DefaultServiceName
	}

	if options.Authenticator == nil {
		options.Authenticator, err = core.GetAuthenticatorFromEnvironment(options.ServiceName)
		if err != nil {
			return
		}
	}

	powervs, err = NewPowervsV1(options)
	if err != nil {
		return
	}

	err = powervs.Service.ConfigureService(options.ServiceName)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = powervs.Service.SetServiceURL(options.URL)
	}
	return
}

// NewPowervsV1 : constructs an instance of PowervsV1 with passed in options.
func NewPowervsV1(options *PowervsV1Options) (service *PowervsV1, err error) {
	serviceOptions := &core.ServiceOptions{
		Authenticator: options.Authenticator,
	}

	baseService, err := core.NewBaseService(serviceOptions)
	if err != nil {
		return
	}

	if options.URL != "" {
		err = baseService.SetServiceURL(options.URL)
		if err != nil {
			return
		}
	}

	service = &PowervsV1{
		Service: baseService,
	}

	return
}

// GetServiceURLForRegion returns the service URL to be used for the specified region
func GetServiceURLForRegion(region string) (string, error) {
	return "", fmt.Errorf("service does not support regional URLs")
}

// Clone makes a copy of "powervs" suitable for processing requests.
func (powervs *PowervsV1) Clone() *PowervsV1 {
	if core.IsNil(powervs) {
		return nil
	}
	clone := *powervs
	clone.Service = powervs.Service.Clone()
	return &clone
}

// SetServiceURL sets the service URL
func (powervs *PowervsV1) SetServiceURL(url string) error {
	return powervs.Service.SetServiceURL(url)
}

// GetServiceURL returns the service URL
func (powervs *PowervsV1) GetServiceURL() string {
	return powervs.Service.GetServiceURL()
}

// SetDefaultHeaders sets HTTP headers to be sent in every request
func (powervs *PowervsV1) SetDefaultHeaders(headers http.Header) {
	powervs.Service.SetDefaultHeaders(headers)
}

// SetEnableGzipCompression sets the service's EnableGzipCompression field
func (powervs *PowervsV1) SetEnableGzipCompression(enableGzip bool) {
	powervs.Service.SetEnableGzipCompression(enableGzip)
}

// GetEnableGzipCompression returns the service's EnableGzipCompression field
func (powervs *PowervsV1) GetEnableGzipCompression() bool {
	return powervs.Service.GetEnableGzipCompression()
}

// EnableRetries enables automatic retries for requests invoked for this service instance.
// If either parameter is specified as 0, then a default value is used instead.
func (powervs *PowervsV1) EnableRetries(maxRetries int, maxRetryInterval time.Duration) {
	powervs.Service.EnableRetries(maxRetries, maxRetryInterval)
}

// DisableRetries disables automatic retries for requests invoked for this service instance.
func (powervs *PowervsV1) DisableRetries() {
	powervs.Service.DisableRetries()
}

// ServiceBrokerAuthCallback : Returns an accessToken (and set cookie)
func (powervs *PowervsV1) ServiceBrokerAuthCallback(serviceBrokerAuthCallbackOptions *ServiceBrokerAuthCallbackOptions) (result *AccessToken, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerAuthCallbackWithContext(context.Background(), serviceBrokerAuthCallbackOptions)
}

// ServiceBrokerAuthCallbackWithContext is an alternate form of the ServiceBrokerAuthCallback method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerAuthCallbackWithContext(ctx context.Context, serviceBrokerAuthCallbackOptions *ServiceBrokerAuthCallbackOptions) (result *AccessToken, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(serviceBrokerAuthCallbackOptions, "serviceBrokerAuthCallbackOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/auth/v1/callback`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerAuthCallbackOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerAuthCallback")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAccessToken)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerAuthRegistrationCallback : Associates the user with a tenant and returns an accessToken
func (powervs *PowervsV1) ServiceBrokerAuthRegistrationCallback(serviceBrokerAuthRegistrationCallbackOptions *ServiceBrokerAuthRegistrationCallbackOptions) (result *AccessToken, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerAuthRegistrationCallbackWithContext(context.Background(), serviceBrokerAuthRegistrationCallbackOptions)
}

// ServiceBrokerAuthRegistrationCallbackWithContext is an alternate form of the ServiceBrokerAuthRegistrationCallback method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerAuthRegistrationCallbackWithContext(ctx context.Context, serviceBrokerAuthRegistrationCallbackOptions *ServiceBrokerAuthRegistrationCallbackOptions) (result *AccessToken, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(serviceBrokerAuthRegistrationCallbackOptions, "serviceBrokerAuthRegistrationCallbackOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/auth/v1/callback-registration`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerAuthRegistrationCallbackOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerAuthRegistrationCallback")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAccessToken)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerAuthDeviceCodePost : Request a authorization device code
func (powervs *PowervsV1) ServiceBrokerAuthDeviceCodePost(serviceBrokerAuthDeviceCodePostOptions *ServiceBrokerAuthDeviceCodePostOptions) (result *DeviceCode, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerAuthDeviceCodePostWithContext(context.Background(), serviceBrokerAuthDeviceCodePostOptions)
}

// ServiceBrokerAuthDeviceCodePostWithContext is an alternate form of the ServiceBrokerAuthDeviceCodePost method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerAuthDeviceCodePostWithContext(ctx context.Context, serviceBrokerAuthDeviceCodePostOptions *ServiceBrokerAuthDeviceCodePostOptions) (result *DeviceCode, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(serviceBrokerAuthDeviceCodePostOptions, "serviceBrokerAuthDeviceCodePostOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/auth/v1/device/code`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerAuthDeviceCodePostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerAuthDeviceCodePost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDeviceCode)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerAuthDeviceTokenPost : Poll for authorization device token
func (powervs *PowervsV1) ServiceBrokerAuthDeviceTokenPost(serviceBrokerAuthDeviceTokenPostOptions *ServiceBrokerAuthDeviceTokenPostOptions) (result *Token, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerAuthDeviceTokenPostWithContext(context.Background(), serviceBrokerAuthDeviceTokenPostOptions)
}

// ServiceBrokerAuthDeviceTokenPostWithContext is an alternate form of the ServiceBrokerAuthDeviceTokenPost method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerAuthDeviceTokenPostWithContext(ctx context.Context, serviceBrokerAuthDeviceTokenPostOptions *ServiceBrokerAuthDeviceTokenPostOptions) (result *Token, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceBrokerAuthDeviceTokenPostOptions, "serviceBrokerAuthDeviceTokenPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceBrokerAuthDeviceTokenPostOptions, "serviceBrokerAuthDeviceTokenPostOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/auth/v1/device/token`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerAuthDeviceTokenPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerAuthDeviceTokenPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if serviceBrokerAuthDeviceTokenPostOptions.DeviceCode != nil {
		body["deviceCode"] = serviceBrokerAuthDeviceTokenPostOptions.DeviceCode
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalToken)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerAuthInfoToken : Information about current access token
func (powervs *PowervsV1) ServiceBrokerAuthInfoToken(serviceBrokerAuthInfoTokenOptions *ServiceBrokerAuthInfoTokenOptions) (result *TokenExtra, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerAuthInfoTokenWithContext(context.Background(), serviceBrokerAuthInfoTokenOptions)
}

// ServiceBrokerAuthInfoTokenWithContext is an alternate form of the ServiceBrokerAuthInfoToken method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerAuthInfoTokenWithContext(ctx context.Context, serviceBrokerAuthInfoTokenOptions *ServiceBrokerAuthInfoTokenOptions) (result *TokenExtra, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(serviceBrokerAuthInfoTokenOptions, "serviceBrokerAuthInfoTokenOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/auth/v1/info/token`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerAuthInfoTokenOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerAuthInfoToken")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTokenExtra)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerAuthInfoUser : Information about current user
func (powervs *PowervsV1) ServiceBrokerAuthInfoUser(serviceBrokerAuthInfoUserOptions *ServiceBrokerAuthInfoUserOptions) (result *UserInfo, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerAuthInfoUserWithContext(context.Background(), serviceBrokerAuthInfoUserOptions)
}

// ServiceBrokerAuthInfoUserWithContext is an alternate form of the ServiceBrokerAuthInfoUser method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerAuthInfoUserWithContext(ctx context.Context, serviceBrokerAuthInfoUserOptions *ServiceBrokerAuthInfoUserOptions) (result *UserInfo, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(serviceBrokerAuthInfoUserOptions, "serviceBrokerAuthInfoUserOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/auth/v1/info/user`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerAuthInfoUserOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerAuthInfoUser")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalUserInfo)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerAuthLogin : Login
func (powervs *PowervsV1) ServiceBrokerAuthLogin(serviceBrokerAuthLoginOptions *ServiceBrokerAuthLoginOptions) (result *AccessToken, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerAuthLoginWithContext(context.Background(), serviceBrokerAuthLoginOptions)
}

// ServiceBrokerAuthLoginWithContext is an alternate form of the ServiceBrokerAuthLogin method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerAuthLoginWithContext(ctx context.Context, serviceBrokerAuthLoginOptions *ServiceBrokerAuthLoginOptions) (result *AccessToken, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(serviceBrokerAuthLoginOptions, "serviceBrokerAuthLoginOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/auth/v1/login`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerAuthLoginOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerAuthLogin")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if serviceBrokerAuthLoginOptions.UserID != nil {
		builder.AddQuery("user_id", fmt.Sprint(*serviceBrokerAuthLoginOptions.UserID))
	}
	if serviceBrokerAuthLoginOptions.RedirectURL != nil {
		builder.AddQuery("redirect_url", fmt.Sprint(*serviceBrokerAuthLoginOptions.RedirectURL))
	}
	if serviceBrokerAuthLoginOptions.AccessType != nil {
		builder.AddQuery("access_type", fmt.Sprint(*serviceBrokerAuthLoginOptions.AccessType))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAccessToken)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerAuthLogout : Logout
func (powervs *PowervsV1) ServiceBrokerAuthLogout(serviceBrokerAuthLogoutOptions *ServiceBrokerAuthLogoutOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerAuthLogoutWithContext(context.Background(), serviceBrokerAuthLogoutOptions)
}

// ServiceBrokerAuthLogoutWithContext is an alternate form of the ServiceBrokerAuthLogout method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerAuthLogoutWithContext(ctx context.Context, serviceBrokerAuthLogoutOptions *ServiceBrokerAuthLogoutOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(serviceBrokerAuthLogoutOptions, "serviceBrokerAuthLogoutOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/auth/v1/logout`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerAuthLogoutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerAuthLogout")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerAuthRegistration : Registration of a new Tenant and Login
func (powervs *PowervsV1) ServiceBrokerAuthRegistration(serviceBrokerAuthRegistrationOptions *ServiceBrokerAuthRegistrationOptions) (result *AccessToken, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerAuthRegistrationWithContext(context.Background(), serviceBrokerAuthRegistrationOptions)
}

// ServiceBrokerAuthRegistrationWithContext is an alternate form of the ServiceBrokerAuthRegistration method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerAuthRegistrationWithContext(ctx context.Context, serviceBrokerAuthRegistrationOptions *ServiceBrokerAuthRegistrationOptions) (result *AccessToken, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceBrokerAuthRegistrationOptions, "serviceBrokerAuthRegistrationOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceBrokerAuthRegistrationOptions, "serviceBrokerAuthRegistrationOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/auth/v1/registration`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerAuthRegistrationOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerAuthRegistration")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("tenant_id", fmt.Sprint(*serviceBrokerAuthRegistrationOptions.TenantID))
	builder.AddQuery("entitlement_id", fmt.Sprint(*serviceBrokerAuthRegistrationOptions.EntitlementID))
	builder.AddQuery("plan", fmt.Sprint(*serviceBrokerAuthRegistrationOptions.Plan))
	builder.AddQuery("icn", fmt.Sprint(*serviceBrokerAuthRegistrationOptions.Icn))
	builder.AddQuery("regions", strings.Join(serviceBrokerAuthRegistrationOptions.Regions, ","))
	if serviceBrokerAuthRegistrationOptions.RedirectURL != nil {
		builder.AddQuery("redirect_url", fmt.Sprint(*serviceBrokerAuthRegistrationOptions.RedirectURL))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalAccessToken)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerAuthTokenPost : Request a new token from a refresh token
func (powervs *PowervsV1) ServiceBrokerAuthTokenPost(serviceBrokerAuthTokenPostOptions *ServiceBrokerAuthTokenPostOptions) (result *Token, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerAuthTokenPostWithContext(context.Background(), serviceBrokerAuthTokenPostOptions)
}

// ServiceBrokerAuthTokenPostWithContext is an alternate form of the ServiceBrokerAuthTokenPost method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerAuthTokenPostWithContext(ctx context.Context, serviceBrokerAuthTokenPostOptions *ServiceBrokerAuthTokenPostOptions) (result *Token, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceBrokerAuthTokenPostOptions, "serviceBrokerAuthTokenPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceBrokerAuthTokenPostOptions, "serviceBrokerAuthTokenPostOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/auth/v1/token`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerAuthTokenPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerAuthTokenPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if serviceBrokerAuthTokenPostOptions.RefreshToken != nil {
		body["refreshToken"] = serviceBrokerAuthTokenPostOptions.RefreshToken
	}
	if serviceBrokerAuthTokenPostOptions.Source != nil {
		body["source"] = serviceBrokerAuthTokenPostOptions.Source
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalToken)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// BluemixServiceInstanceGet : Get the current state information associated with the service instance
func (powervs *PowervsV1) BluemixServiceInstanceGet(bluemixServiceInstanceGetOptions *BluemixServiceInstanceGetOptions) (result *ServiceInstance, response *core.DetailedResponse, err error) {
	return powervs.BluemixServiceInstanceGetWithContext(context.Background(), bluemixServiceInstanceGetOptions)
}

// BluemixServiceInstanceGetWithContext is an alternate form of the BluemixServiceInstanceGet method which supports a Context parameter
func (powervs *PowervsV1) BluemixServiceInstanceGetWithContext(ctx context.Context, bluemixServiceInstanceGetOptions *BluemixServiceInstanceGetOptions) (result *ServiceInstance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(bluemixServiceInstanceGetOptions, "bluemixServiceInstanceGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(bluemixServiceInstanceGetOptions, "bluemixServiceInstanceGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *bluemixServiceInstanceGetOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/bluemix_v1/service_instances/{instance_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range bluemixServiceInstanceGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "BluemixServiceInstanceGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalServiceInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// BluemixServiceInstancePut : Update (disable or enable) the state of a provisioned service instance
func (powervs *PowervsV1) BluemixServiceInstancePut(bluemixServiceInstancePutOptions *BluemixServiceInstancePutOptions) (result *ServiceInstance, response *core.DetailedResponse, err error) {
	return powervs.BluemixServiceInstancePutWithContext(context.Background(), bluemixServiceInstancePutOptions)
}

// BluemixServiceInstancePutWithContext is an alternate form of the BluemixServiceInstancePut method which supports a Context parameter
func (powervs *PowervsV1) BluemixServiceInstancePutWithContext(ctx context.Context, bluemixServiceInstancePutOptions *BluemixServiceInstancePutOptions) (result *ServiceInstance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(bluemixServiceInstancePutOptions, "bluemixServiceInstancePutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(bluemixServiceInstancePutOptions, "bluemixServiceInstancePutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *bluemixServiceInstancePutOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/bluemix_v1/service_instances/{instance_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range bluemixServiceInstancePutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "BluemixServiceInstancePut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if bluemixServiceInstancePutOptions.Enabled != nil {
		body["enabled"] = bluemixServiceInstancePutOptions.Enabled
	}
	if bluemixServiceInstancePutOptions.InitiatorID != nil {
		body["initiator_id"] = bluemixServiceInstancePutOptions.InitiatorID
	}
	if bluemixServiceInstancePutOptions.ReasonCode != nil {
		body["reason_code"] = bluemixServiceInstancePutOptions.ReasonCode
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalServiceInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// CatalogGet : get the catalog of services that the service broker offers
func (powervs *PowervsV1) CatalogGet(catalogGetOptions *CatalogGetOptions) (result *Catalog, response *core.DetailedResponse, err error) {
	return powervs.CatalogGetWithContext(context.Background(), catalogGetOptions)
}

// CatalogGetWithContext is an alternate form of the CatalogGet method which supports a Context parameter
func (powervs *PowervsV1) CatalogGetWithContext(ctx context.Context, catalogGetOptions *CatalogGetOptions) (result *Catalog, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(catalogGetOptions, "catalogGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(catalogGetOptions, "catalogGetOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/v2/catalog`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range catalogGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "CatalogGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if catalogGetOptions.XBrokerApiVersion != nil {
		builder.AddHeader("X-Broker-API-Version", fmt.Sprint(*catalogGetOptions.XBrokerApiVersion))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCatalog)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DatacentersGetall : Get all Datacenters information and capabilities
func (powervs *PowervsV1) DatacentersGetall(v1DatacentersGetallOptions *V1DatacentersGetallOptions) (result *Datacenters, response *core.DetailedResponse, err error) {
	return powervs.DatacentersGetallWithContext(context.Background(), v1DatacentersGetallOptions)
}

// DatacentersGetallWithContext is an alternate form of the DatacentersGetall method which supports a Context parameter
func (powervs *PowervsV1) DatacentersGetallWithContext(ctx context.Context, v1DatacentersGetallOptions *V1DatacentersGetallOptions) (result *Datacenters, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(v1DatacentersGetallOptions, "v1DatacentersGetallOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/v1/datacenters`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v1DatacentersGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "DatacentersGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if v1DatacentersGetallOptions.Accept != nil {
		builder.AddHeader("Accept", fmt.Sprint(*v1DatacentersGetallOptions.Accept))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDatacenters)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// DatacentersGet : Get a Datacenter's information and capabilities
func (powervs *PowervsV1) DatacentersGet(v1DatacentersGetOptions *V1DatacentersGetOptions) (result *Datacenter, response *core.DetailedResponse, err error) {
	return powervs.DatacentersGetWithContext(context.Background(), v1DatacentersGetOptions)
}

// DatacentersGetWithContext is an alternate form of the DatacentersGet method which supports a Context parameter
func (powervs *PowervsV1) DatacentersGetWithContext(ctx context.Context, v1DatacentersGetOptions *V1DatacentersGetOptions) (result *Datacenter, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v1DatacentersGetOptions, "v1DatacentersGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v1DatacentersGetOptions, "v1DatacentersGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"datacenter_region": *v1DatacentersGetOptions.DatacenterRegion,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/v1/datacenters/{datacenter_region}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range v1DatacentersGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "DatacentersGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if v1DatacentersGetOptions.Accept != nil {
		builder.AddHeader("Accept", fmt.Sprint(*v1DatacentersGetOptions.Accept))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDatacenter)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerHardwareplatformsGet : Available hardware statistics and limits
func (powervs *PowervsV1) ServiceBrokerHardwareplatformsGet(serviceBrokerHardwareplatformsGetOptions *ServiceBrokerHardwareplatformsGetOptions) (result map[string]HardwarePlatform, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerHardwareplatformsGetWithContext(context.Background(), serviceBrokerHardwareplatformsGetOptions)
}

// ServiceBrokerHardwareplatformsGetWithContext is an alternate form of the ServiceBrokerHardwareplatformsGet method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerHardwareplatformsGetWithContext(ctx context.Context, serviceBrokerHardwareplatformsGetOptions *ServiceBrokerHardwareplatformsGetOptions) (result map[string]HardwarePlatform, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(serviceBrokerHardwareplatformsGetOptions, "serviceBrokerHardwareplatformsGetOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/broker/v1/hardware-platforms`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerHardwareplatformsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerHardwareplatformsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if serviceBrokerHardwareplatformsGetOptions.RegionZone != nil {
		builder.AddQuery("regionZone", fmt.Sprint(*serviceBrokerHardwareplatformsGetOptions.RegionZone))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalHardwarePlatform)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerHealthHead : Get current server health
func (powervs *PowervsV1) ServiceBrokerHealthHead(serviceBrokerHealthHeadOptions *ServiceBrokerHealthHeadOptions) (response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerHealthHeadWithContext(context.Background(), serviceBrokerHealthHeadOptions)
}

// ServiceBrokerHealthHeadWithContext is an alternate form of the ServiceBrokerHealthHead method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerHealthHeadWithContext(ctx context.Context, serviceBrokerHealthHeadOptions *ServiceBrokerHealthHeadOptions) (response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(serviceBrokerHealthHeadOptions, "serviceBrokerHealthHeadOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.HEAD)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/broker/v1/health`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerHealthHeadOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerHealthHead")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	response, err = powervs.Service.Request(request, nil)

	return
}

// ServiceBrokerHealth : Get current server health
func (powervs *PowervsV1) ServiceBrokerHealth(serviceBrokerHealthOptions *ServiceBrokerHealthOptions) (result *Health, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerHealthWithContext(context.Background(), serviceBrokerHealthOptions)
}

// ServiceBrokerHealthWithContext is an alternate form of the ServiceBrokerHealth method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerHealthWithContext(ctx context.Context, serviceBrokerHealthOptions *ServiceBrokerHealthOptions) (result *Health, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(serviceBrokerHealthOptions, "serviceBrokerHealthOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/broker/v1/health`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerHealthOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerHealth")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalHealth)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerTestTimeout : Get current server version
func (powervs *PowervsV1) ServiceBrokerTestTimeout(serviceBrokerTestTimeoutOptions *ServiceBrokerTestTimeoutOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerTestTimeoutWithContext(context.Background(), serviceBrokerTestTimeoutOptions)
}

// ServiceBrokerTestTimeoutWithContext is an alternate form of the ServiceBrokerTestTimeout method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerTestTimeoutWithContext(ctx context.Context, serviceBrokerTestTimeoutOptions *ServiceBrokerTestTimeoutOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceBrokerTestTimeoutOptions, "serviceBrokerTestTimeoutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceBrokerTestTimeoutOptions, "serviceBrokerTestTimeoutOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/broker/v1/test/timeout`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerTestTimeoutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerTestTimeout")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	builder.AddQuery("t", fmt.Sprint(*serviceBrokerTestTimeoutOptions.T))

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerVersion : Get current server version
func (powervs *PowervsV1) ServiceBrokerVersion(serviceBrokerVersionOptions *ServiceBrokerVersionOptions) (result *Version, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerVersionWithContext(context.Background(), serviceBrokerVersionOptions)
}

// ServiceBrokerVersionWithContext is an alternate form of the ServiceBrokerVersion method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerVersionWithContext(ctx context.Context, serviceBrokerVersionOptions *ServiceBrokerVersionOptions) (result *Version, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(serviceBrokerVersionOptions, "serviceBrokerVersionOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/broker/v1/version`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerVersionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerVersion")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVersion)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// InternalV1PowervsInstancesGet : Get List of PowerVS Cloud Instances
func (powervs *PowervsV1) InternalV1PowervsInstancesGet(internalV1PowervsInstancesGetOptions *InternalV1PowervsInstancesGetOptions) (result *PowerVsInstances, response *core.DetailedResponse, err error) {
	return powervs.InternalV1PowervsInstancesGetWithContext(context.Background(), internalV1PowervsInstancesGetOptions)
}

// InternalV1PowervsInstancesGetWithContext is an alternate form of the InternalV1PowervsInstancesGet method which supports a Context parameter
func (powervs *PowervsV1) InternalV1PowervsInstancesGetWithContext(ctx context.Context, internalV1PowervsInstancesGetOptions *InternalV1PowervsInstancesGetOptions) (result *PowerVsInstances, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(internalV1PowervsInstancesGetOptions, "internalV1PowervsInstancesGetOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/internal/v1/powervs/instances`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range internalV1PowervsInstancesGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "InternalV1PowervsInstancesGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if internalV1PowervsInstancesGetOptions.PowervsLocation != nil {
		builder.AddQuery("powervs_location", fmt.Sprint(*internalV1PowervsInstancesGetOptions.PowervsLocation))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPowerVsInstances)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// InternalV1PowervsLocationsTransitgatewayGet : Get List of PER enabled PowerVS Locations
func (powervs *PowervsV1) InternalV1PowervsLocationsTransitgatewayGet(internalV1PowervsLocationsTransitgatewayGetOptions *InternalV1PowervsLocationsTransitgatewayGetOptions) (result *TransitGatewayLocations, response *core.DetailedResponse, err error) {
	return powervs.InternalV1PowervsLocationsTransitgatewayGetWithContext(context.Background(), internalV1PowervsLocationsTransitgatewayGetOptions)
}

// InternalV1PowervsLocationsTransitgatewayGetWithContext is an alternate form of the InternalV1PowervsLocationsTransitgatewayGet method which supports a Context parameter
func (powervs *PowervsV1) InternalV1PowervsLocationsTransitgatewayGetWithContext(ctx context.Context, internalV1PowervsLocationsTransitgatewayGetOptions *InternalV1PowervsLocationsTransitgatewayGetOptions) (result *TransitGatewayLocations, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(internalV1PowervsLocationsTransitgatewayGetOptions, "internalV1PowervsLocationsTransitgatewayGetOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/internal/v1/powervs/locations/transit-gateway`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range internalV1PowervsLocationsTransitgatewayGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "InternalV1PowervsLocationsTransitgatewayGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayLocations)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// InternalV1StorageRegionsStoragePoolsGetall : Get the current storage pools settings for a region-zone
func (powervs *PowervsV1) InternalV1StorageRegionsStoragePoolsGetall(internalV1StorageRegionsStoragePoolsGetallOptions *InternalV1StorageRegionsStoragePoolsGetallOptions) (result []StoragePool, response *core.DetailedResponse, err error) {
	return powervs.InternalV1StorageRegionsStoragePoolsGetallWithContext(context.Background(), internalV1StorageRegionsStoragePoolsGetallOptions)
}

// InternalV1StorageRegionsStoragePoolsGetallWithContext is an alternate form of the InternalV1StorageRegionsStoragePoolsGetall method which supports a Context parameter
func (powervs *PowervsV1) InternalV1StorageRegionsStoragePoolsGetallWithContext(ctx context.Context, internalV1StorageRegionsStoragePoolsGetallOptions *InternalV1StorageRegionsStoragePoolsGetallOptions) (result []StoragePool, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(internalV1StorageRegionsStoragePoolsGetallOptions, "internalV1StorageRegionsStoragePoolsGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(internalV1StorageRegionsStoragePoolsGetallOptions, "internalV1StorageRegionsStoragePoolsGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"region_zone_id": *internalV1StorageRegionsStoragePoolsGetallOptions.RegionZoneID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/internal/v1/storage/regions/{region_zone_id}/storage-pools`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range internalV1StorageRegionsStoragePoolsGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "InternalV1StorageRegionsStoragePoolsGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStoragePool)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// InternalV1StorageRegionsStoragePoolsGet : Get the settings for given pool name
func (powervs *PowervsV1) InternalV1StorageRegionsStoragePoolsGet(internalV1StorageRegionsStoragePoolsGetOptions *InternalV1StorageRegionsStoragePoolsGetOptions) (result []StoragePool, response *core.DetailedResponse, err error) {
	return powervs.InternalV1StorageRegionsStoragePoolsGetWithContext(context.Background(), internalV1StorageRegionsStoragePoolsGetOptions)
}

// InternalV1StorageRegionsStoragePoolsGetWithContext is an alternate form of the InternalV1StorageRegionsStoragePoolsGet method which supports a Context parameter
func (powervs *PowervsV1) InternalV1StorageRegionsStoragePoolsGetWithContext(ctx context.Context, internalV1StorageRegionsStoragePoolsGetOptions *InternalV1StorageRegionsStoragePoolsGetOptions) (result []StoragePool, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(internalV1StorageRegionsStoragePoolsGetOptions, "internalV1StorageRegionsStoragePoolsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(internalV1StorageRegionsStoragePoolsGetOptions, "internalV1StorageRegionsStoragePoolsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"region_zone_id": *internalV1StorageRegionsStoragePoolsGetOptions.RegionZoneID,
		"storage_pool_name": *internalV1StorageRegionsStoragePoolsGetOptions.StoragePoolName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/internal/v1/storage/regions/{region_zone_id}/storage-pools/{storage_pool_name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range internalV1StorageRegionsStoragePoolsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "InternalV1StorageRegionsStoragePoolsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStoragePool)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// InternalV1StorageRegionsStoragePoolsPut : Update the settings for given pool name
func (powervs *PowervsV1) InternalV1StorageRegionsStoragePoolsPut(internalV1StorageRegionsStoragePoolsPutOptions *InternalV1StorageRegionsStoragePoolsPutOptions) (result *StoragePool, response *core.DetailedResponse, err error) {
	return powervs.InternalV1StorageRegionsStoragePoolsPutWithContext(context.Background(), internalV1StorageRegionsStoragePoolsPutOptions)
}

// InternalV1StorageRegionsStoragePoolsPutWithContext is an alternate form of the InternalV1StorageRegionsStoragePoolsPut method which supports a Context parameter
func (powervs *PowervsV1) InternalV1StorageRegionsStoragePoolsPutWithContext(ctx context.Context, internalV1StorageRegionsStoragePoolsPutOptions *InternalV1StorageRegionsStoragePoolsPutOptions) (result *StoragePool, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(internalV1StorageRegionsStoragePoolsPutOptions, "internalV1StorageRegionsStoragePoolsPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(internalV1StorageRegionsStoragePoolsPutOptions, "internalV1StorageRegionsStoragePoolsPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"region_zone_id": *internalV1StorageRegionsStoragePoolsPutOptions.RegionZoneID,
		"storage_pool_name": *internalV1StorageRegionsStoragePoolsPutOptions.StoragePoolName,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/internal/v1/storage/regions/{region_zone_id}/storage-pools/{storage_pool_name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range internalV1StorageRegionsStoragePoolsPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "InternalV1StorageRegionsStoragePoolsPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if internalV1StorageRegionsStoragePoolsPutOptions.DisplayName != nil {
		body["displayName"] = internalV1StorageRegionsStoragePoolsPutOptions.DisplayName
	}
	if internalV1StorageRegionsStoragePoolsPutOptions.DrEnabled != nil {
		body["drEnabled"] = internalV1StorageRegionsStoragePoolsPutOptions.DrEnabled
	}
	if internalV1StorageRegionsStoragePoolsPutOptions.OverrideThresholds != nil {
		body["overrideThresholds"] = internalV1StorageRegionsStoragePoolsPutOptions.OverrideThresholds
	}
	if internalV1StorageRegionsStoragePoolsPutOptions.State != nil {
		body["state"] = internalV1StorageRegionsStoragePoolsPutOptions.State
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStoragePool)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// InternalV1StorageRegionsThresholdsGet : Get the current default threshold settings for a region-zone
func (powervs *PowervsV1) InternalV1StorageRegionsThresholdsGet(internalV1StorageRegionsThresholdsGetOptions *InternalV1StorageRegionsThresholdsGetOptions) (result *Thresholds, response *core.DetailedResponse, err error) {
	return powervs.InternalV1StorageRegionsThresholdsGetWithContext(context.Background(), internalV1StorageRegionsThresholdsGetOptions)
}

// InternalV1StorageRegionsThresholdsGetWithContext is an alternate form of the InternalV1StorageRegionsThresholdsGet method which supports a Context parameter
func (powervs *PowervsV1) InternalV1StorageRegionsThresholdsGetWithContext(ctx context.Context, internalV1StorageRegionsThresholdsGetOptions *InternalV1StorageRegionsThresholdsGetOptions) (result *Thresholds, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(internalV1StorageRegionsThresholdsGetOptions, "internalV1StorageRegionsThresholdsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(internalV1StorageRegionsThresholdsGetOptions, "internalV1StorageRegionsThresholdsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"region_zone_id": *internalV1StorageRegionsThresholdsGetOptions.RegionZoneID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/internal/v1/storage/regions/{region_zone_id}/thresholds`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range internalV1StorageRegionsThresholdsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "InternalV1StorageRegionsThresholdsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalThresholds)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// InternalV1StorageRegionsThresholdsPut : Update a default threshold setting for a region-zone
func (powervs *PowervsV1) InternalV1StorageRegionsThresholdsPut(internalV1StorageRegionsThresholdsPutOptions *InternalV1StorageRegionsThresholdsPutOptions) (result *Thresholds, response *core.DetailedResponse, err error) {
	return powervs.InternalV1StorageRegionsThresholdsPutWithContext(context.Background(), internalV1StorageRegionsThresholdsPutOptions)
}

// InternalV1StorageRegionsThresholdsPutWithContext is an alternate form of the InternalV1StorageRegionsThresholdsPut method which supports a Context parameter
func (powervs *PowervsV1) InternalV1StorageRegionsThresholdsPutWithContext(ctx context.Context, internalV1StorageRegionsThresholdsPutOptions *InternalV1StorageRegionsThresholdsPutOptions) (result *Thresholds, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(internalV1StorageRegionsThresholdsPutOptions, "internalV1StorageRegionsThresholdsPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(internalV1StorageRegionsThresholdsPutOptions, "internalV1StorageRegionsThresholdsPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"region_zone_id": *internalV1StorageRegionsThresholdsPutOptions.RegionZoneID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/internal/v1/storage/regions/{region_zone_id}/thresholds`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range internalV1StorageRegionsThresholdsPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "InternalV1StorageRegionsThresholdsPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if internalV1StorageRegionsThresholdsPutOptions.Capacity != nil {
		body["capacity"] = internalV1StorageRegionsThresholdsPutOptions.Capacity
	}
	if internalV1StorageRegionsThresholdsPutOptions.Overcommit != nil {
		body["overcommit"] = internalV1StorageRegionsThresholdsPutOptions.Overcommit
	}
	if internalV1StorageRegionsThresholdsPutOptions.PhysicalCapacity != nil {
		body["physicalCapacity"] = internalV1StorageRegionsThresholdsPutOptions.PhysicalCapacity
	}
	if internalV1StorageRegionsThresholdsPutOptions.VdiskCapacity != nil {
		body["vdiskCapacity"] = internalV1StorageRegionsThresholdsPutOptions.VdiskCapacity
	}
	if internalV1StorageRegionsThresholdsPutOptions.VdiskLimit != nil {
		body["vdiskLimit"] = internalV1StorageRegionsThresholdsPutOptions.VdiskLimit
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalThresholds)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// InternalV1TransitgatewayGet : Get the Cloud Instance Transit Gateway information
func (powervs *PowervsV1) InternalV1TransitgatewayGet(internalV1TransitgatewayGetOptions *InternalV1TransitgatewayGetOptions) (result *TransitGatewayInstance, response *core.DetailedResponse, err error) {
	return powervs.InternalV1TransitgatewayGetWithContext(context.Background(), internalV1TransitgatewayGetOptions)
}

// InternalV1TransitgatewayGetWithContext is an alternate form of the InternalV1TransitgatewayGet method which supports a Context parameter
func (powervs *PowervsV1) InternalV1TransitgatewayGetWithContext(ctx context.Context, internalV1TransitgatewayGetOptions *InternalV1TransitgatewayGetOptions) (result *TransitGatewayInstance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(internalV1TransitgatewayGetOptions, "internalV1TransitgatewayGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(internalV1TransitgatewayGetOptions, "internalV1TransitgatewayGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"powervs_service_crn": *internalV1TransitgatewayGetOptions.PowervsServiceCRN,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/internal/v1/transit-gateway/{powervs_service_crn}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range internalV1TransitgatewayGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "InternalV1TransitgatewayGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if internalV1TransitgatewayGetOptions.IBMUserAuthorization != nil {
		builder.AddHeader("IBM-UserAuthorization", fmt.Sprint(*internalV1TransitgatewayGetOptions.IBMUserAuthorization))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTransitGatewayInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerOpenstacksGet : List all OpenStack instances being managed
func (powervs *PowervsV1) ServiceBrokerOpenstacksGet(serviceBrokerOpenstacksGetOptions *ServiceBrokerOpenstacksGetOptions) (result *OpenStacks, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerOpenstacksGetWithContext(context.Background(), serviceBrokerOpenstacksGetOptions)
}

// ServiceBrokerOpenstacksGetWithContext is an alternate form of the ServiceBrokerOpenstacksGet method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerOpenstacksGetWithContext(ctx context.Context, serviceBrokerOpenstacksGetOptions *ServiceBrokerOpenstacksGetOptions) (result *OpenStacks, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(serviceBrokerOpenstacksGetOptions, "serviceBrokerOpenstacksGetOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/broker/v1/openstacks`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerOpenstacksGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerOpenstacksGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalOpenStacks)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerOpenstacksPost : Create a new OpenStack instance to be managed
func (powervs *PowervsV1) ServiceBrokerOpenstacksPost(serviceBrokerOpenstacksPostOptions *ServiceBrokerOpenstacksPostOptions) (result *OpenStack, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerOpenstacksPostWithContext(context.Background(), serviceBrokerOpenstacksPostOptions)
}

// ServiceBrokerOpenstacksPostWithContext is an alternate form of the ServiceBrokerOpenstacksPost method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerOpenstacksPostWithContext(ctx context.Context, serviceBrokerOpenstacksPostOptions *ServiceBrokerOpenstacksPostOptions) (result *OpenStack, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceBrokerOpenstacksPostOptions, "serviceBrokerOpenstacksPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceBrokerOpenstacksPostOptions, "serviceBrokerOpenstacksPostOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/broker/v1/openstacks`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerOpenstacksPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerOpenstacksPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if serviceBrokerOpenstacksPostOptions.IPAddress != nil {
		body["ipAddress"] = serviceBrokerOpenstacksPostOptions.IPAddress
	}
	if serviceBrokerOpenstacksPostOptions.Name != nil {
		body["name"] = serviceBrokerOpenstacksPostOptions.Name
	}
	if serviceBrokerOpenstacksPostOptions.Region != nil {
		body["region"] = serviceBrokerOpenstacksPostOptions.Region
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalOpenStack)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerOpenstacksOpenstackGet : List account information for all pvm instances on hostname
func (powervs *PowervsV1) ServiceBrokerOpenstacksOpenstackGet(serviceBrokerOpenstacksOpenstackGetOptions *ServiceBrokerOpenstacksOpenstackGetOptions) (result *OpenStackInfo, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerOpenstacksOpenstackGetWithContext(context.Background(), serviceBrokerOpenstacksOpenstackGetOptions)
}

// ServiceBrokerOpenstacksOpenstackGetWithContext is an alternate form of the ServiceBrokerOpenstacksOpenstackGet method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerOpenstacksOpenstackGetWithContext(ctx context.Context, serviceBrokerOpenstacksOpenstackGetOptions *ServiceBrokerOpenstacksOpenstackGetOptions) (result *OpenStackInfo, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceBrokerOpenstacksOpenstackGetOptions, "serviceBrokerOpenstacksOpenstackGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceBrokerOpenstacksOpenstackGetOptions, "serviceBrokerOpenstacksOpenstackGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"openstack_id": *serviceBrokerOpenstacksOpenstackGetOptions.OpenstackID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/broker/v1/openstacks/{openstack_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerOpenstacksOpenstackGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerOpenstacksOpenstackGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalOpenStackInfo)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerOpenstacksHostsGet : List account information for all pvm instances on hostname
func (powervs *PowervsV1) ServiceBrokerOpenstacksHostsGet(serviceBrokerOpenstacksHostsGetOptions *ServiceBrokerOpenstacksHostsGetOptions) (result *HostInfo, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerOpenstacksHostsGetWithContext(context.Background(), serviceBrokerOpenstacksHostsGetOptions)
}

// ServiceBrokerOpenstacksHostsGetWithContext is an alternate form of the ServiceBrokerOpenstacksHostsGet method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerOpenstacksHostsGetWithContext(ctx context.Context, serviceBrokerOpenstacksHostsGetOptions *ServiceBrokerOpenstacksHostsGetOptions) (result *HostInfo, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceBrokerOpenstacksHostsGetOptions, "serviceBrokerOpenstacksHostsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceBrokerOpenstacksHostsGetOptions, "serviceBrokerOpenstacksHostsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"hostname": *serviceBrokerOpenstacksHostsGetOptions.Hostname,
		"openstack_id": *serviceBrokerOpenstacksHostsGetOptions.OpenstackID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/broker/v1/openstacks/{openstack_id}/hosts/{hostname}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerOpenstacksHostsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerOpenstacksHostsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalHostInfo)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerOpenstacksServersGet : List account information for a pvm instance
func (powervs *PowervsV1) ServiceBrokerOpenstacksServersGet(serviceBrokerOpenstacksServersGetOptions *ServiceBrokerOpenstacksServersGetOptions) (result *HostPvmInstance, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerOpenstacksServersGetWithContext(context.Background(), serviceBrokerOpenstacksServersGetOptions)
}

// ServiceBrokerOpenstacksServersGetWithContext is an alternate form of the ServiceBrokerOpenstacksServersGet method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerOpenstacksServersGetWithContext(ctx context.Context, serviceBrokerOpenstacksServersGetOptions *ServiceBrokerOpenstacksServersGetOptions) (result *HostPvmInstance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceBrokerOpenstacksServersGetOptions, "serviceBrokerOpenstacksServersGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceBrokerOpenstacksServersGetOptions, "serviceBrokerOpenstacksServersGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"openstack_id": *serviceBrokerOpenstacksServersGetOptions.OpenstackID,
		"pvm_instance_id": *serviceBrokerOpenstacksServersGetOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/broker/v1/openstacks/{openstack_id}/servers/{pvm_instance_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerOpenstacksServersGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerOpenstacksServersGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalHostPvmInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudconnectionsGetall : Get all cloud connections in this cloud instance
func (powervs *PowervsV1) PcloudCloudconnectionsGetall(pcloudCloudconnectionsGetallOptions *PcloudCloudconnectionsGetallOptions) (result *CloudConnections, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudconnectionsGetallWithContext(context.Background(), pcloudCloudconnectionsGetallOptions)
}

// PcloudCloudconnectionsGetallWithContext is an alternate form of the PcloudCloudconnectionsGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudconnectionsGetallWithContext(ctx context.Context, pcloudCloudconnectionsGetallOptions *PcloudCloudconnectionsGetallOptions) (result *CloudConnections, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudconnectionsGetallOptions, "pcloudCloudconnectionsGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudconnectionsGetallOptions, "pcloudCloudconnectionsGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudconnectionsGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/cloud-connections`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudconnectionsGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudconnectionsGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCloudConnections)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudconnectionsPost : Create a new cloud connection
func (powervs *PowervsV1) PcloudCloudconnectionsPost(pcloudCloudconnectionsPostOptions *PcloudCloudconnectionsPostOptions) (result *CloudConnection, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudconnectionsPostWithContext(context.Background(), pcloudCloudconnectionsPostOptions)
}

// PcloudCloudconnectionsPostWithContext is an alternate form of the PcloudCloudconnectionsPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudconnectionsPostWithContext(ctx context.Context, pcloudCloudconnectionsPostOptions *PcloudCloudconnectionsPostOptions) (result *CloudConnection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudconnectionsPostOptions, "pcloudCloudconnectionsPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudconnectionsPostOptions, "pcloudCloudconnectionsPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudconnectionsPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/cloud-connections`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudconnectionsPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudconnectionsPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudCloudconnectionsPostOptions.Name != nil {
		body["name"] = pcloudCloudconnectionsPostOptions.Name
	}
	if pcloudCloudconnectionsPostOptions.Speed != nil {
		body["speed"] = pcloudCloudconnectionsPostOptions.Speed
	}
	if pcloudCloudconnectionsPostOptions.Classic != nil {
		body["classic"] = pcloudCloudconnectionsPostOptions.Classic
	}
	if pcloudCloudconnectionsPostOptions.GlobalRouting != nil {
		body["globalRouting"] = pcloudCloudconnectionsPostOptions.GlobalRouting
	}
	if pcloudCloudconnectionsPostOptions.Metered != nil {
		body["metered"] = pcloudCloudconnectionsPostOptions.Metered
	}
	if pcloudCloudconnectionsPostOptions.Subnets != nil {
		body["subnets"] = pcloudCloudconnectionsPostOptions.Subnets
	}
	if pcloudCloudconnectionsPostOptions.TransitEnabled != nil {
		body["transitEnabled"] = pcloudCloudconnectionsPostOptions.TransitEnabled
	}
	if pcloudCloudconnectionsPostOptions.VPC != nil {
		body["vpc"] = pcloudCloudconnectionsPostOptions.VPC
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCloudConnection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudconnectionsVirtualprivatecloudsGetall : Get all virtual private cloud connections in this cloud instance
func (powervs *PowervsV1) PcloudCloudconnectionsVirtualprivatecloudsGetall(pcloudCloudconnectionsVirtualprivatecloudsGetallOptions *PcloudCloudconnectionsVirtualprivatecloudsGetallOptions) (result *CloudConnectionVirtualPrivateClouds, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudconnectionsVirtualprivatecloudsGetallWithContext(context.Background(), pcloudCloudconnectionsVirtualprivatecloudsGetallOptions)
}

// PcloudCloudconnectionsVirtualprivatecloudsGetallWithContext is an alternate form of the PcloudCloudconnectionsVirtualprivatecloudsGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudconnectionsVirtualprivatecloudsGetallWithContext(ctx context.Context, pcloudCloudconnectionsVirtualprivatecloudsGetallOptions *PcloudCloudconnectionsVirtualprivatecloudsGetallOptions) (result *CloudConnectionVirtualPrivateClouds, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudconnectionsVirtualprivatecloudsGetallOptions, "pcloudCloudconnectionsVirtualprivatecloudsGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudconnectionsVirtualprivatecloudsGetallOptions, "pcloudCloudconnectionsVirtualprivatecloudsGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudconnectionsVirtualprivatecloudsGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/cloud-connections-virtual-private-clouds`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudconnectionsVirtualprivatecloudsGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudconnectionsVirtualprivatecloudsGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCloudConnectionVirtualPrivateClouds)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudconnectionsDelete : Delete a Cloud Connection
func (powervs *PowervsV1) PcloudCloudconnectionsDelete(pcloudCloudconnectionsDeleteOptions *PcloudCloudconnectionsDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudconnectionsDeleteWithContext(context.Background(), pcloudCloudconnectionsDeleteOptions)
}

// PcloudCloudconnectionsDeleteWithContext is an alternate form of the PcloudCloudconnectionsDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudconnectionsDeleteWithContext(ctx context.Context, pcloudCloudconnectionsDeleteOptions *PcloudCloudconnectionsDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudconnectionsDeleteOptions, "pcloudCloudconnectionsDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudconnectionsDeleteOptions, "pcloudCloudconnectionsDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudconnectionsDeleteOptions.CloudInstanceID,
		"cloud_connection_id": *pcloudCloudconnectionsDeleteOptions.CloudConnectionID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/cloud-connections/{cloud_connection_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudconnectionsDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudconnectionsDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudconnectionsGet : Get a cloud connection's state/information
func (powervs *PowervsV1) PcloudCloudconnectionsGet(pcloudCloudconnectionsGetOptions *PcloudCloudconnectionsGetOptions) (result *CloudConnection, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudconnectionsGetWithContext(context.Background(), pcloudCloudconnectionsGetOptions)
}

// PcloudCloudconnectionsGetWithContext is an alternate form of the PcloudCloudconnectionsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudconnectionsGetWithContext(ctx context.Context, pcloudCloudconnectionsGetOptions *PcloudCloudconnectionsGetOptions) (result *CloudConnection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudconnectionsGetOptions, "pcloudCloudconnectionsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudconnectionsGetOptions, "pcloudCloudconnectionsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudconnectionsGetOptions.CloudInstanceID,
		"cloud_connection_id": *pcloudCloudconnectionsGetOptions.CloudConnectionID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/cloud-connections/{cloud_connection_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudconnectionsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudconnectionsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCloudConnection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudconnectionsPut : Update a Cloud Connection
func (powervs *PowervsV1) PcloudCloudconnectionsPut(pcloudCloudconnectionsPutOptions *PcloudCloudconnectionsPutOptions) (result *CloudConnection, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudconnectionsPutWithContext(context.Background(), pcloudCloudconnectionsPutOptions)
}

// PcloudCloudconnectionsPutWithContext is an alternate form of the PcloudCloudconnectionsPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudconnectionsPutWithContext(ctx context.Context, pcloudCloudconnectionsPutOptions *PcloudCloudconnectionsPutOptions) (result *CloudConnection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudconnectionsPutOptions, "pcloudCloudconnectionsPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudconnectionsPutOptions, "pcloudCloudconnectionsPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudconnectionsPutOptions.CloudInstanceID,
		"cloud_connection_id": *pcloudCloudconnectionsPutOptions.CloudConnectionID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/cloud-connections/{cloud_connection_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudconnectionsPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudconnectionsPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudCloudconnectionsPutOptions.Classic != nil {
		body["classic"] = pcloudCloudconnectionsPutOptions.Classic
	}
	if pcloudCloudconnectionsPutOptions.GlobalRouting != nil {
		body["globalRouting"] = pcloudCloudconnectionsPutOptions.GlobalRouting
	}
	if pcloudCloudconnectionsPutOptions.Metered != nil {
		body["metered"] = pcloudCloudconnectionsPutOptions.Metered
	}
	if pcloudCloudconnectionsPutOptions.Name != nil {
		body["name"] = pcloudCloudconnectionsPutOptions.Name
	}
	if pcloudCloudconnectionsPutOptions.Speed != nil {
		body["speed"] = pcloudCloudconnectionsPutOptions.Speed
	}
	if pcloudCloudconnectionsPutOptions.VPC != nil {
		body["vpc"] = pcloudCloudconnectionsPutOptions.VPC
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCloudConnection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudconnectionsNetworksDelete : Detach a network from a Cloud Connection
func (powervs *PowervsV1) PcloudCloudconnectionsNetworksDelete(pcloudCloudconnectionsNetworksDeleteOptions *PcloudCloudconnectionsNetworksDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudconnectionsNetworksDeleteWithContext(context.Background(), pcloudCloudconnectionsNetworksDeleteOptions)
}

// PcloudCloudconnectionsNetworksDeleteWithContext is an alternate form of the PcloudCloudconnectionsNetworksDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudconnectionsNetworksDeleteWithContext(ctx context.Context, pcloudCloudconnectionsNetworksDeleteOptions *PcloudCloudconnectionsNetworksDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudconnectionsNetworksDeleteOptions, "pcloudCloudconnectionsNetworksDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudconnectionsNetworksDeleteOptions, "pcloudCloudconnectionsNetworksDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudconnectionsNetworksDeleteOptions.CloudInstanceID,
		"cloud_connection_id": *pcloudCloudconnectionsNetworksDeleteOptions.CloudConnectionID,
		"network_id": *pcloudCloudconnectionsNetworksDeleteOptions.NetworkID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/cloud-connections/{cloud_connection_id}/networks/{network_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudconnectionsNetworksDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudconnectionsNetworksDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudconnectionsNetworksPut : Attach a network to the cloud connection
func (powervs *PowervsV1) PcloudCloudconnectionsNetworksPut(pcloudCloudconnectionsNetworksPutOptions *PcloudCloudconnectionsNetworksPutOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudconnectionsNetworksPutWithContext(context.Background(), pcloudCloudconnectionsNetworksPutOptions)
}

// PcloudCloudconnectionsNetworksPutWithContext is an alternate form of the PcloudCloudconnectionsNetworksPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudconnectionsNetworksPutWithContext(ctx context.Context, pcloudCloudconnectionsNetworksPutOptions *PcloudCloudconnectionsNetworksPutOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudconnectionsNetworksPutOptions, "pcloudCloudconnectionsNetworksPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudconnectionsNetworksPutOptions, "pcloudCloudconnectionsNetworksPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudconnectionsNetworksPutOptions.CloudInstanceID,
		"cloud_connection_id": *pcloudCloudconnectionsNetworksPutOptions.CloudConnectionID,
		"network_id": *pcloudCloudconnectionsNetworksPutOptions.NetworkID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/cloud-connections/{cloud_connection_id}/networks/{network_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudconnectionsNetworksPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudconnectionsNetworksPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudLocationsDisasterrecoveryGet : Get the disaster recovery site details for the current location
func (powervs *PowervsV1) PcloudLocationsDisasterrecoveryGet(pcloudLocationsDisasterrecoveryGetOptions *PcloudLocationsDisasterrecoveryGetOptions) (result *DisasterRecoveryLocation, response *core.DetailedResponse, err error) {
	return powervs.PcloudLocationsDisasterrecoveryGetWithContext(context.Background(), pcloudLocationsDisasterrecoveryGetOptions)
}

// PcloudLocationsDisasterrecoveryGetWithContext is an alternate form of the PcloudLocationsDisasterrecoveryGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudLocationsDisasterrecoveryGetWithContext(ctx context.Context, pcloudLocationsDisasterrecoveryGetOptions *PcloudLocationsDisasterrecoveryGetOptions) (result *DisasterRecoveryLocation, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudLocationsDisasterrecoveryGetOptions, "pcloudLocationsDisasterrecoveryGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudLocationsDisasterrecoveryGetOptions, "pcloudLocationsDisasterrecoveryGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudLocationsDisasterrecoveryGetOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/locations/disaster-recovery`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudLocationsDisasterrecoveryGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudLocationsDisasterrecoveryGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDisasterRecoveryLocation)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudLocationsDisasterrecoveryGetall : Get all disaster recovery locations supported by Power Virtual Server
func (powervs *PowervsV1) PcloudLocationsDisasterrecoveryGetall(pcloudLocationsDisasterrecoveryGetallOptions *PcloudLocationsDisasterrecoveryGetallOptions) (result *DisasterRecoveryLocations, response *core.DetailedResponse, err error) {
	return powervs.PcloudLocationsDisasterrecoveryGetallWithContext(context.Background(), pcloudLocationsDisasterrecoveryGetallOptions)
}

// PcloudLocationsDisasterrecoveryGetallWithContext is an alternate form of the PcloudLocationsDisasterrecoveryGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudLocationsDisasterrecoveryGetallWithContext(ctx context.Context, pcloudLocationsDisasterrecoveryGetallOptions *PcloudLocationsDisasterrecoveryGetallOptions) (result *DisasterRecoveryLocations, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(pcloudLocationsDisasterrecoveryGetallOptions, "pcloudLocationsDisasterrecoveryGetallOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/locations/disaster-recovery`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudLocationsDisasterrecoveryGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudLocationsDisasterrecoveryGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDisasterRecoveryLocations)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudEventsGetquery : Get events from this cloud instance since a specific timestamp
func (powervs *PowervsV1) PcloudEventsGetquery(pcloudEventsGetqueryOptions *PcloudEventsGetqueryOptions) (result *Events, response *core.DetailedResponse, err error) {
	return powervs.PcloudEventsGetqueryWithContext(context.Background(), pcloudEventsGetqueryOptions)
}

// PcloudEventsGetqueryWithContext is an alternate form of the PcloudEventsGetquery method which supports a Context parameter
func (powervs *PowervsV1) PcloudEventsGetqueryWithContext(ctx context.Context, pcloudEventsGetqueryOptions *PcloudEventsGetqueryOptions) (result *Events, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudEventsGetqueryOptions, "pcloudEventsGetqueryOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudEventsGetqueryOptions, "pcloudEventsGetqueryOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudEventsGetqueryOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/events`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudEventsGetqueryOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudEventsGetquery")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if pcloudEventsGetqueryOptions.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*pcloudEventsGetqueryOptions.AcceptLanguage))
	}

	if pcloudEventsGetqueryOptions.Time != nil {
		builder.AddQuery("time", fmt.Sprint(*pcloudEventsGetqueryOptions.Time))
	}
	if pcloudEventsGetqueryOptions.FromTime != nil {
		builder.AddQuery("from_time", fmt.Sprint(*pcloudEventsGetqueryOptions.FromTime))
	}
	if pcloudEventsGetqueryOptions.ToTime != nil {
		builder.AddQuery("to_time", fmt.Sprint(*pcloudEventsGetqueryOptions.ToTime))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalEvents)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudEventsGet : Get a single event
func (powervs *PowervsV1) PcloudEventsGet(pcloudEventsGetOptions *PcloudEventsGetOptions) (result *Event, response *core.DetailedResponse, err error) {
	return powervs.PcloudEventsGetWithContext(context.Background(), pcloudEventsGetOptions)
}

// PcloudEventsGetWithContext is an alternate form of the PcloudEventsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudEventsGetWithContext(ctx context.Context, pcloudEventsGetOptions *PcloudEventsGetOptions) (result *Event, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudEventsGetOptions, "pcloudEventsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudEventsGetOptions, "pcloudEventsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudEventsGetOptions.CloudInstanceID,
		"event_id": *pcloudEventsGetOptions.EventID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/events/{event_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudEventsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudEventsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if pcloudEventsGetOptions.AcceptLanguage != nil {
		builder.AddHeader("Accept-Language", fmt.Sprint(*pcloudEventsGetOptions.AcceptLanguage))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalEvent)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV1CloudinstancesCosimagesGet : Get detail of last cos-image import job
func (powervs *PowervsV1) PcloudV1CloudinstancesCosimagesGet(pcloudV1CloudinstancesCosimagesGetOptions *PcloudV1CloudinstancesCosimagesGetOptions) (result *Job, response *core.DetailedResponse, err error) {
	return powervs.PcloudV1CloudinstancesCosimagesGetWithContext(context.Background(), pcloudV1CloudinstancesCosimagesGetOptions)
}

// PcloudV1CloudinstancesCosimagesGetWithContext is an alternate form of the PcloudV1CloudinstancesCosimagesGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudV1CloudinstancesCosimagesGetWithContext(ctx context.Context, pcloudV1CloudinstancesCosimagesGetOptions *PcloudV1CloudinstancesCosimagesGetOptions) (result *Job, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV1CloudinstancesCosimagesGetOptions, "pcloudV1CloudinstancesCosimagesGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV1CloudinstancesCosimagesGetOptions, "pcloudV1CloudinstancesCosimagesGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV1CloudinstancesCosimagesGetOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/cos-images`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV1CloudinstancesCosimagesGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV1CloudinstancesCosimagesGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalJob)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV1CloudinstancesCosimagesPost : Create an cos-image import job
func (powervs *PowervsV1) PcloudV1CloudinstancesCosimagesPost(pcloudV1CloudinstancesCosimagesPostOptions *PcloudV1CloudinstancesCosimagesPostOptions) (result *JobReference, response *core.DetailedResponse, err error) {
	return powervs.PcloudV1CloudinstancesCosimagesPostWithContext(context.Background(), pcloudV1CloudinstancesCosimagesPostOptions)
}

// PcloudV1CloudinstancesCosimagesPostWithContext is an alternate form of the PcloudV1CloudinstancesCosimagesPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudV1CloudinstancesCosimagesPostWithContext(ctx context.Context, pcloudV1CloudinstancesCosimagesPostOptions *PcloudV1CloudinstancesCosimagesPostOptions) (result *JobReference, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV1CloudinstancesCosimagesPostOptions, "pcloudV1CloudinstancesCosimagesPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV1CloudinstancesCosimagesPostOptions, "pcloudV1CloudinstancesCosimagesPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV1CloudinstancesCosimagesPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/cos-images`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV1CloudinstancesCosimagesPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV1CloudinstancesCosimagesPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudV1CloudinstancesCosimagesPostOptions.BucketName != nil {
		body["bucketName"] = pcloudV1CloudinstancesCosimagesPostOptions.BucketName
	}
	if pcloudV1CloudinstancesCosimagesPostOptions.ImageFilename != nil {
		body["imageFilename"] = pcloudV1CloudinstancesCosimagesPostOptions.ImageFilename
	}
	if pcloudV1CloudinstancesCosimagesPostOptions.ImageName != nil {
		body["imageName"] = pcloudV1CloudinstancesCosimagesPostOptions.ImageName
	}
	if pcloudV1CloudinstancesCosimagesPostOptions.Region != nil {
		body["region"] = pcloudV1CloudinstancesCosimagesPostOptions.Region
	}
	if pcloudV1CloudinstancesCosimagesPostOptions.AccessKey != nil {
		body["accessKey"] = pcloudV1CloudinstancesCosimagesPostOptions.AccessKey
	}
	if pcloudV1CloudinstancesCosimagesPostOptions.BucketAccess != nil {
		body["bucketAccess"] = pcloudV1CloudinstancesCosimagesPostOptions.BucketAccess
	}
	if pcloudV1CloudinstancesCosimagesPostOptions.OsType != nil {
		body["osType"] = pcloudV1CloudinstancesCosimagesPostOptions.OsType
	}
	if pcloudV1CloudinstancesCosimagesPostOptions.SecretKey != nil {
		body["secretKey"] = pcloudV1CloudinstancesCosimagesPostOptions.SecretKey
	}
	if pcloudV1CloudinstancesCosimagesPostOptions.StorageAffinity != nil {
		body["storageAffinity"] = pcloudV1CloudinstancesCosimagesPostOptions.StorageAffinity
	}
	if pcloudV1CloudinstancesCosimagesPostOptions.StoragePool != nil {
		body["storagePool"] = pcloudV1CloudinstancesCosimagesPostOptions.StoragePool
	}
	if pcloudV1CloudinstancesCosimagesPostOptions.StorageType != nil {
		body["storageType"] = pcloudV1CloudinstancesCosimagesPostOptions.StorageType
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalJobReference)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesImagesGetall : List all images for this cloud instance
func (powervs *PowervsV1) PcloudCloudinstancesImagesGetall(pcloudCloudinstancesImagesGetallOptions *PcloudCloudinstancesImagesGetallOptions) (result *Images, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesImagesGetallWithContext(context.Background(), pcloudCloudinstancesImagesGetallOptions)
}

// PcloudCloudinstancesImagesGetallWithContext is an alternate form of the PcloudCloudinstancesImagesGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesImagesGetallWithContext(ctx context.Context, pcloudCloudinstancesImagesGetallOptions *PcloudCloudinstancesImagesGetallOptions) (result *Images, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesImagesGetallOptions, "pcloudCloudinstancesImagesGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesImagesGetallOptions, "pcloudCloudinstancesImagesGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesImagesGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/images`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesImagesGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesImagesGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImages)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesImagesPost : Create a new Image (from available images)
func (powervs *PowervsV1) PcloudCloudinstancesImagesPost(pcloudCloudinstancesImagesPostOptions *PcloudCloudinstancesImagesPostOptions) (result *Image, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesImagesPostWithContext(context.Background(), pcloudCloudinstancesImagesPostOptions)
}

// PcloudCloudinstancesImagesPostWithContext is an alternate form of the PcloudCloudinstancesImagesPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesImagesPostWithContext(ctx context.Context, pcloudCloudinstancesImagesPostOptions *PcloudCloudinstancesImagesPostOptions) (result *Image, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesImagesPostOptions, "pcloudCloudinstancesImagesPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesImagesPostOptions, "pcloudCloudinstancesImagesPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesImagesPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/images`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesImagesPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesImagesPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudCloudinstancesImagesPostOptions.Source != nil {
		body["source"] = pcloudCloudinstancesImagesPostOptions.Source
	}
	if pcloudCloudinstancesImagesPostOptions.AccessKey != nil {
		body["accessKey"] = pcloudCloudinstancesImagesPostOptions.AccessKey
	}
	if pcloudCloudinstancesImagesPostOptions.BucketName != nil {
		body["bucketName"] = pcloudCloudinstancesImagesPostOptions.BucketName
	}
	if pcloudCloudinstancesImagesPostOptions.DiskType != nil {
		body["diskType"] = pcloudCloudinstancesImagesPostOptions.DiskType
	}
	if pcloudCloudinstancesImagesPostOptions.ImageFilename != nil {
		body["imageFilename"] = pcloudCloudinstancesImagesPostOptions.ImageFilename
	}
	if pcloudCloudinstancesImagesPostOptions.ImageID != nil {
		body["imageID"] = pcloudCloudinstancesImagesPostOptions.ImageID
	}
	if pcloudCloudinstancesImagesPostOptions.ImageName != nil {
		body["imageName"] = pcloudCloudinstancesImagesPostOptions.ImageName
	}
	if pcloudCloudinstancesImagesPostOptions.ImagePath != nil {
		body["imagePath"] = pcloudCloudinstancesImagesPostOptions.ImagePath
	}
	if pcloudCloudinstancesImagesPostOptions.OsType != nil {
		body["osType"] = pcloudCloudinstancesImagesPostOptions.OsType
	}
	if pcloudCloudinstancesImagesPostOptions.Region != nil {
		body["region"] = pcloudCloudinstancesImagesPostOptions.Region
	}
	if pcloudCloudinstancesImagesPostOptions.SecretKey != nil {
		body["secretKey"] = pcloudCloudinstancesImagesPostOptions.SecretKey
	}
	if pcloudCloudinstancesImagesPostOptions.StorageAffinity != nil {
		body["storageAffinity"] = pcloudCloudinstancesImagesPostOptions.StorageAffinity
	}
	if pcloudCloudinstancesImagesPostOptions.StoragePool != nil {
		body["storagePool"] = pcloudCloudinstancesImagesPostOptions.StoragePool
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImage)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesImagesDelete : Delete an Image from a Cloud Instance
func (powervs *PowervsV1) PcloudCloudinstancesImagesDelete(pcloudCloudinstancesImagesDeleteOptions *PcloudCloudinstancesImagesDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesImagesDeleteWithContext(context.Background(), pcloudCloudinstancesImagesDeleteOptions)
}

// PcloudCloudinstancesImagesDeleteWithContext is an alternate form of the PcloudCloudinstancesImagesDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesImagesDeleteWithContext(ctx context.Context, pcloudCloudinstancesImagesDeleteOptions *PcloudCloudinstancesImagesDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesImagesDeleteOptions, "pcloudCloudinstancesImagesDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesImagesDeleteOptions, "pcloudCloudinstancesImagesDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesImagesDeleteOptions.CloudInstanceID,
		"image_id": *pcloudCloudinstancesImagesDeleteOptions.ImageID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/images/{image_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesImagesDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesImagesDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesImagesGet : Detailed info of an image
func (powervs *PowervsV1) PcloudCloudinstancesImagesGet(pcloudCloudinstancesImagesGetOptions *PcloudCloudinstancesImagesGetOptions) (result *Image, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesImagesGetWithContext(context.Background(), pcloudCloudinstancesImagesGetOptions)
}

// PcloudCloudinstancesImagesGetWithContext is an alternate form of the PcloudCloudinstancesImagesGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesImagesGetWithContext(ctx context.Context, pcloudCloudinstancesImagesGetOptions *PcloudCloudinstancesImagesGetOptions) (result *Image, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesImagesGetOptions, "pcloudCloudinstancesImagesGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesImagesGetOptions, "pcloudCloudinstancesImagesGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesImagesGetOptions.CloudInstanceID,
		"image_id": *pcloudCloudinstancesImagesGetOptions.ImageID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/images/{image_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesImagesGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesImagesGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImage)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesImagesExportPost : Export an image
// This API is deprecated for /pcloud/v2/cloud-instances/{cloud_instance_id}/images/{image_id}/export.
//
// >*Note*: Support for this API is available till Oct 2022.
// Deprecated: this method is deprecated and may be removed in a future release.
func (powervs *PowervsV1) PcloudCloudinstancesImagesExportPost(pcloudCloudinstancesImagesExportPostOptions *PcloudCloudinstancesImagesExportPostOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesImagesExportPostWithContext(context.Background(), pcloudCloudinstancesImagesExportPostOptions)
}

// PcloudCloudinstancesImagesExportPostWithContext is an alternate form of the PcloudCloudinstancesImagesExportPost method which supports a Context parameter
// Deprecated: this method is deprecated and may be removed in a future release.
func (powervs *PowervsV1) PcloudCloudinstancesImagesExportPostWithContext(ctx context.Context, pcloudCloudinstancesImagesExportPostOptions *PcloudCloudinstancesImagesExportPostOptions) (result *Object, response *core.DetailedResponse, err error) {
	core.GetLogger().Warn("A deprecated operation has been invoked: PcloudCloudinstancesImagesExportPost")
	err = core.ValidateNotNil(pcloudCloudinstancesImagesExportPostOptions, "pcloudCloudinstancesImagesExportPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesImagesExportPostOptions, "pcloudCloudinstancesImagesExportPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesImagesExportPostOptions.CloudInstanceID,
		"image_id": *pcloudCloudinstancesImagesExportPostOptions.ImageID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/images/{image_id}/export`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesImagesExportPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesImagesExportPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudCloudinstancesImagesExportPostOptions.AccessKey != nil {
		body["accessKey"] = pcloudCloudinstancesImagesExportPostOptions.AccessKey
	}
	if pcloudCloudinstancesImagesExportPostOptions.BucketName != nil {
		body["bucketName"] = pcloudCloudinstancesImagesExportPostOptions.BucketName
	}
	if pcloudCloudinstancesImagesExportPostOptions.Region != nil {
		body["region"] = pcloudCloudinstancesImagesExportPostOptions.Region
	}
	if pcloudCloudinstancesImagesExportPostOptions.SecretKey != nil {
		body["secretKey"] = pcloudCloudinstancesImagesExportPostOptions.SecretKey
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesStockimagesGetall : List all available stock images
func (powervs *PowervsV1) PcloudCloudinstancesStockimagesGetall(pcloudCloudinstancesStockimagesGetallOptions *PcloudCloudinstancesStockimagesGetallOptions) (result *Images, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesStockimagesGetallWithContext(context.Background(), pcloudCloudinstancesStockimagesGetallOptions)
}

// PcloudCloudinstancesStockimagesGetallWithContext is an alternate form of the PcloudCloudinstancesStockimagesGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesStockimagesGetallWithContext(ctx context.Context, pcloudCloudinstancesStockimagesGetallOptions *PcloudCloudinstancesStockimagesGetallOptions) (result *Images, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesStockimagesGetallOptions, "pcloudCloudinstancesStockimagesGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesStockimagesGetallOptions, "pcloudCloudinstancesStockimagesGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesStockimagesGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/stock-images`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesStockimagesGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesStockimagesGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if pcloudCloudinstancesStockimagesGetallOptions.Sap != nil {
		builder.AddQuery("sap", fmt.Sprint(*pcloudCloudinstancesStockimagesGetallOptions.Sap))
	}
	if pcloudCloudinstancesStockimagesGetallOptions.Vtl != nil {
		builder.AddQuery("vtl", fmt.Sprint(*pcloudCloudinstancesStockimagesGetallOptions.Vtl))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImages)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesStockimagesGet : Detailed info of an available stock image
func (powervs *PowervsV1) PcloudCloudinstancesStockimagesGet(pcloudCloudinstancesStockimagesGetOptions *PcloudCloudinstancesStockimagesGetOptions) (result *Image, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesStockimagesGetWithContext(context.Background(), pcloudCloudinstancesStockimagesGetOptions)
}

// PcloudCloudinstancesStockimagesGetWithContext is an alternate form of the PcloudCloudinstancesStockimagesGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesStockimagesGetWithContext(ctx context.Context, pcloudCloudinstancesStockimagesGetOptions *PcloudCloudinstancesStockimagesGetOptions) (result *Image, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesStockimagesGetOptions, "pcloudCloudinstancesStockimagesGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesStockimagesGetOptions, "pcloudCloudinstancesStockimagesGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesStockimagesGetOptions.CloudInstanceID,
		"image_id": *pcloudCloudinstancesStockimagesGetOptions.ImageID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/stock-images/{image_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesStockimagesGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesStockimagesGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImage)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudImagesGetall : List all the images in the image-catalog
// This API is deprecated for /pcloud/v1/cloud-instances/{cloud_instance_id}/stock-images.
//
// >*Note*: Support for this API will be available till 31st March 2023.
// Deprecated: this method is deprecated and may be removed in a future release.
func (powervs *PowervsV1) PcloudImagesGetall(pcloudImagesGetallOptions *PcloudImagesGetallOptions) (result *Images, response *core.DetailedResponse, err error) {
	return powervs.PcloudImagesGetallWithContext(context.Background(), pcloudImagesGetallOptions)
}

// PcloudImagesGetallWithContext is an alternate form of the PcloudImagesGetall method which supports a Context parameter
// Deprecated: this method is deprecated and may be removed in a future release.
func (powervs *PowervsV1) PcloudImagesGetallWithContext(ctx context.Context, pcloudImagesGetallOptions *PcloudImagesGetallOptions) (result *Images, response *core.DetailedResponse, err error) {
	core.GetLogger().Warn("A deprecated operation has been invoked: PcloudImagesGetall")
	err = core.ValidateStruct(pcloudImagesGetallOptions, "pcloudImagesGetallOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/images`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudImagesGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudImagesGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if pcloudImagesGetallOptions.Sap != nil {
		builder.AddQuery("sap", fmt.Sprint(*pcloudImagesGetallOptions.Sap))
	}
	if pcloudImagesGetallOptions.Vtl != nil {
		builder.AddQuery("vtl", fmt.Sprint(*pcloudImagesGetallOptions.Vtl))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImages)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudImagesGet : Detailed info of an image in the image-catalog
// This API is deprecated for /pcloud/v1/cloud-instances/{cloud_instance_id}/stock-images/{image_id}.
//
// >*Note*: Support for this API will be available till 31st March 2023.
// Deprecated: this method is deprecated and may be removed in a future release.
func (powervs *PowervsV1) PcloudImagesGet(pcloudImagesGetOptions *PcloudImagesGetOptions) (result *Image, response *core.DetailedResponse, err error) {
	return powervs.PcloudImagesGetWithContext(context.Background(), pcloudImagesGetOptions)
}

// PcloudImagesGetWithContext is an alternate form of the PcloudImagesGet method which supports a Context parameter
// Deprecated: this method is deprecated and may be removed in a future release.
func (powervs *PowervsV1) PcloudImagesGetWithContext(ctx context.Context, pcloudImagesGetOptions *PcloudImagesGetOptions) (result *Image, response *core.DetailedResponse, err error) {
	core.GetLogger().Warn("A deprecated operation has been invoked: PcloudImagesGet")
	err = core.ValidateNotNil(pcloudImagesGetOptions, "pcloudImagesGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudImagesGetOptions, "pcloudImagesGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"image_id": *pcloudImagesGetOptions.ImageID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/images/{image_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudImagesGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudImagesGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalImage)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2ImagesExportGet : Get detail of last image export job
func (powervs *PowervsV1) PcloudV2ImagesExportGet(pcloudV2ImagesExportGetOptions *PcloudV2ImagesExportGetOptions) (result *Job, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2ImagesExportGetWithContext(context.Background(), pcloudV2ImagesExportGetOptions)
}

// PcloudV2ImagesExportGetWithContext is an alternate form of the PcloudV2ImagesExportGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2ImagesExportGetWithContext(ctx context.Context, pcloudV2ImagesExportGetOptions *PcloudV2ImagesExportGetOptions) (result *Job, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2ImagesExportGetOptions, "pcloudV2ImagesExportGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2ImagesExportGetOptions, "pcloudV2ImagesExportGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2ImagesExportGetOptions.CloudInstanceID,
		"image_id": *pcloudV2ImagesExportGetOptions.ImageID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/images/{image_id}/export`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2ImagesExportGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2ImagesExportGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalJob)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2ImagesExportPost : Add image export job to the jobs queue
func (powervs *PowervsV1) PcloudV2ImagesExportPost(pcloudV2ImagesExportPostOptions *PcloudV2ImagesExportPostOptions) (result *JobReference, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2ImagesExportPostWithContext(context.Background(), pcloudV2ImagesExportPostOptions)
}

// PcloudV2ImagesExportPostWithContext is an alternate form of the PcloudV2ImagesExportPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2ImagesExportPostWithContext(ctx context.Context, pcloudV2ImagesExportPostOptions *PcloudV2ImagesExportPostOptions) (result *JobReference, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2ImagesExportPostOptions, "pcloudV2ImagesExportPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2ImagesExportPostOptions, "pcloudV2ImagesExportPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2ImagesExportPostOptions.CloudInstanceID,
		"image_id": *pcloudV2ImagesExportPostOptions.ImageID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/images/{image_id}/export`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2ImagesExportPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2ImagesExportPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudV2ImagesExportPostOptions.AccessKey != nil {
		body["accessKey"] = pcloudV2ImagesExportPostOptions.AccessKey
	}
	if pcloudV2ImagesExportPostOptions.BucketName != nil {
		body["bucketName"] = pcloudV2ImagesExportPostOptions.BucketName
	}
	if pcloudV2ImagesExportPostOptions.Region != nil {
		body["region"] = pcloudV2ImagesExportPostOptions.Region
	}
	if pcloudV2ImagesExportPostOptions.SecretKey != nil {
		body["secretKey"] = pcloudV2ImagesExportPostOptions.SecretKey
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalJobReference)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesDelete : Delete a Power Cloud Instance
func (powervs *PowervsV1) PcloudCloudinstancesDelete(pcloudCloudinstancesDeleteOptions *PcloudCloudinstancesDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesDeleteWithContext(context.Background(), pcloudCloudinstancesDeleteOptions)
}

// PcloudCloudinstancesDeleteWithContext is an alternate form of the PcloudCloudinstancesDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesDeleteWithContext(ctx context.Context, pcloudCloudinstancesDeleteOptions *PcloudCloudinstancesDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesDeleteOptions, "pcloudCloudinstancesDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesDeleteOptions, "pcloudCloudinstancesDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesDeleteOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesGet : Get a Cloud Instance's current state/information
func (powervs *PowervsV1) PcloudCloudinstancesGet(pcloudCloudinstancesGetOptions *PcloudCloudinstancesGetOptions) (result *CloudInstance, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesGetWithContext(context.Background(), pcloudCloudinstancesGetOptions)
}

// PcloudCloudinstancesGetWithContext is an alternate form of the PcloudCloudinstancesGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesGetWithContext(ctx context.Context, pcloudCloudinstancesGetOptions *PcloudCloudinstancesGetOptions) (result *CloudInstance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesGetOptions, "pcloudCloudinstancesGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesGetOptions, "pcloudCloudinstancesGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesGetOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCloudInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesPut : Update / Upgrade a Cloud Instance
func (powervs *PowervsV1) PcloudCloudinstancesPut(pcloudCloudinstancesPutOptions *PcloudCloudinstancesPutOptions) (result *CloudInstance, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesPutWithContext(context.Background(), pcloudCloudinstancesPutOptions)
}

// PcloudCloudinstancesPutWithContext is an alternate form of the PcloudCloudinstancesPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesPutWithContext(ctx context.Context, pcloudCloudinstancesPutOptions *PcloudCloudinstancesPutOptions) (result *CloudInstance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesPutOptions, "pcloudCloudinstancesPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesPutOptions, "pcloudCloudinstancesPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesPutOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudCloudinstancesPutOptions.Instances != nil {
		body["instances"] = pcloudCloudinstancesPutOptions.Instances
	}
	if pcloudCloudinstancesPutOptions.Memory != nil {
		body["memory"] = pcloudCloudinstancesPutOptions.Memory
	}
	if pcloudCloudinstancesPutOptions.ProcUnits != nil {
		body["procUnits"] = pcloudCloudinstancesPutOptions.ProcUnits
	}
	if pcloudCloudinstancesPutOptions.Processors != nil {
		body["processors"] = pcloudCloudinstancesPutOptions.Processors
	}
	if pcloudCloudinstancesPutOptions.Storage != nil {
		body["storage"] = pcloudCloudinstancesPutOptions.Storage
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCloudInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesJobsGetall : List up to the last 5 jobs initiated by the cloud instance
func (powervs *PowervsV1) PcloudCloudinstancesJobsGetall(pcloudCloudinstancesJobsGetallOptions *PcloudCloudinstancesJobsGetallOptions) (result *Jobs, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesJobsGetallWithContext(context.Background(), pcloudCloudinstancesJobsGetallOptions)
}

// PcloudCloudinstancesJobsGetallWithContext is an alternate form of the PcloudCloudinstancesJobsGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesJobsGetallWithContext(ctx context.Context, pcloudCloudinstancesJobsGetallOptions *PcloudCloudinstancesJobsGetallOptions) (result *Jobs, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesJobsGetallOptions, "pcloudCloudinstancesJobsGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesJobsGetallOptions, "pcloudCloudinstancesJobsGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesJobsGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/jobs`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesJobsGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesJobsGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if pcloudCloudinstancesJobsGetallOptions.OperationID != nil {
		builder.AddQuery("operation.id", fmt.Sprint(*pcloudCloudinstancesJobsGetallOptions.OperationID))
	}
	if pcloudCloudinstancesJobsGetallOptions.OperationTarget != nil {
		builder.AddQuery("operation.target", fmt.Sprint(*pcloudCloudinstancesJobsGetallOptions.OperationTarget))
	}
	if pcloudCloudinstancesJobsGetallOptions.OperationAction != nil {
		builder.AddQuery("operation.action", fmt.Sprint(*pcloudCloudinstancesJobsGetallOptions.OperationAction))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalJobs)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesJobsDelete : Delete a cloud instance job
func (powervs *PowervsV1) PcloudCloudinstancesJobsDelete(pcloudCloudinstancesJobsDeleteOptions *PcloudCloudinstancesJobsDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesJobsDeleteWithContext(context.Background(), pcloudCloudinstancesJobsDeleteOptions)
}

// PcloudCloudinstancesJobsDeleteWithContext is an alternate form of the PcloudCloudinstancesJobsDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesJobsDeleteWithContext(ctx context.Context, pcloudCloudinstancesJobsDeleteOptions *PcloudCloudinstancesJobsDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesJobsDeleteOptions, "pcloudCloudinstancesJobsDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesJobsDeleteOptions, "pcloudCloudinstancesJobsDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesJobsDeleteOptions.CloudInstanceID,
		"job_id": *pcloudCloudinstancesJobsDeleteOptions.JobID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/jobs/{job_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesJobsDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesJobsDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesJobsGet : List the detail of a job
func (powervs *PowervsV1) PcloudCloudinstancesJobsGet(pcloudCloudinstancesJobsGetOptions *PcloudCloudinstancesJobsGetOptions) (result *Job, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesJobsGetWithContext(context.Background(), pcloudCloudinstancesJobsGetOptions)
}

// PcloudCloudinstancesJobsGetWithContext is an alternate form of the PcloudCloudinstancesJobsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesJobsGetWithContext(ctx context.Context, pcloudCloudinstancesJobsGetOptions *PcloudCloudinstancesJobsGetOptions) (result *Job, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesJobsGetOptions, "pcloudCloudinstancesJobsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesJobsGetOptions, "pcloudCloudinstancesJobsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesJobsGetOptions.CloudInstanceID,
		"job_id": *pcloudCloudinstancesJobsGetOptions.JobID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/jobs/{job_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesJobsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesJobsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalJob)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudNetworksGetall : Get all networks in this cloud instance
func (powervs *PowervsV1) PcloudNetworksGetall(pcloudNetworksGetallOptions *PcloudNetworksGetallOptions) (result *Networks, response *core.DetailedResponse, err error) {
	return powervs.PcloudNetworksGetallWithContext(context.Background(), pcloudNetworksGetallOptions)
}

// PcloudNetworksGetallWithContext is an alternate form of the PcloudNetworksGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudNetworksGetallWithContext(ctx context.Context, pcloudNetworksGetallOptions *PcloudNetworksGetallOptions) (result *Networks, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudNetworksGetallOptions, "pcloudNetworksGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudNetworksGetallOptions, "pcloudNetworksGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudNetworksGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/networks`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudNetworksGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudNetworksGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if pcloudNetworksGetallOptions.Filter != nil {
		builder.AddQuery("filter", fmt.Sprint(*pcloudNetworksGetallOptions.Filter))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworks)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudNetworksPost : Create a new Network
func (powervs *PowervsV1) PcloudNetworksPost(pcloudNetworksPostOptions *PcloudNetworksPostOptions) (result *Network, response *core.DetailedResponse, err error) {
	return powervs.PcloudNetworksPostWithContext(context.Background(), pcloudNetworksPostOptions)
}

// PcloudNetworksPostWithContext is an alternate form of the PcloudNetworksPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudNetworksPostWithContext(ctx context.Context, pcloudNetworksPostOptions *PcloudNetworksPostOptions) (result *Network, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudNetworksPostOptions, "pcloudNetworksPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudNetworksPostOptions, "pcloudNetworksPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudNetworksPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/networks`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudNetworksPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudNetworksPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudNetworksPostOptions.Type != nil {
		body["type"] = pcloudNetworksPostOptions.Type
	}
	if pcloudNetworksPostOptions.AccessConfig != nil {
		body["accessConfig"] = pcloudNetworksPostOptions.AccessConfig
	}
	if pcloudNetworksPostOptions.CIDR != nil {
		body["cidr"] = pcloudNetworksPostOptions.CIDR
	}
	if pcloudNetworksPostOptions.DnsServers != nil {
		body["dnsServers"] = pcloudNetworksPostOptions.DnsServers
	}
	if pcloudNetworksPostOptions.Gateway != nil {
		body["gateway"] = pcloudNetworksPostOptions.Gateway
	}
	if pcloudNetworksPostOptions.IPAddressRanges != nil {
		body["ipAddressRanges"] = pcloudNetworksPostOptions.IPAddressRanges
	}
	if pcloudNetworksPostOptions.Jumbo != nil {
		body["jumbo"] = pcloudNetworksPostOptions.Jumbo
	}
	if pcloudNetworksPostOptions.Mtu != nil {
		body["mtu"] = pcloudNetworksPostOptions.Mtu
	}
	if pcloudNetworksPostOptions.Name != nil {
		body["name"] = pcloudNetworksPostOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetwork)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudNetworksDelete : Delete a Network
func (powervs *PowervsV1) PcloudNetworksDelete(pcloudNetworksDeleteOptions *PcloudNetworksDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudNetworksDeleteWithContext(context.Background(), pcloudNetworksDeleteOptions)
}

// PcloudNetworksDeleteWithContext is an alternate form of the PcloudNetworksDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudNetworksDeleteWithContext(ctx context.Context, pcloudNetworksDeleteOptions *PcloudNetworksDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudNetworksDeleteOptions, "pcloudNetworksDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudNetworksDeleteOptions, "pcloudNetworksDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudNetworksDeleteOptions.CloudInstanceID,
		"network_id": *pcloudNetworksDeleteOptions.NetworkID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/networks/{network_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudNetworksDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudNetworksDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudNetworksGet : Get a network's current state/information
func (powervs *PowervsV1) PcloudNetworksGet(pcloudNetworksGetOptions *PcloudNetworksGetOptions) (result *Network, response *core.DetailedResponse, err error) {
	return powervs.PcloudNetworksGetWithContext(context.Background(), pcloudNetworksGetOptions)
}

// PcloudNetworksGetWithContext is an alternate form of the PcloudNetworksGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudNetworksGetWithContext(ctx context.Context, pcloudNetworksGetOptions *PcloudNetworksGetOptions) (result *Network, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudNetworksGetOptions, "pcloudNetworksGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudNetworksGetOptions, "pcloudNetworksGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudNetworksGetOptions.CloudInstanceID,
		"network_id": *pcloudNetworksGetOptions.NetworkID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/networks/{network_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudNetworksGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudNetworksGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetwork)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudNetworksPut : Update a Network
func (powervs *PowervsV1) PcloudNetworksPut(pcloudNetworksPutOptions *PcloudNetworksPutOptions) (result *Network, response *core.DetailedResponse, err error) {
	return powervs.PcloudNetworksPutWithContext(context.Background(), pcloudNetworksPutOptions)
}

// PcloudNetworksPutWithContext is an alternate form of the PcloudNetworksPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudNetworksPutWithContext(ctx context.Context, pcloudNetworksPutOptions *PcloudNetworksPutOptions) (result *Network, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudNetworksPutOptions, "pcloudNetworksPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudNetworksPutOptions, "pcloudNetworksPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudNetworksPutOptions.CloudInstanceID,
		"network_id": *pcloudNetworksPutOptions.NetworkID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/networks/{network_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudNetworksPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudNetworksPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudNetworksPutOptions.DnsServers != nil {
		body["dnsServers"] = pcloudNetworksPutOptions.DnsServers
	}
	if pcloudNetworksPutOptions.Gateway != nil {
		body["gateway"] = pcloudNetworksPutOptions.Gateway
	}
	if pcloudNetworksPutOptions.IPAddressRanges != nil {
		body["ipAddressRanges"] = pcloudNetworksPutOptions.IPAddressRanges
	}
	if pcloudNetworksPutOptions.Name != nil {
		body["name"] = pcloudNetworksPutOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetwork)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudNetworksPortsGetall : Get all ports for this network
func (powervs *PowervsV1) PcloudNetworksPortsGetall(pcloudNetworksPortsGetallOptions *PcloudNetworksPortsGetallOptions) (result *NetworkPorts, response *core.DetailedResponse, err error) {
	return powervs.PcloudNetworksPortsGetallWithContext(context.Background(), pcloudNetworksPortsGetallOptions)
}

// PcloudNetworksPortsGetallWithContext is an alternate form of the PcloudNetworksPortsGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudNetworksPortsGetallWithContext(ctx context.Context, pcloudNetworksPortsGetallOptions *PcloudNetworksPortsGetallOptions) (result *NetworkPorts, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudNetworksPortsGetallOptions, "pcloudNetworksPortsGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudNetworksPortsGetallOptions, "pcloudNetworksPortsGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudNetworksPortsGetallOptions.CloudInstanceID,
		"network_id": *pcloudNetworksPortsGetallOptions.NetworkID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/networks/{network_id}/ports`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudNetworksPortsGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudNetworksPortsGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkPorts)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudNetworksPortsPost : Perform port addition, deletion, and listing
func (powervs *PowervsV1) PcloudNetworksPortsPost(pcloudNetworksPortsPostOptions *PcloudNetworksPortsPostOptions) (result *NetworkPort, response *core.DetailedResponse, err error) {
	return powervs.PcloudNetworksPortsPostWithContext(context.Background(), pcloudNetworksPortsPostOptions)
}

// PcloudNetworksPortsPostWithContext is an alternate form of the PcloudNetworksPortsPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudNetworksPortsPostWithContext(ctx context.Context, pcloudNetworksPortsPostOptions *PcloudNetworksPortsPostOptions) (result *NetworkPort, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudNetworksPortsPostOptions, "pcloudNetworksPortsPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudNetworksPortsPostOptions, "pcloudNetworksPortsPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudNetworksPortsPostOptions.CloudInstanceID,
		"network_id": *pcloudNetworksPortsPostOptions.NetworkID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/networks/{network_id}/ports`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudNetworksPortsPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudNetworksPortsPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudNetworksPortsPostOptions.Description != nil {
		body["description"] = pcloudNetworksPortsPostOptions.Description
	}
	if pcloudNetworksPortsPostOptions.IPAddress != nil {
		body["ipAddress"] = pcloudNetworksPortsPostOptions.IPAddress
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkPort)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudNetworksPortsDelete : Delete a Network Port
func (powervs *PowervsV1) PcloudNetworksPortsDelete(pcloudNetworksPortsDeleteOptions *PcloudNetworksPortsDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudNetworksPortsDeleteWithContext(context.Background(), pcloudNetworksPortsDeleteOptions)
}

// PcloudNetworksPortsDeleteWithContext is an alternate form of the PcloudNetworksPortsDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudNetworksPortsDeleteWithContext(ctx context.Context, pcloudNetworksPortsDeleteOptions *PcloudNetworksPortsDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudNetworksPortsDeleteOptions, "pcloudNetworksPortsDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudNetworksPortsDeleteOptions, "pcloudNetworksPortsDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudNetworksPortsDeleteOptions.CloudInstanceID,
		"network_id": *pcloudNetworksPortsDeleteOptions.NetworkID,
		"port_id": *pcloudNetworksPortsDeleteOptions.PortID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/networks/{network_id}/ports/{port_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudNetworksPortsDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudNetworksPortsDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudNetworksPortsGet : Get a port's information
func (powervs *PowervsV1) PcloudNetworksPortsGet(pcloudNetworksPortsGetOptions *PcloudNetworksPortsGetOptions) (result *NetworkPort, response *core.DetailedResponse, err error) {
	return powervs.PcloudNetworksPortsGetWithContext(context.Background(), pcloudNetworksPortsGetOptions)
}

// PcloudNetworksPortsGetWithContext is an alternate form of the PcloudNetworksPortsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudNetworksPortsGetWithContext(ctx context.Context, pcloudNetworksPortsGetOptions *PcloudNetworksPortsGetOptions) (result *NetworkPort, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudNetworksPortsGetOptions, "pcloudNetworksPortsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudNetworksPortsGetOptions, "pcloudNetworksPortsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudNetworksPortsGetOptions.CloudInstanceID,
		"network_id": *pcloudNetworksPortsGetOptions.NetworkID,
		"port_id": *pcloudNetworksPortsGetOptions.PortID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/networks/{network_id}/ports/{port_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudNetworksPortsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudNetworksPortsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if pcloudNetworksPortsGetOptions.Accept != nil {
		builder.AddHeader("Accept", fmt.Sprint(*pcloudNetworksPortsGetOptions.Accept))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkPort)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudNetworksPortsPut : Update a port's information
func (powervs *PowervsV1) PcloudNetworksPortsPut(pcloudNetworksPortsPutOptions *PcloudNetworksPortsPutOptions) (result *NetworkPort, response *core.DetailedResponse, err error) {
	return powervs.PcloudNetworksPortsPutWithContext(context.Background(), pcloudNetworksPortsPutOptions)
}

// PcloudNetworksPortsPutWithContext is an alternate form of the PcloudNetworksPortsPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudNetworksPortsPutWithContext(ctx context.Context, pcloudNetworksPortsPutOptions *PcloudNetworksPortsPutOptions) (result *NetworkPort, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudNetworksPortsPutOptions, "pcloudNetworksPortsPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudNetworksPortsPutOptions, "pcloudNetworksPortsPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudNetworksPortsPutOptions.CloudInstanceID,
		"network_id": *pcloudNetworksPortsPutOptions.NetworkID,
		"port_id": *pcloudNetworksPortsPutOptions.PortID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/networks/{network_id}/ports/{port_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudNetworksPortsPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudNetworksPortsPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudNetworksPortsPutOptions.Description != nil {
		body["description"] = pcloudNetworksPortsPutOptions.Description
	}
	if pcloudNetworksPortsPutOptions.PvmInstanceID != nil {
		body["pvmInstanceID"] = pcloudNetworksPortsPutOptions.PvmInstanceID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkPort)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesGetall : Get all the pvm instances for this cloud instance
func (powervs *PowervsV1) PcloudPvminstancesGetall(pcloudPvminstancesGetallOptions *PcloudPvminstancesGetallOptions) (result *PvmInstances, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesGetallWithContext(context.Background(), pcloudPvminstancesGetallOptions)
}

// PcloudPvminstancesGetallWithContext is an alternate form of the PcloudPvminstancesGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesGetallWithContext(ctx context.Context, pcloudPvminstancesGetallOptions *PcloudPvminstancesGetallOptions) (result *PvmInstances, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesGetallOptions, "pcloudPvminstancesGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesGetallOptions, "pcloudPvminstancesGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPvmInstances)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesPost : Create a new Power VM Instance
func (powervs *PowervsV1) PcloudPvminstancesPost(pcloudPvminstancesPostOptions *PcloudPvminstancesPostOptions) (result []PvmInstance, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesPostWithContext(context.Background(), pcloudPvminstancesPostOptions)
}

// PcloudPvminstancesPostWithContext is an alternate form of the PcloudPvminstancesPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesPostWithContext(ctx context.Context, pcloudPvminstancesPostOptions *PcloudPvminstancesPostOptions) (result []PvmInstance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesPostOptions, "pcloudPvminstancesPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesPostOptions, "pcloudPvminstancesPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	if pcloudPvminstancesPostOptions.SkipHostValidation != nil {
		builder.AddQuery("skipHostValidation", fmt.Sprint(*pcloudPvminstancesPostOptions.SkipHostValidation))
	}

	body := make(map[string]interface{})
	if pcloudPvminstancesPostOptions.ImageID != nil {
		body["imageID"] = pcloudPvminstancesPostOptions.ImageID
	}
	if pcloudPvminstancesPostOptions.Memory != nil {
		body["memory"] = pcloudPvminstancesPostOptions.Memory
	}
	if pcloudPvminstancesPostOptions.ProcType != nil {
		body["procType"] = pcloudPvminstancesPostOptions.ProcType
	}
	if pcloudPvminstancesPostOptions.Processors != nil {
		body["processors"] = pcloudPvminstancesPostOptions.Processors
	}
	if pcloudPvminstancesPostOptions.ServerName != nil {
		body["serverName"] = pcloudPvminstancesPostOptions.ServerName
	}
	if pcloudPvminstancesPostOptions.DeploymentType != nil {
		body["deploymentType"] = pcloudPvminstancesPostOptions.DeploymentType
	}
	if pcloudPvminstancesPostOptions.KeyPairName != nil {
		body["keyPairName"] = pcloudPvminstancesPostOptions.KeyPairName
	}
	if pcloudPvminstancesPostOptions.LicenseRepositoryCapacity != nil {
		body["licenseRepositoryCapacity"] = pcloudPvminstancesPostOptions.LicenseRepositoryCapacity
	}
	if pcloudPvminstancesPostOptions.Migratable != nil {
		body["migratable"] = pcloudPvminstancesPostOptions.Migratable
	}
	if pcloudPvminstancesPostOptions.NetworkIDs != nil {
		body["networkIDs"] = pcloudPvminstancesPostOptions.NetworkIDs
	}
	if pcloudPvminstancesPostOptions.Networks != nil {
		body["networks"] = pcloudPvminstancesPostOptions.Networks
	}
	if pcloudPvminstancesPostOptions.PinPolicy != nil {
		body["pinPolicy"] = pcloudPvminstancesPostOptions.PinPolicy
	}
	if pcloudPvminstancesPostOptions.PlacementGroup != nil {
		body["placementGroup"] = pcloudPvminstancesPostOptions.PlacementGroup
	}
	if pcloudPvminstancesPostOptions.ReplicantAffinityPolicy != nil {
		body["replicantAffinityPolicy"] = pcloudPvminstancesPostOptions.ReplicantAffinityPolicy
	}
	if pcloudPvminstancesPostOptions.ReplicantNamingScheme != nil {
		body["replicantNamingScheme"] = pcloudPvminstancesPostOptions.ReplicantNamingScheme
	}
	if pcloudPvminstancesPostOptions.Replicants != nil {
		body["replicants"] = pcloudPvminstancesPostOptions.Replicants
	}
	if pcloudPvminstancesPostOptions.SharedProcessorPool != nil {
		body["sharedProcessorPool"] = pcloudPvminstancesPostOptions.SharedProcessorPool
	}
	if pcloudPvminstancesPostOptions.SoftwareLicenses != nil {
		body["softwareLicenses"] = pcloudPvminstancesPostOptions.SoftwareLicenses
	}
	if pcloudPvminstancesPostOptions.StorageAffinity != nil {
		body["storageAffinity"] = pcloudPvminstancesPostOptions.StorageAffinity
	}
	if pcloudPvminstancesPostOptions.StorageConnection != nil {
		body["storageConnection"] = pcloudPvminstancesPostOptions.StorageConnection
	}
	if pcloudPvminstancesPostOptions.StorageConnectionV2 != nil {
		body["storageConnectionV2"] = pcloudPvminstancesPostOptions.StorageConnectionV2
	}
	if pcloudPvminstancesPostOptions.StoragePool != nil {
		body["storagePool"] = pcloudPvminstancesPostOptions.StoragePool
	}
	if pcloudPvminstancesPostOptions.StorageType != nil {
		body["storageType"] = pcloudPvminstancesPostOptions.StorageType
	}
	if pcloudPvminstancesPostOptions.SysType != nil {
		body["sysType"] = pcloudPvminstancesPostOptions.SysType
	}
	if pcloudPvminstancesPostOptions.UserData != nil {
		body["userData"] = pcloudPvminstancesPostOptions.UserData
	}
	if pcloudPvminstancesPostOptions.VirtualCores != nil {
		body["virtualCores"] = pcloudPvminstancesPostOptions.VirtualCores
	}
	if pcloudPvminstancesPostOptions.VolumeIDs != nil {
		body["volumeIDs"] = pcloudPvminstancesPostOptions.VolumeIDs
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPvmInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesDelete : Delete a PCloud PVM Instance
func (powervs *PowervsV1) PcloudPvminstancesDelete(pcloudPvminstancesDeleteOptions *PcloudPvminstancesDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesDeleteWithContext(context.Background(), pcloudPvminstancesDeleteOptions)
}

// PcloudPvminstancesDeleteWithContext is an alternate form of the PcloudPvminstancesDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesDeleteWithContext(ctx context.Context, pcloudPvminstancesDeleteOptions *PcloudPvminstancesDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesDeleteOptions, "pcloudPvminstancesDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesDeleteOptions, "pcloudPvminstancesDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesDeleteOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesDeleteOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if pcloudPvminstancesDeleteOptions.DeleteDataVolumes != nil {
		builder.AddQuery("delete_data_volumes", fmt.Sprint(*pcloudPvminstancesDeleteOptions.DeleteDataVolumes))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesGet : Get a PVM Instance's current state or information
func (powervs *PowervsV1) PcloudPvminstancesGet(pcloudPvminstancesGetOptions *PcloudPvminstancesGetOptions) (result *PvmInstance, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesGetWithContext(context.Background(), pcloudPvminstancesGetOptions)
}

// PcloudPvminstancesGetWithContext is an alternate form of the PcloudPvminstancesGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesGetWithContext(ctx context.Context, pcloudPvminstancesGetOptions *PcloudPvminstancesGetOptions) (result *PvmInstance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesGetOptions, "pcloudPvminstancesGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesGetOptions, "pcloudPvminstancesGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesGetOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesGetOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPvmInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesPut : Update a PCloud PVM Instance
func (powervs *PowervsV1) PcloudPvminstancesPut(pcloudPvminstancesPutOptions *PcloudPvminstancesPutOptions) (result *PvmInstanceUpdateResponse, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesPutWithContext(context.Background(), pcloudPvminstancesPutOptions)
}

// PcloudPvminstancesPutWithContext is an alternate form of the PcloudPvminstancesPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesPutWithContext(ctx context.Context, pcloudPvminstancesPutOptions *PcloudPvminstancesPutOptions) (result *PvmInstanceUpdateResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesPutOptions, "pcloudPvminstancesPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesPutOptions, "pcloudPvminstancesPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesPutOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesPutOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudPvminstancesPutOptions.CloudInitialization != nil {
		body["cloudInitialization"] = pcloudPvminstancesPutOptions.CloudInitialization
	}
	if pcloudPvminstancesPutOptions.LicenseRepositoryCapacity != nil {
		body["licenseRepositoryCapacity"] = pcloudPvminstancesPutOptions.LicenseRepositoryCapacity
	}
	if pcloudPvminstancesPutOptions.Memory != nil {
		body["memory"] = pcloudPvminstancesPutOptions.Memory
	}
	if pcloudPvminstancesPutOptions.Migratable != nil {
		body["migratable"] = pcloudPvminstancesPutOptions.Migratable
	}
	if pcloudPvminstancesPutOptions.PinPolicy != nil {
		body["pinPolicy"] = pcloudPvminstancesPutOptions.PinPolicy
	}
	if pcloudPvminstancesPutOptions.ProcType != nil {
		body["procType"] = pcloudPvminstancesPutOptions.ProcType
	}
	if pcloudPvminstancesPutOptions.Processors != nil {
		body["processors"] = pcloudPvminstancesPutOptions.Processors
	}
	if pcloudPvminstancesPutOptions.SapProfileID != nil {
		body["sapProfileID"] = pcloudPvminstancesPutOptions.SapProfileID
	}
	if pcloudPvminstancesPutOptions.ServerName != nil {
		body["serverName"] = pcloudPvminstancesPutOptions.ServerName
	}
	if pcloudPvminstancesPutOptions.SoftwareLicenses != nil {
		body["softwareLicenses"] = pcloudPvminstancesPutOptions.SoftwareLicenses
	}
	if pcloudPvminstancesPutOptions.StoragePoolAffinity != nil {
		body["storagePoolAffinity"] = pcloudPvminstancesPutOptions.StoragePoolAffinity
	}
	if pcloudPvminstancesPutOptions.VirtualCores != nil {
		body["virtualCores"] = pcloudPvminstancesPutOptions.VirtualCores
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPvmInstanceUpdateResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesActionPost : Perform an action (start stop reboot immediate-shutdown reset) on a PVMInstance
func (powervs *PowervsV1) PcloudPvminstancesActionPost(pcloudPvminstancesActionPostOptions *PcloudPvminstancesActionPostOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesActionPostWithContext(context.Background(), pcloudPvminstancesActionPostOptions)
}

// PcloudPvminstancesActionPostWithContext is an alternate form of the PcloudPvminstancesActionPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesActionPostWithContext(ctx context.Context, pcloudPvminstancesActionPostOptions *PcloudPvminstancesActionPostOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesActionPostOptions, "pcloudPvminstancesActionPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesActionPostOptions, "pcloudPvminstancesActionPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesActionPostOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesActionPostOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/action`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesActionPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesActionPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudPvminstancesActionPostOptions.Action != nil {
		body["action"] = pcloudPvminstancesActionPostOptions.Action
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesCapturePost : Capture a PVMInstance and create a deployable image
// This API is deprecated for /pcloud/v2/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/capture.
//
// >*Note*: Support for this API is available till Oct 2022.
// Deprecated: this method is deprecated and may be removed in a future release.
func (powervs *PowervsV1) PcloudPvminstancesCapturePost(pcloudPvminstancesCapturePostOptions *PcloudPvminstancesCapturePostOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesCapturePostWithContext(context.Background(), pcloudPvminstancesCapturePostOptions)
}

// PcloudPvminstancesCapturePostWithContext is an alternate form of the PcloudPvminstancesCapturePost method which supports a Context parameter
// Deprecated: this method is deprecated and may be removed in a future release.
func (powervs *PowervsV1) PcloudPvminstancesCapturePostWithContext(ctx context.Context, pcloudPvminstancesCapturePostOptions *PcloudPvminstancesCapturePostOptions) (result *Object, response *core.DetailedResponse, err error) {
	core.GetLogger().Warn("A deprecated operation has been invoked: PcloudPvminstancesCapturePost")
	err = core.ValidateNotNil(pcloudPvminstancesCapturePostOptions, "pcloudPvminstancesCapturePostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesCapturePostOptions, "pcloudPvminstancesCapturePostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesCapturePostOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesCapturePostOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/capture`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesCapturePostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesCapturePost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudPvminstancesCapturePostOptions.CaptureDestination != nil {
		body["captureDestination"] = pcloudPvminstancesCapturePostOptions.CaptureDestination
	}
	if pcloudPvminstancesCapturePostOptions.CaptureName != nil {
		body["captureName"] = pcloudPvminstancesCapturePostOptions.CaptureName
	}
	if pcloudPvminstancesCapturePostOptions.CaptureVolumeIDs != nil {
		body["captureVolumeIDs"] = pcloudPvminstancesCapturePostOptions.CaptureVolumeIDs
	}
	if pcloudPvminstancesCapturePostOptions.CloudStorageAccessKey != nil {
		body["cloudStorageAccessKey"] = pcloudPvminstancesCapturePostOptions.CloudStorageAccessKey
	}
	if pcloudPvminstancesCapturePostOptions.CloudStorageImagePath != nil {
		body["cloudStorageImagePath"] = pcloudPvminstancesCapturePostOptions.CloudStorageImagePath
	}
	if pcloudPvminstancesCapturePostOptions.CloudStorageRegion != nil {
		body["cloudStorageRegion"] = pcloudPvminstancesCapturePostOptions.CloudStorageRegion
	}
	if pcloudPvminstancesCapturePostOptions.CloudStorageSecretKey != nil {
		body["cloudStorageSecretKey"] = pcloudPvminstancesCapturePostOptions.CloudStorageSecretKey
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesClonePost : Clone a PVMInstance
func (powervs *PowervsV1) PcloudPvminstancesClonePost(pcloudPvminstancesClonePostOptions *PcloudPvminstancesClonePostOptions) (result *PvmInstance, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesClonePostWithContext(context.Background(), pcloudPvminstancesClonePostOptions)
}

// PcloudPvminstancesClonePostWithContext is an alternate form of the PcloudPvminstancesClonePost method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesClonePostWithContext(ctx context.Context, pcloudPvminstancesClonePostOptions *PcloudPvminstancesClonePostOptions) (result *PvmInstance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesClonePostOptions, "pcloudPvminstancesClonePostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesClonePostOptions, "pcloudPvminstancesClonePostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesClonePostOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesClonePostOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/clone`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesClonePostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesClonePost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudPvminstancesClonePostOptions.Name != nil {
		body["name"] = pcloudPvminstancesClonePostOptions.Name
	}
	if pcloudPvminstancesClonePostOptions.Networks != nil {
		body["networks"] = pcloudPvminstancesClonePostOptions.Networks
	}
	if pcloudPvminstancesClonePostOptions.KeyPairName != nil {
		body["keyPairName"] = pcloudPvminstancesClonePostOptions.KeyPairName
	}
	if pcloudPvminstancesClonePostOptions.Memory != nil {
		body["memory"] = pcloudPvminstancesClonePostOptions.Memory
	}
	if pcloudPvminstancesClonePostOptions.ProcType != nil {
		body["procType"] = pcloudPvminstancesClonePostOptions.ProcType
	}
	if pcloudPvminstancesClonePostOptions.Processors != nil {
		body["processors"] = pcloudPvminstancesClonePostOptions.Processors
	}
	if pcloudPvminstancesClonePostOptions.SoftwareLicenses != nil {
		body["softwareLicenses"] = pcloudPvminstancesClonePostOptions.SoftwareLicenses
	}
	if pcloudPvminstancesClonePostOptions.VolumeIDs != nil {
		body["volumeIDs"] = pcloudPvminstancesClonePostOptions.VolumeIDs
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPvmInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesConsoleGet : List all console languages
func (powervs *PowervsV1) PcloudPvminstancesConsoleGet(pcloudPvminstancesConsoleGetOptions *PcloudPvminstancesConsoleGetOptions) (result *ConsoleLanguages, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesConsoleGetWithContext(context.Background(), pcloudPvminstancesConsoleGetOptions)
}

// PcloudPvminstancesConsoleGetWithContext is an alternate form of the PcloudPvminstancesConsoleGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesConsoleGetWithContext(ctx context.Context, pcloudPvminstancesConsoleGetOptions *PcloudPvminstancesConsoleGetOptions) (result *ConsoleLanguages, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesConsoleGetOptions, "pcloudPvminstancesConsoleGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesConsoleGetOptions, "pcloudPvminstancesConsoleGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesConsoleGetOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesConsoleGetOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/console`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesConsoleGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesConsoleGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalConsoleLanguages)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesConsolePost : Generate the noVNC Console URL
func (powervs *PowervsV1) PcloudPvminstancesConsolePost(pcloudPvminstancesConsolePostOptions *PcloudPvminstancesConsolePostOptions) (result *PvmInstanceConsole, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesConsolePostWithContext(context.Background(), pcloudPvminstancesConsolePostOptions)
}

// PcloudPvminstancesConsolePostWithContext is an alternate form of the PcloudPvminstancesConsolePost method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesConsolePostWithContext(ctx context.Context, pcloudPvminstancesConsolePostOptions *PcloudPvminstancesConsolePostOptions) (result *PvmInstanceConsole, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesConsolePostOptions, "pcloudPvminstancesConsolePostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesConsolePostOptions, "pcloudPvminstancesConsolePostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesConsolePostOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesConsolePostOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/console`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesConsolePostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesConsolePost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPvmInstanceConsole)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesConsolePut : Update PVMInstance console laguage code
func (powervs *PowervsV1) PcloudPvminstancesConsolePut(pcloudPvminstancesConsolePutOptions *PcloudPvminstancesConsolePutOptions) (result *ConsoleLanguage, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesConsolePutWithContext(context.Background(), pcloudPvminstancesConsolePutOptions)
}

// PcloudPvminstancesConsolePutWithContext is an alternate form of the PcloudPvminstancesConsolePut method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesConsolePutWithContext(ctx context.Context, pcloudPvminstancesConsolePutOptions *PcloudPvminstancesConsolePutOptions) (result *ConsoleLanguage, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesConsolePutOptions, "pcloudPvminstancesConsolePutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesConsolePutOptions, "pcloudPvminstancesConsolePutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesConsolePutOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesConsolePutOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/console`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesConsolePutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesConsolePut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudPvminstancesConsolePutOptions.Code != nil {
		body["code"] = pcloudPvminstancesConsolePutOptions.Code
	}
	if pcloudPvminstancesConsolePutOptions.Language != nil {
		body["language"] = pcloudPvminstancesConsolePutOptions.Language
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalConsoleLanguage)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesNetworksGetall : Get all networks for this PVM Instance
func (powervs *PowervsV1) PcloudPvminstancesNetworksGetall(pcloudPvminstancesNetworksGetallOptions *PcloudPvminstancesNetworksGetallOptions) (result *PvmInstanceNetworks, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesNetworksGetallWithContext(context.Background(), pcloudPvminstancesNetworksGetallOptions)
}

// PcloudPvminstancesNetworksGetallWithContext is an alternate form of the PcloudPvminstancesNetworksGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesNetworksGetallWithContext(ctx context.Context, pcloudPvminstancesNetworksGetallOptions *PcloudPvminstancesNetworksGetallOptions) (result *PvmInstanceNetworks, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesNetworksGetallOptions, "pcloudPvminstancesNetworksGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesNetworksGetallOptions, "pcloudPvminstancesNetworksGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesNetworksGetallOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesNetworksGetallOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/networks`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesNetworksGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesNetworksGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPvmInstanceNetworks)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesNetworksPost : Perform network addition
func (powervs *PowervsV1) PcloudPvminstancesNetworksPost(pcloudPvminstancesNetworksPostOptions *PcloudPvminstancesNetworksPostOptions) (result *PvmInstanceNetwork, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesNetworksPostWithContext(context.Background(), pcloudPvminstancesNetworksPostOptions)
}

// PcloudPvminstancesNetworksPostWithContext is an alternate form of the PcloudPvminstancesNetworksPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesNetworksPostWithContext(ctx context.Context, pcloudPvminstancesNetworksPostOptions *PcloudPvminstancesNetworksPostOptions) (result *PvmInstanceNetwork, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesNetworksPostOptions, "pcloudPvminstancesNetworksPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesNetworksPostOptions, "pcloudPvminstancesNetworksPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesNetworksPostOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesNetworksPostOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/networks`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesNetworksPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesNetworksPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudPvminstancesNetworksPostOptions.NetworkID != nil {
		body["networkID"] = pcloudPvminstancesNetworksPostOptions.NetworkID
	}
	if pcloudPvminstancesNetworksPostOptions.IPAddress != nil {
		body["ipAddress"] = pcloudPvminstancesNetworksPostOptions.IPAddress
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPvmInstanceNetwork)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesNetworksDelete : Remove all Address of Network from a PVM Instance
func (powervs *PowervsV1) PcloudPvminstancesNetworksDelete(pcloudPvminstancesNetworksDeleteOptions *PcloudPvminstancesNetworksDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesNetworksDeleteWithContext(context.Background(), pcloudPvminstancesNetworksDeleteOptions)
}

// PcloudPvminstancesNetworksDeleteWithContext is an alternate form of the PcloudPvminstancesNetworksDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesNetworksDeleteWithContext(ctx context.Context, pcloudPvminstancesNetworksDeleteOptions *PcloudPvminstancesNetworksDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesNetworksDeleteOptions, "pcloudPvminstancesNetworksDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesNetworksDeleteOptions, "pcloudPvminstancesNetworksDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesNetworksDeleteOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesNetworksDeleteOptions.PvmInstanceID,
		"network_id": *pcloudPvminstancesNetworksDeleteOptions.NetworkID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/networks/{network_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesNetworksDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesNetworksDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudPvminstancesNetworksDeleteOptions.MacAddress != nil {
		body["macAddress"] = pcloudPvminstancesNetworksDeleteOptions.MacAddress
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesNetworksGet : Get a PVM Instance's network information
func (powervs *PowervsV1) PcloudPvminstancesNetworksGet(pcloudPvminstancesNetworksGetOptions *PcloudPvminstancesNetworksGetOptions) (result *PvmInstanceNetworks, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesNetworksGetWithContext(context.Background(), pcloudPvminstancesNetworksGetOptions)
}

// PcloudPvminstancesNetworksGetWithContext is an alternate form of the PcloudPvminstancesNetworksGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesNetworksGetWithContext(ctx context.Context, pcloudPvminstancesNetworksGetOptions *PcloudPvminstancesNetworksGetOptions) (result *PvmInstanceNetworks, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesNetworksGetOptions, "pcloudPvminstancesNetworksGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesNetworksGetOptions, "pcloudPvminstancesNetworksGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesNetworksGetOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesNetworksGetOptions.PvmInstanceID,
		"network_id": *pcloudPvminstancesNetworksGetOptions.NetworkID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/networks/{network_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesNetworksGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesNetworksGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPvmInstanceNetworks)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesOperationsPost : Perform an operation on a PVMInstance
func (powervs *PowervsV1) PcloudPvminstancesOperationsPost(pcloudPvminstancesOperationsPostOptions *PcloudPvminstancesOperationsPostOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesOperationsPostWithContext(context.Background(), pcloudPvminstancesOperationsPostOptions)
}

// PcloudPvminstancesOperationsPostWithContext is an alternate form of the PcloudPvminstancesOperationsPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesOperationsPostWithContext(ctx context.Context, pcloudPvminstancesOperationsPostOptions *PcloudPvminstancesOperationsPostOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesOperationsPostOptions, "pcloudPvminstancesOperationsPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesOperationsPostOptions, "pcloudPvminstancesOperationsPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesOperationsPostOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesOperationsPostOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/operations`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesOperationsPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesOperationsPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudPvminstancesOperationsPostOptions.Operation != nil {
		body["operation"] = pcloudPvminstancesOperationsPostOptions.Operation
	}
	if pcloudPvminstancesOperationsPostOptions.OperationType != nil {
		body["operationType"] = pcloudPvminstancesOperationsPostOptions.OperationType
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesSnapshotsGetall : Get all snapshots for this PVM Instance
func (powervs *PowervsV1) PcloudPvminstancesSnapshotsGetall(pcloudPvminstancesSnapshotsGetallOptions *PcloudPvminstancesSnapshotsGetallOptions) (result *Snapshots, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesSnapshotsGetallWithContext(context.Background(), pcloudPvminstancesSnapshotsGetallOptions)
}

// PcloudPvminstancesSnapshotsGetallWithContext is an alternate form of the PcloudPvminstancesSnapshotsGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesSnapshotsGetallWithContext(ctx context.Context, pcloudPvminstancesSnapshotsGetallOptions *PcloudPvminstancesSnapshotsGetallOptions) (result *Snapshots, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesSnapshotsGetallOptions, "pcloudPvminstancesSnapshotsGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesSnapshotsGetallOptions, "pcloudPvminstancesSnapshotsGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesSnapshotsGetallOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesSnapshotsGetallOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/snapshots`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesSnapshotsGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesSnapshotsGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSnapshots)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesSnapshotsPost : Create a PVM Instance snapshot
func (powervs *PowervsV1) PcloudPvminstancesSnapshotsPost(pcloudPvminstancesSnapshotsPostOptions *PcloudPvminstancesSnapshotsPostOptions) (result *SnapshotCreateResponse, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesSnapshotsPostWithContext(context.Background(), pcloudPvminstancesSnapshotsPostOptions)
}

// PcloudPvminstancesSnapshotsPostWithContext is an alternate form of the PcloudPvminstancesSnapshotsPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesSnapshotsPostWithContext(ctx context.Context, pcloudPvminstancesSnapshotsPostOptions *PcloudPvminstancesSnapshotsPostOptions) (result *SnapshotCreateResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesSnapshotsPostOptions, "pcloudPvminstancesSnapshotsPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesSnapshotsPostOptions, "pcloudPvminstancesSnapshotsPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesSnapshotsPostOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesSnapshotsPostOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/snapshots`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesSnapshotsPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesSnapshotsPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudPvminstancesSnapshotsPostOptions.Name != nil {
		body["name"] = pcloudPvminstancesSnapshotsPostOptions.Name
	}
	if pcloudPvminstancesSnapshotsPostOptions.Description != nil {
		body["description"] = pcloudPvminstancesSnapshotsPostOptions.Description
	}
	if pcloudPvminstancesSnapshotsPostOptions.VolumeIDs != nil {
		body["volumeIDs"] = pcloudPvminstancesSnapshotsPostOptions.VolumeIDs
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSnapshotCreateResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesSnapshotsRestorePost : Restore a PVM Instance snapshot
func (powervs *PowervsV1) PcloudPvminstancesSnapshotsRestorePost(pcloudPvminstancesSnapshotsRestorePostOptions *PcloudPvminstancesSnapshotsRestorePostOptions) (result *Snapshot, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesSnapshotsRestorePostWithContext(context.Background(), pcloudPvminstancesSnapshotsRestorePostOptions)
}

// PcloudPvminstancesSnapshotsRestorePostWithContext is an alternate form of the PcloudPvminstancesSnapshotsRestorePost method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesSnapshotsRestorePostWithContext(ctx context.Context, pcloudPvminstancesSnapshotsRestorePostOptions *PcloudPvminstancesSnapshotsRestorePostOptions) (result *Snapshot, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesSnapshotsRestorePostOptions, "pcloudPvminstancesSnapshotsRestorePostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesSnapshotsRestorePostOptions, "pcloudPvminstancesSnapshotsRestorePostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesSnapshotsRestorePostOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesSnapshotsRestorePostOptions.PvmInstanceID,
		"snapshot_id": *pcloudPvminstancesSnapshotsRestorePostOptions.SnapshotID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/snapshots/{snapshot_id}/restore`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesSnapshotsRestorePostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesSnapshotsRestorePost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	if pcloudPvminstancesSnapshotsRestorePostOptions.RestoreFailAction != nil {
		builder.AddQuery("restore_fail_action", fmt.Sprint(*pcloudPvminstancesSnapshotsRestorePostOptions.RestoreFailAction))
	}

	body := make(map[string]interface{})
	if pcloudPvminstancesSnapshotsRestorePostOptions.Force != nil {
		body["force"] = pcloudPvminstancesSnapshotsRestorePostOptions.Force
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSnapshot)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2PvminstancesGetall : Get all the pvm instances for this cloud instance
func (powervs *PowervsV1) PcloudV2PvminstancesGetall(pcloudV2PvminstancesGetallOptions *PcloudV2PvminstancesGetallOptions) (result *PvmInstancesV2, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2PvminstancesGetallWithContext(context.Background(), pcloudV2PvminstancesGetallOptions)
}

// PcloudV2PvminstancesGetallWithContext is an alternate form of the PcloudV2PvminstancesGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2PvminstancesGetallWithContext(ctx context.Context, pcloudV2PvminstancesGetallOptions *PcloudV2PvminstancesGetallOptions) (result *PvmInstancesV2, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2PvminstancesGetallOptions, "pcloudV2PvminstancesGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2PvminstancesGetallOptions, "pcloudV2PvminstancesGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2PvminstancesGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/pvm-instances`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2PvminstancesGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2PvminstancesGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPvmInstancesV2)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2PvminstancesCaptureGet : Get detail of last capture job
func (powervs *PowervsV1) PcloudV2PvminstancesCaptureGet(pcloudV2PvminstancesCaptureGetOptions *PcloudV2PvminstancesCaptureGetOptions) (result *Job, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2PvminstancesCaptureGetWithContext(context.Background(), pcloudV2PvminstancesCaptureGetOptions)
}

// PcloudV2PvminstancesCaptureGetWithContext is an alternate form of the PcloudV2PvminstancesCaptureGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2PvminstancesCaptureGetWithContext(ctx context.Context, pcloudV2PvminstancesCaptureGetOptions *PcloudV2PvminstancesCaptureGetOptions) (result *Job, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2PvminstancesCaptureGetOptions, "pcloudV2PvminstancesCaptureGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2PvminstancesCaptureGetOptions, "pcloudV2PvminstancesCaptureGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2PvminstancesCaptureGetOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudV2PvminstancesCaptureGetOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/capture`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2PvminstancesCaptureGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2PvminstancesCaptureGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalJob)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2PvminstancesCapturePost : Add a capture pvm-instance to the jobs queue
func (powervs *PowervsV1) PcloudV2PvminstancesCapturePost(pcloudV2PvminstancesCapturePostOptions *PcloudV2PvminstancesCapturePostOptions) (result *JobReference, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2PvminstancesCapturePostWithContext(context.Background(), pcloudV2PvminstancesCapturePostOptions)
}

// PcloudV2PvminstancesCapturePostWithContext is an alternate form of the PcloudV2PvminstancesCapturePost method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2PvminstancesCapturePostWithContext(ctx context.Context, pcloudV2PvminstancesCapturePostOptions *PcloudV2PvminstancesCapturePostOptions) (result *JobReference, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2PvminstancesCapturePostOptions, "pcloudV2PvminstancesCapturePostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2PvminstancesCapturePostOptions, "pcloudV2PvminstancesCapturePostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2PvminstancesCapturePostOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudV2PvminstancesCapturePostOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/capture`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2PvminstancesCapturePostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2PvminstancesCapturePost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudV2PvminstancesCapturePostOptions.CaptureDestination != nil {
		body["captureDestination"] = pcloudV2PvminstancesCapturePostOptions.CaptureDestination
	}
	if pcloudV2PvminstancesCapturePostOptions.CaptureName != nil {
		body["captureName"] = pcloudV2PvminstancesCapturePostOptions.CaptureName
	}
	if pcloudV2PvminstancesCapturePostOptions.CaptureVolumeIDs != nil {
		body["captureVolumeIDs"] = pcloudV2PvminstancesCapturePostOptions.CaptureVolumeIDs
	}
	if pcloudV2PvminstancesCapturePostOptions.CloudStorageAccessKey != nil {
		body["cloudStorageAccessKey"] = pcloudV2PvminstancesCapturePostOptions.CloudStorageAccessKey
	}
	if pcloudV2PvminstancesCapturePostOptions.CloudStorageImagePath != nil {
		body["cloudStorageImagePath"] = pcloudV2PvminstancesCapturePostOptions.CloudStorageImagePath
	}
	if pcloudV2PvminstancesCapturePostOptions.CloudStorageRegion != nil {
		body["cloudStorageRegion"] = pcloudV2PvminstancesCapturePostOptions.CloudStorageRegion
	}
	if pcloudV2PvminstancesCapturePostOptions.CloudStorageSecretKey != nil {
		body["cloudStorageSecretKey"] = pcloudV2PvminstancesCapturePostOptions.CloudStorageSecretKey
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalJobReference)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPlacementgroupsGetall : Get all Server Placement Groups
func (powervs *PowervsV1) PcloudPlacementgroupsGetall(pcloudPlacementgroupsGetallOptions *PcloudPlacementgroupsGetallOptions) (result *PlacementGroups, response *core.DetailedResponse, err error) {
	return powervs.PcloudPlacementgroupsGetallWithContext(context.Background(), pcloudPlacementgroupsGetallOptions)
}

// PcloudPlacementgroupsGetallWithContext is an alternate form of the PcloudPlacementgroupsGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudPlacementgroupsGetallWithContext(ctx context.Context, pcloudPlacementgroupsGetallOptions *PcloudPlacementgroupsGetallOptions) (result *PlacementGroups, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPlacementgroupsGetallOptions, "pcloudPlacementgroupsGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPlacementgroupsGetallOptions, "pcloudPlacementgroupsGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPlacementgroupsGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/placement-groups`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPlacementgroupsGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPlacementgroupsGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPlacementGroups)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPlacementgroupsPost : Create a new Server Placement Group
func (powervs *PowervsV1) PcloudPlacementgroupsPost(pcloudPlacementgroupsPostOptions *PcloudPlacementgroupsPostOptions) (result *PlacementGroup, response *core.DetailedResponse, err error) {
	return powervs.PcloudPlacementgroupsPostWithContext(context.Background(), pcloudPlacementgroupsPostOptions)
}

// PcloudPlacementgroupsPostWithContext is an alternate form of the PcloudPlacementgroupsPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudPlacementgroupsPostWithContext(ctx context.Context, pcloudPlacementgroupsPostOptions *PcloudPlacementgroupsPostOptions) (result *PlacementGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPlacementgroupsPostOptions, "pcloudPlacementgroupsPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPlacementgroupsPostOptions, "pcloudPlacementgroupsPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPlacementgroupsPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/placement-groups`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPlacementgroupsPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPlacementgroupsPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudPlacementgroupsPostOptions.Name != nil {
		body["name"] = pcloudPlacementgroupsPostOptions.Name
	}
	if pcloudPlacementgroupsPostOptions.Policy != nil {
		body["policy"] = pcloudPlacementgroupsPostOptions.Policy
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPlacementGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPlacementgroupsDelete : Delete Server Placement Group
func (powervs *PowervsV1) PcloudPlacementgroupsDelete(pcloudPlacementgroupsDeleteOptions *PcloudPlacementgroupsDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudPlacementgroupsDeleteWithContext(context.Background(), pcloudPlacementgroupsDeleteOptions)
}

// PcloudPlacementgroupsDeleteWithContext is an alternate form of the PcloudPlacementgroupsDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudPlacementgroupsDeleteWithContext(ctx context.Context, pcloudPlacementgroupsDeleteOptions *PcloudPlacementgroupsDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPlacementgroupsDeleteOptions, "pcloudPlacementgroupsDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPlacementgroupsDeleteOptions, "pcloudPlacementgroupsDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPlacementgroupsDeleteOptions.CloudInstanceID,
		"placement_group_id": *pcloudPlacementgroupsDeleteOptions.PlacementGroupID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/placement-groups/{placement_group_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPlacementgroupsDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPlacementgroupsDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPlacementgroupsGet : Get Server Placement Group detail
func (powervs *PowervsV1) PcloudPlacementgroupsGet(pcloudPlacementgroupsGetOptions *PcloudPlacementgroupsGetOptions) (result *PlacementGroup, response *core.DetailedResponse, err error) {
	return powervs.PcloudPlacementgroupsGetWithContext(context.Background(), pcloudPlacementgroupsGetOptions)
}

// PcloudPlacementgroupsGetWithContext is an alternate form of the PcloudPlacementgroupsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudPlacementgroupsGetWithContext(ctx context.Context, pcloudPlacementgroupsGetOptions *PcloudPlacementgroupsGetOptions) (result *PlacementGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPlacementgroupsGetOptions, "pcloudPlacementgroupsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPlacementgroupsGetOptions, "pcloudPlacementgroupsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPlacementgroupsGetOptions.CloudInstanceID,
		"placement_group_id": *pcloudPlacementgroupsGetOptions.PlacementGroupID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/placement-groups/{placement_group_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPlacementgroupsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPlacementgroupsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPlacementGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPlacementgroupsMembersDelete : Remove Server from Placement Group
func (powervs *PowervsV1) PcloudPlacementgroupsMembersDelete(pcloudPlacementgroupsMembersDeleteOptions *PcloudPlacementgroupsMembersDeleteOptions) (result *PlacementGroup, response *core.DetailedResponse, err error) {
	return powervs.PcloudPlacementgroupsMembersDeleteWithContext(context.Background(), pcloudPlacementgroupsMembersDeleteOptions)
}

// PcloudPlacementgroupsMembersDeleteWithContext is an alternate form of the PcloudPlacementgroupsMembersDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudPlacementgroupsMembersDeleteWithContext(ctx context.Context, pcloudPlacementgroupsMembersDeleteOptions *PcloudPlacementgroupsMembersDeleteOptions) (result *PlacementGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPlacementgroupsMembersDeleteOptions, "pcloudPlacementgroupsMembersDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPlacementgroupsMembersDeleteOptions, "pcloudPlacementgroupsMembersDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPlacementgroupsMembersDeleteOptions.CloudInstanceID,
		"placement_group_id": *pcloudPlacementgroupsMembersDeleteOptions.PlacementGroupID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/placement-groups/{placement_group_id}/members`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPlacementgroupsMembersDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPlacementgroupsMembersDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudPlacementgroupsMembersDeleteOptions.ID != nil {
		body["id"] = pcloudPlacementgroupsMembersDeleteOptions.ID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPlacementGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPlacementgroupsMembersPost : Add Server to Placement Group
func (powervs *PowervsV1) PcloudPlacementgroupsMembersPost(pcloudPlacementgroupsMembersPostOptions *PcloudPlacementgroupsMembersPostOptions) (result *PlacementGroup, response *core.DetailedResponse, err error) {
	return powervs.PcloudPlacementgroupsMembersPostWithContext(context.Background(), pcloudPlacementgroupsMembersPostOptions)
}

// PcloudPlacementgroupsMembersPostWithContext is an alternate form of the PcloudPlacementgroupsMembersPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudPlacementgroupsMembersPostWithContext(ctx context.Context, pcloudPlacementgroupsMembersPostOptions *PcloudPlacementgroupsMembersPostOptions) (result *PlacementGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPlacementgroupsMembersPostOptions, "pcloudPlacementgroupsMembersPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPlacementgroupsMembersPostOptions, "pcloudPlacementgroupsMembersPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPlacementgroupsMembersPostOptions.CloudInstanceID,
		"placement_group_id": *pcloudPlacementgroupsMembersPostOptions.PlacementGroupID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/placement-groups/{placement_group_id}/members`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPlacementgroupsMembersPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPlacementgroupsMembersPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudPlacementgroupsMembersPostOptions.ID != nil {
		body["id"] = pcloudPlacementgroupsMembersPostOptions.ID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPlacementGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPodcapacityGet : List of available resources within a particular Pod
func (powervs *PowervsV1) PcloudPodcapacityGet(pcloudPodcapacityGetOptions *PcloudPodcapacityGetOptions) (result *PodCapacity, response *core.DetailedResponse, err error) {
	return powervs.PcloudPodcapacityGetWithContext(context.Background(), pcloudPodcapacityGetOptions)
}

// PcloudPodcapacityGetWithContext is an alternate form of the PcloudPodcapacityGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudPodcapacityGetWithContext(ctx context.Context, pcloudPodcapacityGetOptions *PcloudPodcapacityGetOptions) (result *PodCapacity, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPodcapacityGetOptions, "pcloudPodcapacityGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPodcapacityGetOptions, "pcloudPodcapacityGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPodcapacityGetOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pod-capacity`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPodcapacityGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPodcapacityGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPodCapacity)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudSapGetall : Get list of SAP profiles
func (powervs *PowervsV1) PcloudSapGetall(pcloudSapGetallOptions *PcloudSapGetallOptions) (result *SapProfiles, response *core.DetailedResponse, err error) {
	return powervs.PcloudSapGetallWithContext(context.Background(), pcloudSapGetallOptions)
}

// PcloudSapGetallWithContext is an alternate form of the PcloudSapGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudSapGetallWithContext(ctx context.Context, pcloudSapGetallOptions *PcloudSapGetallOptions) (result *SapProfiles, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudSapGetallOptions, "pcloudSapGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudSapGetallOptions, "pcloudSapGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudSapGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/sap`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudSapGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudSapGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSapProfiles)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudSapPost : Create a new SAP PVM Instance
func (powervs *PowervsV1) PcloudSapPost(pcloudSapPostOptions *PcloudSapPostOptions) (result []PvmInstance, response *core.DetailedResponse, err error) {
	return powervs.PcloudSapPostWithContext(context.Background(), pcloudSapPostOptions)
}

// PcloudSapPostWithContext is an alternate form of the PcloudSapPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudSapPostWithContext(ctx context.Context, pcloudSapPostOptions *PcloudSapPostOptions) (result []PvmInstance, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudSapPostOptions, "pcloudSapPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudSapPostOptions, "pcloudSapPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudSapPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/sap`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudSapPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudSapPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudSapPostOptions.ImageID != nil {
		body["imageID"] = pcloudSapPostOptions.ImageID
	}
	if pcloudSapPostOptions.Name != nil {
		body["name"] = pcloudSapPostOptions.Name
	}
	if pcloudSapPostOptions.Networks != nil {
		body["networks"] = pcloudSapPostOptions.Networks
	}
	if pcloudSapPostOptions.ProfileID != nil {
		body["profileID"] = pcloudSapPostOptions.ProfileID
	}
	if pcloudSapPostOptions.DeploymentType != nil {
		body["deploymentType"] = pcloudSapPostOptions.DeploymentType
	}
	if pcloudSapPostOptions.Instances != nil {
		body["instances"] = pcloudSapPostOptions.Instances
	}
	if pcloudSapPostOptions.PinPolicy != nil {
		body["pinPolicy"] = pcloudSapPostOptions.PinPolicy
	}
	if pcloudSapPostOptions.PlacementGroup != nil {
		body["placementGroup"] = pcloudSapPostOptions.PlacementGroup
	}
	if pcloudSapPostOptions.SshKeyName != nil {
		body["sshKeyName"] = pcloudSapPostOptions.SshKeyName
	}
	if pcloudSapPostOptions.StorageAffinity != nil {
		body["storageAffinity"] = pcloudSapPostOptions.StorageAffinity
	}
	if pcloudSapPostOptions.StoragePool != nil {
		body["storagePool"] = pcloudSapPostOptions.StoragePool
	}
	if pcloudSapPostOptions.StorageType != nil {
		body["storageType"] = pcloudSapPostOptions.StorageType
	}
	if pcloudSapPostOptions.SysType != nil {
		body["sysType"] = pcloudSapPostOptions.SysType
	}
	if pcloudSapPostOptions.UserData != nil {
		body["userData"] = pcloudSapPostOptions.UserData
	}
	if pcloudSapPostOptions.VolumeIDs != nil {
		body["volumeIDs"] = pcloudSapPostOptions.VolumeIDs
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPvmInstance)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudSapGet : Get the information on an SAP profile
func (powervs *PowervsV1) PcloudSapGet(pcloudSapGetOptions *PcloudSapGetOptions) (result *SapProfile, response *core.DetailedResponse, err error) {
	return powervs.PcloudSapGetWithContext(context.Background(), pcloudSapGetOptions)
}

// PcloudSapGetWithContext is an alternate form of the PcloudSapGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudSapGetWithContext(ctx context.Context, pcloudSapGetOptions *PcloudSapGetOptions) (result *SapProfile, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudSapGetOptions, "pcloudSapGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudSapGetOptions, "pcloudSapGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudSapGetOptions.CloudInstanceID,
		"sap_profile_id": *pcloudSapGetOptions.SapProfileID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/sap/{sap_profile_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudSapGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudSapGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSapProfile)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudSppplacementgroupsGetall : Get the list of Shared Processor Pool Placement Groups for a cloud instance
func (powervs *PowervsV1) PcloudSppplacementgroupsGetall(pcloudSppplacementgroupsGetallOptions *PcloudSppplacementgroupsGetallOptions) (result *SppPlacementGroups, response *core.DetailedResponse, err error) {
	return powervs.PcloudSppplacementgroupsGetallWithContext(context.Background(), pcloudSppplacementgroupsGetallOptions)
}

// PcloudSppplacementgroupsGetallWithContext is an alternate form of the PcloudSppplacementgroupsGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudSppplacementgroupsGetallWithContext(ctx context.Context, pcloudSppplacementgroupsGetallOptions *PcloudSppplacementgroupsGetallOptions) (result *SppPlacementGroups, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudSppplacementgroupsGetallOptions, "pcloudSppplacementgroupsGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudSppplacementgroupsGetallOptions, "pcloudSppplacementgroupsGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudSppplacementgroupsGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/spp-placement-groups`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudSppplacementgroupsGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudSppplacementgroupsGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSppPlacementGroups)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudSppplacementgroupsPost : Create a new Shared Processor Pool Placement Group
func (powervs *PowervsV1) PcloudSppplacementgroupsPost(pcloudSppplacementgroupsPostOptions *PcloudSppplacementgroupsPostOptions) (result *SppPlacementGroup, response *core.DetailedResponse, err error) {
	return powervs.PcloudSppplacementgroupsPostWithContext(context.Background(), pcloudSppplacementgroupsPostOptions)
}

// PcloudSppplacementgroupsPostWithContext is an alternate form of the PcloudSppplacementgroupsPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudSppplacementgroupsPostWithContext(ctx context.Context, pcloudSppplacementgroupsPostOptions *PcloudSppplacementgroupsPostOptions) (result *SppPlacementGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudSppplacementgroupsPostOptions, "pcloudSppplacementgroupsPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudSppplacementgroupsPostOptions, "pcloudSppplacementgroupsPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudSppplacementgroupsPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/spp-placement-groups`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudSppplacementgroupsPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudSppplacementgroupsPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudSppplacementgroupsPostOptions.Name != nil {
		body["name"] = pcloudSppplacementgroupsPostOptions.Name
	}
	if pcloudSppplacementgroupsPostOptions.Policy != nil {
		body["policy"] = pcloudSppplacementgroupsPostOptions.Policy
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSppPlacementGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudSppplacementgroupsDelete : Delete a Shared Processor Pool Placement Group from a cloud instance
func (powervs *PowervsV1) PcloudSppplacementgroupsDelete(pcloudSppplacementgroupsDeleteOptions *PcloudSppplacementgroupsDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudSppplacementgroupsDeleteWithContext(context.Background(), pcloudSppplacementgroupsDeleteOptions)
}

// PcloudSppplacementgroupsDeleteWithContext is an alternate form of the PcloudSppplacementgroupsDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudSppplacementgroupsDeleteWithContext(ctx context.Context, pcloudSppplacementgroupsDeleteOptions *PcloudSppplacementgroupsDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudSppplacementgroupsDeleteOptions, "pcloudSppplacementgroupsDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudSppplacementgroupsDeleteOptions, "pcloudSppplacementgroupsDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudSppplacementgroupsDeleteOptions.CloudInstanceID,
		"spp_placement_group_id": *pcloudSppplacementgroupsDeleteOptions.SppPlacementGroupID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/spp-placement-groups/{spp_placement_group_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudSppplacementgroupsDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudSppplacementgroupsDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudSppplacementgroupsGet : Get the detail of a Shared Processor Pool Placement Group for a cloud instance
func (powervs *PowervsV1) PcloudSppplacementgroupsGet(pcloudSppplacementgroupsGetOptions *PcloudSppplacementgroupsGetOptions) (result *SppPlacementGroup, response *core.DetailedResponse, err error) {
	return powervs.PcloudSppplacementgroupsGetWithContext(context.Background(), pcloudSppplacementgroupsGetOptions)
}

// PcloudSppplacementgroupsGetWithContext is an alternate form of the PcloudSppplacementgroupsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudSppplacementgroupsGetWithContext(ctx context.Context, pcloudSppplacementgroupsGetOptions *PcloudSppplacementgroupsGetOptions) (result *SppPlacementGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudSppplacementgroupsGetOptions, "pcloudSppplacementgroupsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudSppplacementgroupsGetOptions, "pcloudSppplacementgroupsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudSppplacementgroupsGetOptions.CloudInstanceID,
		"spp_placement_group_id": *pcloudSppplacementgroupsGetOptions.SppPlacementGroupID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/spp-placement-groups/{spp_placement_group_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudSppplacementgroupsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudSppplacementgroupsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSppPlacementGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudSppplacementgroupsMembersDelete : Delete Shared Processor Pool member from a Shared Processor Pool Placement Group
func (powervs *PowervsV1) PcloudSppplacementgroupsMembersDelete(pcloudSppplacementgroupsMembersDeleteOptions *PcloudSppplacementgroupsMembersDeleteOptions) (result *SppPlacementGroup, response *core.DetailedResponse, err error) {
	return powervs.PcloudSppplacementgroupsMembersDeleteWithContext(context.Background(), pcloudSppplacementgroupsMembersDeleteOptions)
}

// PcloudSppplacementgroupsMembersDeleteWithContext is an alternate form of the PcloudSppplacementgroupsMembersDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudSppplacementgroupsMembersDeleteWithContext(ctx context.Context, pcloudSppplacementgroupsMembersDeleteOptions *PcloudSppplacementgroupsMembersDeleteOptions) (result *SppPlacementGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudSppplacementgroupsMembersDeleteOptions, "pcloudSppplacementgroupsMembersDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudSppplacementgroupsMembersDeleteOptions, "pcloudSppplacementgroupsMembersDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudSppplacementgroupsMembersDeleteOptions.CloudInstanceID,
		"spp_placement_group_id": *pcloudSppplacementgroupsMembersDeleteOptions.SppPlacementGroupID,
		"shared_processor_pool_id": *pcloudSppplacementgroupsMembersDeleteOptions.SharedProcessorPoolID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/spp-placement-groups/{spp_placement_group_id}/members/{shared_processor_pool_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudSppplacementgroupsMembersDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudSppplacementgroupsMembersDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSppPlacementGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudSppplacementgroupsMembersPost : Add Shared Processor Pool as a member of a Shared Processor Pool Placement Group
func (powervs *PowervsV1) PcloudSppplacementgroupsMembersPost(pcloudSppplacementgroupsMembersPostOptions *PcloudSppplacementgroupsMembersPostOptions) (result *SppPlacementGroup, response *core.DetailedResponse, err error) {
	return powervs.PcloudSppplacementgroupsMembersPostWithContext(context.Background(), pcloudSppplacementgroupsMembersPostOptions)
}

// PcloudSppplacementgroupsMembersPostWithContext is an alternate form of the PcloudSppplacementgroupsMembersPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudSppplacementgroupsMembersPostWithContext(ctx context.Context, pcloudSppplacementgroupsMembersPostOptions *PcloudSppplacementgroupsMembersPostOptions) (result *SppPlacementGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudSppplacementgroupsMembersPostOptions, "pcloudSppplacementgroupsMembersPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudSppplacementgroupsMembersPostOptions, "pcloudSppplacementgroupsMembersPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudSppplacementgroupsMembersPostOptions.CloudInstanceID,
		"spp_placement_group_id": *pcloudSppplacementgroupsMembersPostOptions.SppPlacementGroupID,
		"shared_processor_pool_id": *pcloudSppplacementgroupsMembersPostOptions.SharedProcessorPoolID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/spp-placement-groups/{spp_placement_group_id}/members/{shared_processor_pool_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudSppplacementgroupsMembersPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudSppplacementgroupsMembersPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSppPlacementGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudDhcpGetall : Get all DHCP Servers information (OpenShift Internal Use Only)
func (powervs *PowervsV1) PcloudDhcpGetall(pcloudDhcpGetallOptions *PcloudDhcpGetallOptions) (result []DhcpServer, response *core.DetailedResponse, err error) {
	return powervs.PcloudDhcpGetallWithContext(context.Background(), pcloudDhcpGetallOptions)
}

// PcloudDhcpGetallWithContext is an alternate form of the PcloudDhcpGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudDhcpGetallWithContext(ctx context.Context, pcloudDhcpGetallOptions *PcloudDhcpGetallOptions) (result []DhcpServer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudDhcpGetallOptions, "pcloudDhcpGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudDhcpGetallOptions, "pcloudDhcpGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudDhcpGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/services/dhcp`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudDhcpGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudDhcpGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDhcpServer)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudDhcpPost : Create a DHCP Server (OpenShift Internal Use Only)
func (powervs *PowervsV1) PcloudDhcpPost(pcloudDhcpPostOptions *PcloudDhcpPostOptions) (result *DhcpServer, response *core.DetailedResponse, err error) {
	return powervs.PcloudDhcpPostWithContext(context.Background(), pcloudDhcpPostOptions)
}

// PcloudDhcpPostWithContext is an alternate form of the PcloudDhcpPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudDhcpPostWithContext(ctx context.Context, pcloudDhcpPostOptions *PcloudDhcpPostOptions) (result *DhcpServer, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudDhcpPostOptions, "pcloudDhcpPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudDhcpPostOptions, "pcloudDhcpPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudDhcpPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/services/dhcp`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudDhcpPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudDhcpPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudDhcpPostOptions.CIDR != nil {
		body["cidr"] = pcloudDhcpPostOptions.CIDR
	}
	if pcloudDhcpPostOptions.CloudConnectionID != nil {
		body["cloudConnectionID"] = pcloudDhcpPostOptions.CloudConnectionID
	}
	if pcloudDhcpPostOptions.DnsServer != nil {
		body["dnsServer"] = pcloudDhcpPostOptions.DnsServer
	}
	if pcloudDhcpPostOptions.Name != nil {
		body["name"] = pcloudDhcpPostOptions.Name
	}
	if pcloudDhcpPostOptions.SnatEnabled != nil {
		body["snatEnabled"] = pcloudDhcpPostOptions.SnatEnabled
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDhcpServer)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudDhcpDelete : Delete DHCP Server (OpenShift Internal Use Only)
func (powervs *PowervsV1) PcloudDhcpDelete(pcloudDhcpDeleteOptions *PcloudDhcpDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudDhcpDeleteWithContext(context.Background(), pcloudDhcpDeleteOptions)
}

// PcloudDhcpDeleteWithContext is an alternate form of the PcloudDhcpDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudDhcpDeleteWithContext(ctx context.Context, pcloudDhcpDeleteOptions *PcloudDhcpDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudDhcpDeleteOptions, "pcloudDhcpDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudDhcpDeleteOptions, "pcloudDhcpDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudDhcpDeleteOptions.CloudInstanceID,
		"dhcp_id": *pcloudDhcpDeleteOptions.DhcpID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/services/dhcp/{dhcp_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudDhcpDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudDhcpDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudDhcpGet : Get DHCP Server information (OpenShift Internal Use Only)
func (powervs *PowervsV1) PcloudDhcpGet(pcloudDhcpGetOptions *PcloudDhcpGetOptions) (result *DhcpServerDetail, response *core.DetailedResponse, err error) {
	return powervs.PcloudDhcpGetWithContext(context.Background(), pcloudDhcpGetOptions)
}

// PcloudDhcpGetWithContext is an alternate form of the PcloudDhcpGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudDhcpGetWithContext(ctx context.Context, pcloudDhcpGetOptions *PcloudDhcpGetOptions) (result *DhcpServerDetail, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudDhcpGetOptions, "pcloudDhcpGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudDhcpGetOptions, "pcloudDhcpGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudDhcpGetOptions.CloudInstanceID,
		"dhcp_id": *pcloudDhcpGetOptions.DhcpID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/services/dhcp/{dhcp_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudDhcpGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudDhcpGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalDhcpServerDetail)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudSharedprocessorpoolsGetall : Get the list of Shared Processor Pools for a cloud instance
func (powervs *PowervsV1) PcloudSharedprocessorpoolsGetall(pcloudSharedprocessorpoolsGetallOptions *PcloudSharedprocessorpoolsGetallOptions) (result *SharedProcessorPools, response *core.DetailedResponse, err error) {
	return powervs.PcloudSharedprocessorpoolsGetallWithContext(context.Background(), pcloudSharedprocessorpoolsGetallOptions)
}

// PcloudSharedprocessorpoolsGetallWithContext is an alternate form of the PcloudSharedprocessorpoolsGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudSharedprocessorpoolsGetallWithContext(ctx context.Context, pcloudSharedprocessorpoolsGetallOptions *PcloudSharedprocessorpoolsGetallOptions) (result *SharedProcessorPools, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudSharedprocessorpoolsGetallOptions, "pcloudSharedprocessorpoolsGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudSharedprocessorpoolsGetallOptions, "pcloudSharedprocessorpoolsGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudSharedprocessorpoolsGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/shared-processor-pools`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudSharedprocessorpoolsGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudSharedprocessorpoolsGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSharedProcessorPools)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudSharedprocessorpoolsPost : Create a new Shared Processor Pool
func (powervs *PowervsV1) PcloudSharedprocessorpoolsPost(pcloudSharedprocessorpoolsPostOptions *PcloudSharedprocessorpoolsPostOptions) (result *SharedProcessorPool, response *core.DetailedResponse, err error) {
	return powervs.PcloudSharedprocessorpoolsPostWithContext(context.Background(), pcloudSharedprocessorpoolsPostOptions)
}

// PcloudSharedprocessorpoolsPostWithContext is an alternate form of the PcloudSharedprocessorpoolsPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudSharedprocessorpoolsPostWithContext(ctx context.Context, pcloudSharedprocessorpoolsPostOptions *PcloudSharedprocessorpoolsPostOptions) (result *SharedProcessorPool, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudSharedprocessorpoolsPostOptions, "pcloudSharedprocessorpoolsPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudSharedprocessorpoolsPostOptions, "pcloudSharedprocessorpoolsPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudSharedprocessorpoolsPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/shared-processor-pools`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudSharedprocessorpoolsPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudSharedprocessorpoolsPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudSharedprocessorpoolsPostOptions.HostGroup != nil {
		body["hostGroup"] = pcloudSharedprocessorpoolsPostOptions.HostGroup
	}
	if pcloudSharedprocessorpoolsPostOptions.Name != nil {
		body["name"] = pcloudSharedprocessorpoolsPostOptions.Name
	}
	if pcloudSharedprocessorpoolsPostOptions.ReservedCores != nil {
		body["reservedCores"] = pcloudSharedprocessorpoolsPostOptions.ReservedCores
	}
	if pcloudSharedprocessorpoolsPostOptions.PlacementGroupID != nil {
		body["placementGroupID"] = pcloudSharedprocessorpoolsPostOptions.PlacementGroupID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSharedProcessorPool)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudSharedprocessorpoolsDelete : Delete a Shared Processor Pool from a cloud instance
func (powervs *PowervsV1) PcloudSharedprocessorpoolsDelete(pcloudSharedprocessorpoolsDeleteOptions *PcloudSharedprocessorpoolsDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudSharedprocessorpoolsDeleteWithContext(context.Background(), pcloudSharedprocessorpoolsDeleteOptions)
}

// PcloudSharedprocessorpoolsDeleteWithContext is an alternate form of the PcloudSharedprocessorpoolsDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudSharedprocessorpoolsDeleteWithContext(ctx context.Context, pcloudSharedprocessorpoolsDeleteOptions *PcloudSharedprocessorpoolsDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudSharedprocessorpoolsDeleteOptions, "pcloudSharedprocessorpoolsDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudSharedprocessorpoolsDeleteOptions, "pcloudSharedprocessorpoolsDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudSharedprocessorpoolsDeleteOptions.CloudInstanceID,
		"shared_processor_pool_id": *pcloudSharedprocessorpoolsDeleteOptions.SharedProcessorPoolID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/shared-processor-pools/{shared_processor_pool_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudSharedprocessorpoolsDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudSharedprocessorpoolsDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudSharedprocessorpoolsGet : Get the detail of a Shared Processor Pool for a cloud instance
func (powervs *PowervsV1) PcloudSharedprocessorpoolsGet(pcloudSharedprocessorpoolsGetOptions *PcloudSharedprocessorpoolsGetOptions) (result *SharedProcessorPoolDetail, response *core.DetailedResponse, err error) {
	return powervs.PcloudSharedprocessorpoolsGetWithContext(context.Background(), pcloudSharedprocessorpoolsGetOptions)
}

// PcloudSharedprocessorpoolsGetWithContext is an alternate form of the PcloudSharedprocessorpoolsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudSharedprocessorpoolsGetWithContext(ctx context.Context, pcloudSharedprocessorpoolsGetOptions *PcloudSharedprocessorpoolsGetOptions) (result *SharedProcessorPoolDetail, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudSharedprocessorpoolsGetOptions, "pcloudSharedprocessorpoolsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudSharedprocessorpoolsGetOptions, "pcloudSharedprocessorpoolsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudSharedprocessorpoolsGetOptions.CloudInstanceID,
		"shared_processor_pool_id": *pcloudSharedprocessorpoolsGetOptions.SharedProcessorPoolID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/shared-processor-pools/{shared_processor_pool_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudSharedprocessorpoolsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudSharedprocessorpoolsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSharedProcessorPoolDetail)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudSharedprocessorpoolsPut : Update a Shared Processor Pool for a cloud instance
func (powervs *PowervsV1) PcloudSharedprocessorpoolsPut(pcloudSharedprocessorpoolsPutOptions *PcloudSharedprocessorpoolsPutOptions) (result *SharedProcessorPool, response *core.DetailedResponse, err error) {
	return powervs.PcloudSharedprocessorpoolsPutWithContext(context.Background(), pcloudSharedprocessorpoolsPutOptions)
}

// PcloudSharedprocessorpoolsPutWithContext is an alternate form of the PcloudSharedprocessorpoolsPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudSharedprocessorpoolsPutWithContext(ctx context.Context, pcloudSharedprocessorpoolsPutOptions *PcloudSharedprocessorpoolsPutOptions) (result *SharedProcessorPool, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudSharedprocessorpoolsPutOptions, "pcloudSharedprocessorpoolsPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudSharedprocessorpoolsPutOptions, "pcloudSharedprocessorpoolsPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudSharedprocessorpoolsPutOptions.CloudInstanceID,
		"shared_processor_pool_id": *pcloudSharedprocessorpoolsPutOptions.SharedProcessorPoolID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/shared-processor-pools/{shared_processor_pool_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudSharedprocessorpoolsPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudSharedprocessorpoolsPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudSharedprocessorpoolsPutOptions.Name != nil {
		body["name"] = pcloudSharedprocessorpoolsPutOptions.Name
	}
	if pcloudSharedprocessorpoolsPutOptions.ReservedCores != nil {
		body["reservedCores"] = pcloudSharedprocessorpoolsPutOptions.ReservedCores
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSharedProcessorPool)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesSnapshotsGetall : List all PVM instance snapshots for this cloud instance
func (powervs *PowervsV1) PcloudCloudinstancesSnapshotsGetall(pcloudCloudinstancesSnapshotsGetallOptions *PcloudCloudinstancesSnapshotsGetallOptions) (result *Snapshots, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesSnapshotsGetallWithContext(context.Background(), pcloudCloudinstancesSnapshotsGetallOptions)
}

// PcloudCloudinstancesSnapshotsGetallWithContext is an alternate form of the PcloudCloudinstancesSnapshotsGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesSnapshotsGetallWithContext(ctx context.Context, pcloudCloudinstancesSnapshotsGetallOptions *PcloudCloudinstancesSnapshotsGetallOptions) (result *Snapshots, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesSnapshotsGetallOptions, "pcloudCloudinstancesSnapshotsGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesSnapshotsGetallOptions, "pcloudCloudinstancesSnapshotsGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesSnapshotsGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/snapshots`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesSnapshotsGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesSnapshotsGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSnapshots)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesSnapshotsDelete : Delete a PVM instance snapshot of a cloud instance
func (powervs *PowervsV1) PcloudCloudinstancesSnapshotsDelete(pcloudCloudinstancesSnapshotsDeleteOptions *PcloudCloudinstancesSnapshotsDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesSnapshotsDeleteWithContext(context.Background(), pcloudCloudinstancesSnapshotsDeleteOptions)
}

// PcloudCloudinstancesSnapshotsDeleteWithContext is an alternate form of the PcloudCloudinstancesSnapshotsDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesSnapshotsDeleteWithContext(ctx context.Context, pcloudCloudinstancesSnapshotsDeleteOptions *PcloudCloudinstancesSnapshotsDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesSnapshotsDeleteOptions, "pcloudCloudinstancesSnapshotsDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesSnapshotsDeleteOptions, "pcloudCloudinstancesSnapshotsDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesSnapshotsDeleteOptions.CloudInstanceID,
		"snapshot_id": *pcloudCloudinstancesSnapshotsDeleteOptions.SnapshotID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/snapshots/{snapshot_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesSnapshotsDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesSnapshotsDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesSnapshotsGet : Get the detail of a snapshot
func (powervs *PowervsV1) PcloudCloudinstancesSnapshotsGet(pcloudCloudinstancesSnapshotsGetOptions *PcloudCloudinstancesSnapshotsGetOptions) (result *Snapshot, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesSnapshotsGetWithContext(context.Background(), pcloudCloudinstancesSnapshotsGetOptions)
}

// PcloudCloudinstancesSnapshotsGetWithContext is an alternate form of the PcloudCloudinstancesSnapshotsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesSnapshotsGetWithContext(ctx context.Context, pcloudCloudinstancesSnapshotsGetOptions *PcloudCloudinstancesSnapshotsGetOptions) (result *Snapshot, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesSnapshotsGetOptions, "pcloudCloudinstancesSnapshotsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesSnapshotsGetOptions, "pcloudCloudinstancesSnapshotsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesSnapshotsGetOptions.CloudInstanceID,
		"snapshot_id": *pcloudCloudinstancesSnapshotsGetOptions.SnapshotID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/snapshots/{snapshot_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesSnapshotsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesSnapshotsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSnapshot)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesSnapshotsPut : Update a PVM instance snapshot
func (powervs *PowervsV1) PcloudCloudinstancesSnapshotsPut(pcloudCloudinstancesSnapshotsPutOptions *PcloudCloudinstancesSnapshotsPutOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesSnapshotsPutWithContext(context.Background(), pcloudCloudinstancesSnapshotsPutOptions)
}

// PcloudCloudinstancesSnapshotsPutWithContext is an alternate form of the PcloudCloudinstancesSnapshotsPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesSnapshotsPutWithContext(ctx context.Context, pcloudCloudinstancesSnapshotsPutOptions *PcloudCloudinstancesSnapshotsPutOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesSnapshotsPutOptions, "pcloudCloudinstancesSnapshotsPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesSnapshotsPutOptions, "pcloudCloudinstancesSnapshotsPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesSnapshotsPutOptions.CloudInstanceID,
		"snapshot_id": *pcloudCloudinstancesSnapshotsPutOptions.SnapshotID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/snapshots/{snapshot_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesSnapshotsPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesSnapshotsPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudCloudinstancesSnapshotsPutOptions.Description != nil {
		body["description"] = pcloudCloudinstancesSnapshotsPutOptions.Description
	}
	if pcloudCloudinstancesSnapshotsPutOptions.Name != nil {
		body["name"] = pcloudCloudinstancesSnapshotsPutOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudStoragecapacityPoolsGetall : Storage capacity for all available storage pools in a region
func (powervs *PowervsV1) PcloudStoragecapacityPoolsGetall(pcloudStoragecapacityPoolsGetallOptions *PcloudStoragecapacityPoolsGetallOptions) (result *StoragePoolsCapacity, response *core.DetailedResponse, err error) {
	return powervs.PcloudStoragecapacityPoolsGetallWithContext(context.Background(), pcloudStoragecapacityPoolsGetallOptions)
}

// PcloudStoragecapacityPoolsGetallWithContext is an alternate form of the PcloudStoragecapacityPoolsGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudStoragecapacityPoolsGetallWithContext(ctx context.Context, pcloudStoragecapacityPoolsGetallOptions *PcloudStoragecapacityPoolsGetallOptions) (result *StoragePoolsCapacity, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudStoragecapacityPoolsGetallOptions, "pcloudStoragecapacityPoolsGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudStoragecapacityPoolsGetallOptions, "pcloudStoragecapacityPoolsGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudStoragecapacityPoolsGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/storage-capacity/storage-pools`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudStoragecapacityPoolsGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudStoragecapacityPoolsGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStoragePoolsCapacity)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudStoragecapacityPoolsGet : Storage capacity for a storage pool in a region
func (powervs *PowervsV1) PcloudStoragecapacityPoolsGet(pcloudStoragecapacityPoolsGetOptions *PcloudStoragecapacityPoolsGetOptions) (result *StoragePoolCapacity, response *core.DetailedResponse, err error) {
	return powervs.PcloudStoragecapacityPoolsGetWithContext(context.Background(), pcloudStoragecapacityPoolsGetOptions)
}

// PcloudStoragecapacityPoolsGetWithContext is an alternate form of the PcloudStoragecapacityPoolsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudStoragecapacityPoolsGetWithContext(ctx context.Context, pcloudStoragecapacityPoolsGetOptions *PcloudStoragecapacityPoolsGetOptions) (result *StoragePoolCapacity, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudStoragecapacityPoolsGetOptions, "pcloudStoragecapacityPoolsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudStoragecapacityPoolsGetOptions, "pcloudStoragecapacityPoolsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudStoragecapacityPoolsGetOptions.CloudInstanceID,
		"storage_pool_name": *pcloudStoragecapacityPoolsGetOptions.StoragePoolName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/storage-capacity/storage-pools/{storage_pool_name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudStoragecapacityPoolsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudStoragecapacityPoolsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStoragePoolCapacity)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudStoragecapacityTypesGetall : Storage capacity for all available storage types in a region
func (powervs *PowervsV1) PcloudStoragecapacityTypesGetall(pcloudStoragecapacityTypesGetallOptions *PcloudStoragecapacityTypesGetallOptions) (result *StorageTypesCapacity, response *core.DetailedResponse, err error) {
	return powervs.PcloudStoragecapacityTypesGetallWithContext(context.Background(), pcloudStoragecapacityTypesGetallOptions)
}

// PcloudStoragecapacityTypesGetallWithContext is an alternate form of the PcloudStoragecapacityTypesGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudStoragecapacityTypesGetallWithContext(ctx context.Context, pcloudStoragecapacityTypesGetallOptions *PcloudStoragecapacityTypesGetallOptions) (result *StorageTypesCapacity, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudStoragecapacityTypesGetallOptions, "pcloudStoragecapacityTypesGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudStoragecapacityTypesGetallOptions, "pcloudStoragecapacityTypesGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudStoragecapacityTypesGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/storage-capacity/storage-types`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudStoragecapacityTypesGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudStoragecapacityTypesGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageTypesCapacity)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudStoragecapacityTypesGet : Storage capacity for a storage type in a region
func (powervs *PowervsV1) PcloudStoragecapacityTypesGet(pcloudStoragecapacityTypesGetOptions *PcloudStoragecapacityTypesGetOptions) (result *StorageTypeCapacity, response *core.DetailedResponse, err error) {
	return powervs.PcloudStoragecapacityTypesGetWithContext(context.Background(), pcloudStoragecapacityTypesGetOptions)
}

// PcloudStoragecapacityTypesGetWithContext is an alternate form of the PcloudStoragecapacityTypesGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudStoragecapacityTypesGetWithContext(ctx context.Context, pcloudStoragecapacityTypesGetOptions *PcloudStoragecapacityTypesGetOptions) (result *StorageTypeCapacity, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudStoragecapacityTypesGetOptions, "pcloudStoragecapacityTypesGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudStoragecapacityTypesGetOptions, "pcloudStoragecapacityTypesGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudStoragecapacityTypesGetOptions.CloudInstanceID,
		"storage_type_name": *pcloudStoragecapacityTypesGetOptions.StorageTypeName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/storage-capacity/storage-types/{storage_type_name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudStoragecapacityTypesGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudStoragecapacityTypesGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageTypeCapacity)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesStoragetiersGetall : List all supported storage tiers for this cloud instance
func (powervs *PowervsV1) PcloudCloudinstancesStoragetiersGetall(pcloudCloudinstancesStoragetiersGetallOptions *PcloudCloudinstancesStoragetiersGetallOptions) (result []StorageTier, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesStoragetiersGetallWithContext(context.Background(), pcloudCloudinstancesStoragetiersGetallOptions)
}

// PcloudCloudinstancesStoragetiersGetallWithContext is an alternate form of the PcloudCloudinstancesStoragetiersGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesStoragetiersGetallWithContext(ctx context.Context, pcloudCloudinstancesStoragetiersGetallOptions *PcloudCloudinstancesStoragetiersGetallOptions) (result []StorageTier, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesStoragetiersGetallOptions, "pcloudCloudinstancesStoragetiersGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesStoragetiersGetallOptions, "pcloudCloudinstancesStoragetiersGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesStoragetiersGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/storage-tiers`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesStoragetiersGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesStoragetiersGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageTier)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudSystempoolsGet : List of available system pools within a particular DataCenter
func (powervs *PowervsV1) PcloudSystempoolsGet(pcloudSystempoolsGetOptions *PcloudSystempoolsGetOptions) (result map[string]SystemPool, response *core.DetailedResponse, err error) {
	return powervs.PcloudSystempoolsGetWithContext(context.Background(), pcloudSystempoolsGetOptions)
}

// PcloudSystempoolsGetWithContext is an alternate form of the PcloudSystempoolsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudSystempoolsGetWithContext(ctx context.Context, pcloudSystempoolsGetOptions *PcloudSystempoolsGetOptions) (result map[string]SystemPool, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudSystempoolsGetOptions, "pcloudSystempoolsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudSystempoolsGetOptions, "pcloudSystempoolsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudSystempoolsGetOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/system-pools`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudSystempoolsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudSystempoolsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSystemPool)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudTasksDelete : Delete a Task
func (powervs *PowervsV1) PcloudTasksDelete(pcloudTasksDeleteOptions *PcloudTasksDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudTasksDeleteWithContext(context.Background(), pcloudTasksDeleteOptions)
}

// PcloudTasksDeleteWithContext is an alternate form of the PcloudTasksDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudTasksDeleteWithContext(ctx context.Context, pcloudTasksDeleteOptions *PcloudTasksDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudTasksDeleteOptions, "pcloudTasksDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudTasksDeleteOptions, "pcloudTasksDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"task_id": *pcloudTasksDeleteOptions.TaskID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/tasks/{task_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudTasksDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudTasksDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudTasksGet : Get a Task
func (powervs *PowervsV1) PcloudTasksGet(pcloudTasksGetOptions *PcloudTasksGetOptions) (result *Task, response *core.DetailedResponse, err error) {
	return powervs.PcloudTasksGetWithContext(context.Background(), pcloudTasksGetOptions)
}

// PcloudTasksGetWithContext is an alternate form of the PcloudTasksGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudTasksGetWithContext(ctx context.Context, pcloudTasksGetOptions *PcloudTasksGetOptions) (result *Task, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudTasksGetOptions, "pcloudTasksGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudTasksGetOptions, "pcloudTasksGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"task_id": *pcloudTasksGetOptions.TaskID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/tasks/{task_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudTasksGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudTasksGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTask)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudTenantsGet : Get a Tenant's current state/information
func (powervs *PowervsV1) PcloudTenantsGet(pcloudTenantsGetOptions *PcloudTenantsGetOptions) (result *Tenant, response *core.DetailedResponse, err error) {
	return powervs.PcloudTenantsGetWithContext(context.Background(), pcloudTenantsGetOptions)
}

// PcloudTenantsGetWithContext is an alternate form of the PcloudTenantsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudTenantsGetWithContext(ctx context.Context, pcloudTenantsGetOptions *PcloudTenantsGetOptions) (result *Tenant, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudTenantsGetOptions, "pcloudTenantsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudTenantsGetOptions, "pcloudTenantsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"tenant_id": *pcloudTenantsGetOptions.TenantID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/tenants/{tenant_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudTenantsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudTenantsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTenant)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudTenantsPut : Update a tenant
func (powervs *PowervsV1) PcloudTenantsPut(pcloudTenantsPutOptions *PcloudTenantsPutOptions) (result *Tenant, response *core.DetailedResponse, err error) {
	return powervs.PcloudTenantsPutWithContext(context.Background(), pcloudTenantsPutOptions)
}

// PcloudTenantsPutWithContext is an alternate form of the PcloudTenantsPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudTenantsPutWithContext(ctx context.Context, pcloudTenantsPutOptions *PcloudTenantsPutOptions) (result *Tenant, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudTenantsPutOptions, "pcloudTenantsPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudTenantsPutOptions, "pcloudTenantsPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"tenant_id": *pcloudTenantsPutOptions.TenantID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/tenants/{tenant_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudTenantsPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudTenantsPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudTenantsPutOptions.Icn != nil {
		body["icn"] = pcloudTenantsPutOptions.Icn
	}
	if pcloudTenantsPutOptions.PeeringNetworks != nil {
		body["peeringNetworks"] = pcloudTenantsPutOptions.PeeringNetworks
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalTenant)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudTenantsSshkeysGetall : List a Tenant's SSH Keys
func (powervs *PowervsV1) PcloudTenantsSshkeysGetall(pcloudTenantsSshkeysGetallOptions *PcloudTenantsSshkeysGetallOptions) (result *SshKeys, response *core.DetailedResponse, err error) {
	return powervs.PcloudTenantsSshkeysGetallWithContext(context.Background(), pcloudTenantsSshkeysGetallOptions)
}

// PcloudTenantsSshkeysGetallWithContext is an alternate form of the PcloudTenantsSshkeysGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudTenantsSshkeysGetallWithContext(ctx context.Context, pcloudTenantsSshkeysGetallOptions *PcloudTenantsSshkeysGetallOptions) (result *SshKeys, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudTenantsSshkeysGetallOptions, "pcloudTenantsSshkeysGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudTenantsSshkeysGetallOptions, "pcloudTenantsSshkeysGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"tenant_id": *pcloudTenantsSshkeysGetallOptions.TenantID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/tenants/{tenant_id}/sshkeys`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudTenantsSshkeysGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudTenantsSshkeysGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSshKeys)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudTenantsSshkeysPost : Add a new SSH key to the Tenant
func (powervs *PowervsV1) PcloudTenantsSshkeysPost(pcloudTenantsSshkeysPostOptions *PcloudTenantsSshkeysPostOptions) (result *SshKey, response *core.DetailedResponse, err error) {
	return powervs.PcloudTenantsSshkeysPostWithContext(context.Background(), pcloudTenantsSshkeysPostOptions)
}

// PcloudTenantsSshkeysPostWithContext is an alternate form of the PcloudTenantsSshkeysPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudTenantsSshkeysPostWithContext(ctx context.Context, pcloudTenantsSshkeysPostOptions *PcloudTenantsSshkeysPostOptions) (result *SshKey, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudTenantsSshkeysPostOptions, "pcloudTenantsSshkeysPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudTenantsSshkeysPostOptions, "pcloudTenantsSshkeysPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"tenant_id": *pcloudTenantsSshkeysPostOptions.TenantID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/tenants/{tenant_id}/sshkeys`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudTenantsSshkeysPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudTenantsSshkeysPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudTenantsSshkeysPostOptions.Name != nil {
		body["name"] = pcloudTenantsSshkeysPostOptions.Name
	}
	if pcloudTenantsSshkeysPostOptions.SshKey != nil {
		body["sshKey"] = pcloudTenantsSshkeysPostOptions.SshKey
	}
	if pcloudTenantsSshkeysPostOptions.CreationDate != nil {
		body["creationDate"] = pcloudTenantsSshkeysPostOptions.CreationDate
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSshKey)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudTenantsSshkeysDelete : Delete a Tenant's SSH key
func (powervs *PowervsV1) PcloudTenantsSshkeysDelete(pcloudTenantsSshkeysDeleteOptions *PcloudTenantsSshkeysDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudTenantsSshkeysDeleteWithContext(context.Background(), pcloudTenantsSshkeysDeleteOptions)
}

// PcloudTenantsSshkeysDeleteWithContext is an alternate form of the PcloudTenantsSshkeysDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudTenantsSshkeysDeleteWithContext(ctx context.Context, pcloudTenantsSshkeysDeleteOptions *PcloudTenantsSshkeysDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudTenantsSshkeysDeleteOptions, "pcloudTenantsSshkeysDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudTenantsSshkeysDeleteOptions, "pcloudTenantsSshkeysDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"tenant_id": *pcloudTenantsSshkeysDeleteOptions.TenantID,
		"sshkey_name": *pcloudTenantsSshkeysDeleteOptions.SshkeyName,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/tenants/{tenant_id}/sshkeys/{sshkey_name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudTenantsSshkeysDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudTenantsSshkeysDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudTenantsSshkeysGet : Get a Tenant's SSH Key by name
func (powervs *PowervsV1) PcloudTenantsSshkeysGet(pcloudTenantsSshkeysGetOptions *PcloudTenantsSshkeysGetOptions) (result *SshKey, response *core.DetailedResponse, err error) {
	return powervs.PcloudTenantsSshkeysGetWithContext(context.Background(), pcloudTenantsSshkeysGetOptions)
}

// PcloudTenantsSshkeysGetWithContext is an alternate form of the PcloudTenantsSshkeysGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudTenantsSshkeysGetWithContext(ctx context.Context, pcloudTenantsSshkeysGetOptions *PcloudTenantsSshkeysGetOptions) (result *SshKey, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudTenantsSshkeysGetOptions, "pcloudTenantsSshkeysGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudTenantsSshkeysGetOptions, "pcloudTenantsSshkeysGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"tenant_id": *pcloudTenantsSshkeysGetOptions.TenantID,
		"sshkey_name": *pcloudTenantsSshkeysGetOptions.SshkeyName,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/tenants/{tenant_id}/sshkeys/{sshkey_name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudTenantsSshkeysGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudTenantsSshkeysGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSshKey)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudTenantsSshkeysPut : Update an SSH Key
func (powervs *PowervsV1) PcloudTenantsSshkeysPut(pcloudTenantsSshkeysPutOptions *PcloudTenantsSshkeysPutOptions) (result *SshKey, response *core.DetailedResponse, err error) {
	return powervs.PcloudTenantsSshkeysPutWithContext(context.Background(), pcloudTenantsSshkeysPutOptions)
}

// PcloudTenantsSshkeysPutWithContext is an alternate form of the PcloudTenantsSshkeysPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudTenantsSshkeysPutWithContext(ctx context.Context, pcloudTenantsSshkeysPutOptions *PcloudTenantsSshkeysPutOptions) (result *SshKey, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudTenantsSshkeysPutOptions, "pcloudTenantsSshkeysPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudTenantsSshkeysPutOptions, "pcloudTenantsSshkeysPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"tenant_id": *pcloudTenantsSshkeysPutOptions.TenantID,
		"sshkey_name": *pcloudTenantsSshkeysPutOptions.SshkeyName,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/tenants/{tenant_id}/sshkeys/{sshkey_name}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudTenantsSshkeysPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudTenantsSshkeysPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudTenantsSshkeysPutOptions.Name != nil {
		body["name"] = pcloudTenantsSshkeysPutOptions.Name
	}
	if pcloudTenantsSshkeysPutOptions.SshKey != nil {
		body["sshKey"] = pcloudTenantsSshkeysPutOptions.SshKey
	}
	if pcloudTenantsSshkeysPutOptions.CreationDate != nil {
		body["creationDate"] = pcloudTenantsSshkeysPutOptions.CreationDate
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalSshKey)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVpnconnectionsGetall : Get all VPN Connections
// Get all VPN Connections.
func (powervs *PowervsV1) PcloudVpnconnectionsGetall(pcloudVpnconnectionsGetallOptions *PcloudVpnconnectionsGetallOptions) (result *VPNConnections, response *core.DetailedResponse, err error) {
	return powervs.PcloudVpnconnectionsGetallWithContext(context.Background(), pcloudVpnconnectionsGetallOptions)
}

// PcloudVpnconnectionsGetallWithContext is an alternate form of the PcloudVpnconnectionsGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudVpnconnectionsGetallWithContext(ctx context.Context, pcloudVpnconnectionsGetallOptions *PcloudVpnconnectionsGetallOptions) (result *VPNConnections, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVpnconnectionsGetallOptions, "pcloudVpnconnectionsGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVpnconnectionsGetallOptions, "pcloudVpnconnectionsGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVpnconnectionsGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/vpn-connections`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVpnconnectionsGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVpnconnectionsGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNConnections)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVpnconnectionsPost : Create VPN Connection
// Create a new VPN Connection.
func (powervs *PowervsV1) PcloudVpnconnectionsPost(pcloudVpnconnectionsPostOptions *PcloudVpnconnectionsPostOptions) (result *VPNConnectionCreateResponse, response *core.DetailedResponse, err error) {
	return powervs.PcloudVpnconnectionsPostWithContext(context.Background(), pcloudVpnconnectionsPostOptions)
}

// PcloudVpnconnectionsPostWithContext is an alternate form of the PcloudVpnconnectionsPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudVpnconnectionsPostWithContext(ctx context.Context, pcloudVpnconnectionsPostOptions *PcloudVpnconnectionsPostOptions) (result *VPNConnectionCreateResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVpnconnectionsPostOptions, "pcloudVpnconnectionsPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVpnconnectionsPostOptions, "pcloudVpnconnectionsPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVpnconnectionsPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/vpn-connections`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVpnconnectionsPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVpnconnectionsPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudVpnconnectionsPostOptions.IkePolicy != nil {
		body["ikePolicy"] = pcloudVpnconnectionsPostOptions.IkePolicy
	}
	if pcloudVpnconnectionsPostOptions.IPSecPolicy != nil {
		body["ipSecPolicy"] = pcloudVpnconnectionsPostOptions.IPSecPolicy
	}
	if pcloudVpnconnectionsPostOptions.Mode != nil {
		body["mode"] = pcloudVpnconnectionsPostOptions.Mode
	}
	if pcloudVpnconnectionsPostOptions.Name != nil {
		body["name"] = pcloudVpnconnectionsPostOptions.Name
	}
	if pcloudVpnconnectionsPostOptions.Networks != nil {
		body["networks"] = pcloudVpnconnectionsPostOptions.Networks
	}
	if pcloudVpnconnectionsPostOptions.PeerGatewayAddress != nil {
		body["peerGatewayAddress"] = pcloudVpnconnectionsPostOptions.PeerGatewayAddress
	}
	if pcloudVpnconnectionsPostOptions.PeerSubnets != nil {
		body["peerSubnets"] = pcloudVpnconnectionsPostOptions.PeerSubnets
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNConnectionCreateResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVpnconnectionsDelete : Delete VPN Connection
// Delete VPN Connection (by its identifier).
func (powervs *PowervsV1) PcloudVpnconnectionsDelete(pcloudVpnconnectionsDeleteOptions *PcloudVpnconnectionsDeleteOptions) (result *JobReference, response *core.DetailedResponse, err error) {
	return powervs.PcloudVpnconnectionsDeleteWithContext(context.Background(), pcloudVpnconnectionsDeleteOptions)
}

// PcloudVpnconnectionsDeleteWithContext is an alternate form of the PcloudVpnconnectionsDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudVpnconnectionsDeleteWithContext(ctx context.Context, pcloudVpnconnectionsDeleteOptions *PcloudVpnconnectionsDeleteOptions) (result *JobReference, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVpnconnectionsDeleteOptions, "pcloudVpnconnectionsDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVpnconnectionsDeleteOptions, "pcloudVpnconnectionsDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVpnconnectionsDeleteOptions.CloudInstanceID,
		"vpn_connection_id": *pcloudVpnconnectionsDeleteOptions.VPNConnectionID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/vpn-connections/{vpn_connection_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVpnconnectionsDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVpnconnectionsDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalJobReference)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVpnconnectionsGet : Get VPN Connection
// Get a VPN Connection.
func (powervs *PowervsV1) PcloudVpnconnectionsGet(pcloudVpnconnectionsGetOptions *PcloudVpnconnectionsGetOptions) (result *VPNConnection, response *core.DetailedResponse, err error) {
	return powervs.PcloudVpnconnectionsGetWithContext(context.Background(), pcloudVpnconnectionsGetOptions)
}

// PcloudVpnconnectionsGetWithContext is an alternate form of the PcloudVpnconnectionsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudVpnconnectionsGetWithContext(ctx context.Context, pcloudVpnconnectionsGetOptions *PcloudVpnconnectionsGetOptions) (result *VPNConnection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVpnconnectionsGetOptions, "pcloudVpnconnectionsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVpnconnectionsGetOptions, "pcloudVpnconnectionsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVpnconnectionsGetOptions.CloudInstanceID,
		"vpn_connection_id": *pcloudVpnconnectionsGetOptions.VPNConnectionID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/vpn-connections/{vpn_connection_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVpnconnectionsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVpnconnectionsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNConnection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVpnconnectionsPut : Update VPN Connection
// update a VPN Connection (by its identifier).
func (powervs *PowervsV1) PcloudVpnconnectionsPut(pcloudVpnconnectionsPutOptions *PcloudVpnconnectionsPutOptions) (result *VPNConnection, response *core.DetailedResponse, err error) {
	return powervs.PcloudVpnconnectionsPutWithContext(context.Background(), pcloudVpnconnectionsPutOptions)
}

// PcloudVpnconnectionsPutWithContext is an alternate form of the PcloudVpnconnectionsPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudVpnconnectionsPutWithContext(ctx context.Context, pcloudVpnconnectionsPutOptions *PcloudVpnconnectionsPutOptions) (result *VPNConnection, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVpnconnectionsPutOptions, "pcloudVpnconnectionsPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVpnconnectionsPutOptions, "pcloudVpnconnectionsPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVpnconnectionsPutOptions.CloudInstanceID,
		"vpn_connection_id": *pcloudVpnconnectionsPutOptions.VPNConnectionID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/vpn-connections/{vpn_connection_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVpnconnectionsPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVpnconnectionsPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	_, err = builder.SetBodyContentJSON(pcloudVpnconnectionsPutOptions.Body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVPNConnection)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVpnconnectionsNetworksDelete : Detach network
// Detach network from a specific VPN Connection.
func (powervs *PowervsV1) PcloudVpnconnectionsNetworksDelete(pcloudVpnconnectionsNetworksDeleteOptions *PcloudVpnconnectionsNetworksDeleteOptions) (result *JobReference, response *core.DetailedResponse, err error) {
	return powervs.PcloudVpnconnectionsNetworksDeleteWithContext(context.Background(), pcloudVpnconnectionsNetworksDeleteOptions)
}

// PcloudVpnconnectionsNetworksDeleteWithContext is an alternate form of the PcloudVpnconnectionsNetworksDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudVpnconnectionsNetworksDeleteWithContext(ctx context.Context, pcloudVpnconnectionsNetworksDeleteOptions *PcloudVpnconnectionsNetworksDeleteOptions) (result *JobReference, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVpnconnectionsNetworksDeleteOptions, "pcloudVpnconnectionsNetworksDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVpnconnectionsNetworksDeleteOptions, "pcloudVpnconnectionsNetworksDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVpnconnectionsNetworksDeleteOptions.CloudInstanceID,
		"vpn_connection_id": *pcloudVpnconnectionsNetworksDeleteOptions.VPNConnectionID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/vpn-connections/{vpn_connection_id}/networks`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVpnconnectionsNetworksDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVpnconnectionsNetworksDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudVpnconnectionsNetworksDeleteOptions.NetworkID != nil {
		body["networkID"] = pcloudVpnconnectionsNetworksDeleteOptions.NetworkID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalJobReference)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVpnconnectionsNetworksGet : Get attached networks
// Get a list of network IDs attached to a VPN Connection.
func (powervs *PowervsV1) PcloudVpnconnectionsNetworksGet(pcloudVpnconnectionsNetworksGetOptions *PcloudVpnconnectionsNetworksGetOptions) (result *NetworkIDs, response *core.DetailedResponse, err error) {
	return powervs.PcloudVpnconnectionsNetworksGetWithContext(context.Background(), pcloudVpnconnectionsNetworksGetOptions)
}

// PcloudVpnconnectionsNetworksGetWithContext is an alternate form of the PcloudVpnconnectionsNetworksGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudVpnconnectionsNetworksGetWithContext(ctx context.Context, pcloudVpnconnectionsNetworksGetOptions *PcloudVpnconnectionsNetworksGetOptions) (result *NetworkIDs, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVpnconnectionsNetworksGetOptions, "pcloudVpnconnectionsNetworksGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVpnconnectionsNetworksGetOptions, "pcloudVpnconnectionsNetworksGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVpnconnectionsNetworksGetOptions.CloudInstanceID,
		"vpn_connection_id": *pcloudVpnconnectionsNetworksGetOptions.VPNConnectionID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/vpn-connections/{vpn_connection_id}/networks`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVpnconnectionsNetworksGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVpnconnectionsNetworksGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalNetworkIDs)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVpnconnectionsNetworksPut : Attach network
// Attach a network to a VPN Connection.
func (powervs *PowervsV1) PcloudVpnconnectionsNetworksPut(pcloudVpnconnectionsNetworksPutOptions *PcloudVpnconnectionsNetworksPutOptions) (result *JobReference, response *core.DetailedResponse, err error) {
	return powervs.PcloudVpnconnectionsNetworksPutWithContext(context.Background(), pcloudVpnconnectionsNetworksPutOptions)
}

// PcloudVpnconnectionsNetworksPutWithContext is an alternate form of the PcloudVpnconnectionsNetworksPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudVpnconnectionsNetworksPutWithContext(ctx context.Context, pcloudVpnconnectionsNetworksPutOptions *PcloudVpnconnectionsNetworksPutOptions) (result *JobReference, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVpnconnectionsNetworksPutOptions, "pcloudVpnconnectionsNetworksPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVpnconnectionsNetworksPutOptions, "pcloudVpnconnectionsNetworksPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVpnconnectionsNetworksPutOptions.CloudInstanceID,
		"vpn_connection_id": *pcloudVpnconnectionsNetworksPutOptions.VPNConnectionID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/vpn-connections/{vpn_connection_id}/networks`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVpnconnectionsNetworksPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVpnconnectionsNetworksPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudVpnconnectionsNetworksPutOptions.NetworkID != nil {
		body["networkID"] = pcloudVpnconnectionsNetworksPutOptions.NetworkID
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalJobReference)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVpnconnectionsPeersubnetsDelete : Detach Peer Subnet
// Detach peer subnet from a VPN Connection.
func (powervs *PowervsV1) PcloudVpnconnectionsPeersubnetsDelete(pcloudVpnconnectionsPeersubnetsDeleteOptions *PcloudVpnconnectionsPeersubnetsDeleteOptions) (result *PeerSubnets, response *core.DetailedResponse, err error) {
	return powervs.PcloudVpnconnectionsPeersubnetsDeleteWithContext(context.Background(), pcloudVpnconnectionsPeersubnetsDeleteOptions)
}

// PcloudVpnconnectionsPeersubnetsDeleteWithContext is an alternate form of the PcloudVpnconnectionsPeersubnetsDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudVpnconnectionsPeersubnetsDeleteWithContext(ctx context.Context, pcloudVpnconnectionsPeersubnetsDeleteOptions *PcloudVpnconnectionsPeersubnetsDeleteOptions) (result *PeerSubnets, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVpnconnectionsPeersubnetsDeleteOptions, "pcloudVpnconnectionsPeersubnetsDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVpnconnectionsPeersubnetsDeleteOptions, "pcloudVpnconnectionsPeersubnetsDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVpnconnectionsPeersubnetsDeleteOptions.CloudInstanceID,
		"vpn_connection_id": *pcloudVpnconnectionsPeersubnetsDeleteOptions.VPNConnectionID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/vpn-connections/{vpn_connection_id}/peer-subnets`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVpnconnectionsPeersubnetsDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVpnconnectionsPeersubnetsDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudVpnconnectionsPeersubnetsDeleteOptions.CIDR != nil {
		body["cidr"] = pcloudVpnconnectionsPeersubnetsDeleteOptions.CIDR
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPeerSubnets)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVpnconnectionsPeersubnetsGet : Get Peer Subnets
// Get a list of peer subnets attached to a specific VPN Connection.
func (powervs *PowervsV1) PcloudVpnconnectionsPeersubnetsGet(pcloudVpnconnectionsPeersubnetsGetOptions *PcloudVpnconnectionsPeersubnetsGetOptions) (result *PeerSubnets, response *core.DetailedResponse, err error) {
	return powervs.PcloudVpnconnectionsPeersubnetsGetWithContext(context.Background(), pcloudVpnconnectionsPeersubnetsGetOptions)
}

// PcloudVpnconnectionsPeersubnetsGetWithContext is an alternate form of the PcloudVpnconnectionsPeersubnetsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudVpnconnectionsPeersubnetsGetWithContext(ctx context.Context, pcloudVpnconnectionsPeersubnetsGetOptions *PcloudVpnconnectionsPeersubnetsGetOptions) (result *PeerSubnets, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVpnconnectionsPeersubnetsGetOptions, "pcloudVpnconnectionsPeersubnetsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVpnconnectionsPeersubnetsGetOptions, "pcloudVpnconnectionsPeersubnetsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVpnconnectionsPeersubnetsGetOptions.CloudInstanceID,
		"vpn_connection_id": *pcloudVpnconnectionsPeersubnetsGetOptions.VPNConnectionID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/vpn-connections/{vpn_connection_id}/peer-subnets`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVpnconnectionsPeersubnetsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVpnconnectionsPeersubnetsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPeerSubnets)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVpnconnectionsPeersubnetsPut : Attach Peer Subnet
// Attach peer subnet to a VPN Connection.
func (powervs *PowervsV1) PcloudVpnconnectionsPeersubnetsPut(pcloudVpnconnectionsPeersubnetsPutOptions *PcloudVpnconnectionsPeersubnetsPutOptions) (result *PeerSubnets, response *core.DetailedResponse, err error) {
	return powervs.PcloudVpnconnectionsPeersubnetsPutWithContext(context.Background(), pcloudVpnconnectionsPeersubnetsPutOptions)
}

// PcloudVpnconnectionsPeersubnetsPutWithContext is an alternate form of the PcloudVpnconnectionsPeersubnetsPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudVpnconnectionsPeersubnetsPutWithContext(ctx context.Context, pcloudVpnconnectionsPeersubnetsPutOptions *PcloudVpnconnectionsPeersubnetsPutOptions) (result *PeerSubnets, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVpnconnectionsPeersubnetsPutOptions, "pcloudVpnconnectionsPeersubnetsPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVpnconnectionsPeersubnetsPutOptions, "pcloudVpnconnectionsPeersubnetsPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVpnconnectionsPeersubnetsPutOptions.CloudInstanceID,
		"vpn_connection_id": *pcloudVpnconnectionsPeersubnetsPutOptions.VPNConnectionID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/vpn-connections/{vpn_connection_id}/peer-subnets`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVpnconnectionsPeersubnetsPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVpnconnectionsPeersubnetsPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudVpnconnectionsPeersubnetsPutOptions.CIDR != nil {
		body["cidr"] = pcloudVpnconnectionsPeersubnetsPutOptions.CIDR
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalPeerSubnets)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudIkepoliciesGetall : Get all IKE Policies
// List all IKE Policies with all attributes.
func (powervs *PowervsV1) PcloudIkepoliciesGetall(pcloudIkepoliciesGetallOptions *PcloudIkepoliciesGetallOptions) (result *IkePolicies, response *core.DetailedResponse, err error) {
	return powervs.PcloudIkepoliciesGetallWithContext(context.Background(), pcloudIkepoliciesGetallOptions)
}

// PcloudIkepoliciesGetallWithContext is an alternate form of the PcloudIkepoliciesGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudIkepoliciesGetallWithContext(ctx context.Context, pcloudIkepoliciesGetallOptions *PcloudIkepoliciesGetallOptions) (result *IkePolicies, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudIkepoliciesGetallOptions, "pcloudIkepoliciesGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudIkepoliciesGetallOptions, "pcloudIkepoliciesGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudIkepoliciesGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/ike-policies`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudIkepoliciesGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudIkepoliciesGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIkePolicies)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudIkepoliciesPost : Add IKE Policy
// Add a new IKE Policy.
func (powervs *PowervsV1) PcloudIkepoliciesPost(pcloudIkepoliciesPostOptions *PcloudIkepoliciesPostOptions) (result *IkePolicy, response *core.DetailedResponse, err error) {
	return powervs.PcloudIkepoliciesPostWithContext(context.Background(), pcloudIkepoliciesPostOptions)
}

// PcloudIkepoliciesPostWithContext is an alternate form of the PcloudIkepoliciesPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudIkepoliciesPostWithContext(ctx context.Context, pcloudIkepoliciesPostOptions *PcloudIkepoliciesPostOptions) (result *IkePolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudIkepoliciesPostOptions, "pcloudIkepoliciesPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudIkepoliciesPostOptions, "pcloudIkepoliciesPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudIkepoliciesPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/ike-policies`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudIkepoliciesPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudIkepoliciesPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudIkepoliciesPostOptions.DhGroup != nil {
		body["dhGroup"] = pcloudIkepoliciesPostOptions.DhGroup
	}
	if pcloudIkepoliciesPostOptions.Encryption != nil {
		body["encryption"] = pcloudIkepoliciesPostOptions.Encryption
	}
	if pcloudIkepoliciesPostOptions.KeyLifetime != nil {
		body["keyLifetime"] = pcloudIkepoliciesPostOptions.KeyLifetime
	}
	if pcloudIkepoliciesPostOptions.Name != nil {
		body["name"] = pcloudIkepoliciesPostOptions.Name
	}
	if pcloudIkepoliciesPostOptions.PresharedKey != nil {
		body["presharedKey"] = pcloudIkepoliciesPostOptions.PresharedKey
	}
	if pcloudIkepoliciesPostOptions.Version != nil {
		body["version"] = pcloudIkepoliciesPostOptions.Version
	}
	if pcloudIkepoliciesPostOptions.Authentication != nil {
		body["authentication"] = pcloudIkepoliciesPostOptions.Authentication
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIkePolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudIkepoliciesDelete : Delete IKE Policy
// Delete an IKE Policy (by its unique identifier).
func (powervs *PowervsV1) PcloudIkepoliciesDelete(pcloudIkepoliciesDeleteOptions *PcloudIkepoliciesDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudIkepoliciesDeleteWithContext(context.Background(), pcloudIkepoliciesDeleteOptions)
}

// PcloudIkepoliciesDeleteWithContext is an alternate form of the PcloudIkepoliciesDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudIkepoliciesDeleteWithContext(ctx context.Context, pcloudIkepoliciesDeleteOptions *PcloudIkepoliciesDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudIkepoliciesDeleteOptions, "pcloudIkepoliciesDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudIkepoliciesDeleteOptions, "pcloudIkepoliciesDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudIkepoliciesDeleteOptions.CloudInstanceID,
		"ike_policy_id": *pcloudIkepoliciesDeleteOptions.IkePolicyID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/ike-policies/{ike_policy_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudIkepoliciesDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudIkepoliciesDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudIkepoliciesGet : Get the specified IKE Policy
// Get an IKE Policy (by its unique identifier).
func (powervs *PowervsV1) PcloudIkepoliciesGet(pcloudIkepoliciesGetOptions *PcloudIkepoliciesGetOptions) (result *IkePolicy, response *core.DetailedResponse, err error) {
	return powervs.PcloudIkepoliciesGetWithContext(context.Background(), pcloudIkepoliciesGetOptions)
}

// PcloudIkepoliciesGetWithContext is an alternate form of the PcloudIkepoliciesGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudIkepoliciesGetWithContext(ctx context.Context, pcloudIkepoliciesGetOptions *PcloudIkepoliciesGetOptions) (result *IkePolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudIkepoliciesGetOptions, "pcloudIkepoliciesGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudIkepoliciesGetOptions, "pcloudIkepoliciesGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudIkepoliciesGetOptions.CloudInstanceID,
		"ike_policy_id": *pcloudIkepoliciesGetOptions.IkePolicyID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/ike-policies/{ike_policy_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudIkepoliciesGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudIkepoliciesGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIkePolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudIkepoliciesPut : Update IKE Policy
// update an IKE Policy (by its unique identifier).
func (powervs *PowervsV1) PcloudIkepoliciesPut(pcloudIkepoliciesPutOptions *PcloudIkepoliciesPutOptions) (result *IkePolicy, response *core.DetailedResponse, err error) {
	return powervs.PcloudIkepoliciesPutWithContext(context.Background(), pcloudIkepoliciesPutOptions)
}

// PcloudIkepoliciesPutWithContext is an alternate form of the PcloudIkepoliciesPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudIkepoliciesPutWithContext(ctx context.Context, pcloudIkepoliciesPutOptions *PcloudIkepoliciesPutOptions) (result *IkePolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudIkepoliciesPutOptions, "pcloudIkepoliciesPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudIkepoliciesPutOptions, "pcloudIkepoliciesPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudIkepoliciesPutOptions.CloudInstanceID,
		"ike_policy_id": *pcloudIkepoliciesPutOptions.IkePolicyID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/ike-policies/{ike_policy_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudIkepoliciesPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudIkepoliciesPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	_, err = builder.SetBodyContentJSON(pcloudIkepoliciesPutOptions.Body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIkePolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudIpsecpoliciesGetall : Get all IPSec Policies
// Get all IPSec Policies with all their attributes.
func (powervs *PowervsV1) PcloudIpsecpoliciesGetall(pcloudIpsecpoliciesGetallOptions *PcloudIpsecpoliciesGetallOptions) (result *IPSecPolicies, response *core.DetailedResponse, err error) {
	return powervs.PcloudIpsecpoliciesGetallWithContext(context.Background(), pcloudIpsecpoliciesGetallOptions)
}

// PcloudIpsecpoliciesGetallWithContext is an alternate form of the PcloudIpsecpoliciesGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudIpsecpoliciesGetallWithContext(ctx context.Context, pcloudIpsecpoliciesGetallOptions *PcloudIpsecpoliciesGetallOptions) (result *IPSecPolicies, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudIpsecpoliciesGetallOptions, "pcloudIpsecpoliciesGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudIpsecpoliciesGetallOptions, "pcloudIpsecpoliciesGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudIpsecpoliciesGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/ipsec-policies`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudIpsecpoliciesGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudIpsecpoliciesGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIPSecPolicies)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudIpsecpoliciesPost : Add IPSec Policy
// Add a new IPSec Policy.
func (powervs *PowervsV1) PcloudIpsecpoliciesPost(pcloudIpsecpoliciesPostOptions *PcloudIpsecpoliciesPostOptions) (result *IPSecPolicy, response *core.DetailedResponse, err error) {
	return powervs.PcloudIpsecpoliciesPostWithContext(context.Background(), pcloudIpsecpoliciesPostOptions)
}

// PcloudIpsecpoliciesPostWithContext is an alternate form of the PcloudIpsecpoliciesPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudIpsecpoliciesPostWithContext(ctx context.Context, pcloudIpsecpoliciesPostOptions *PcloudIpsecpoliciesPostOptions) (result *IPSecPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudIpsecpoliciesPostOptions, "pcloudIpsecpoliciesPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudIpsecpoliciesPostOptions, "pcloudIpsecpoliciesPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudIpsecpoliciesPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/ipsec-policies`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudIpsecpoliciesPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudIpsecpoliciesPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudIpsecpoliciesPostOptions.DhGroup != nil {
		body["dhGroup"] = pcloudIpsecpoliciesPostOptions.DhGroup
	}
	if pcloudIpsecpoliciesPostOptions.Encryption != nil {
		body["encryption"] = pcloudIpsecpoliciesPostOptions.Encryption
	}
	if pcloudIpsecpoliciesPostOptions.KeyLifetime != nil {
		body["keyLifetime"] = pcloudIpsecpoliciesPostOptions.KeyLifetime
	}
	if pcloudIpsecpoliciesPostOptions.Name != nil {
		body["name"] = pcloudIpsecpoliciesPostOptions.Name
	}
	if pcloudIpsecpoliciesPostOptions.Pfs != nil {
		body["pfs"] = pcloudIpsecpoliciesPostOptions.Pfs
	}
	if pcloudIpsecpoliciesPostOptions.Authentication != nil {
		body["authentication"] = pcloudIpsecpoliciesPostOptions.Authentication
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIPSecPolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudIpsecpoliciesDelete : Delete IPSec Policy
// Delete an IPSec Policy (by its unique identifier).
func (powervs *PowervsV1) PcloudIpsecpoliciesDelete(pcloudIpsecpoliciesDeleteOptions *PcloudIpsecpoliciesDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudIpsecpoliciesDeleteWithContext(context.Background(), pcloudIpsecpoliciesDeleteOptions)
}

// PcloudIpsecpoliciesDeleteWithContext is an alternate form of the PcloudIpsecpoliciesDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudIpsecpoliciesDeleteWithContext(ctx context.Context, pcloudIpsecpoliciesDeleteOptions *PcloudIpsecpoliciesDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudIpsecpoliciesDeleteOptions, "pcloudIpsecpoliciesDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudIpsecpoliciesDeleteOptions, "pcloudIpsecpoliciesDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudIpsecpoliciesDeleteOptions.CloudInstanceID,
		"ipsec_policy_id": *pcloudIpsecpoliciesDeleteOptions.IpsecPolicyID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/ipsec-policies/{ipsec_policy_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudIpsecpoliciesDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudIpsecpoliciesDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudIpsecpoliciesGet : Get the specified IPSec Policy
// Get an IPSec Policy (by its unique identifier).
func (powervs *PowervsV1) PcloudIpsecpoliciesGet(pcloudIpsecpoliciesGetOptions *PcloudIpsecpoliciesGetOptions) (result *IPSecPolicy, response *core.DetailedResponse, err error) {
	return powervs.PcloudIpsecpoliciesGetWithContext(context.Background(), pcloudIpsecpoliciesGetOptions)
}

// PcloudIpsecpoliciesGetWithContext is an alternate form of the PcloudIpsecpoliciesGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudIpsecpoliciesGetWithContext(ctx context.Context, pcloudIpsecpoliciesGetOptions *PcloudIpsecpoliciesGetOptions) (result *IPSecPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudIpsecpoliciesGetOptions, "pcloudIpsecpoliciesGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudIpsecpoliciesGetOptions, "pcloudIpsecpoliciesGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudIpsecpoliciesGetOptions.CloudInstanceID,
		"ipsec_policy_id": *pcloudIpsecpoliciesGetOptions.IpsecPolicyID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/ipsec-policies/{ipsec_policy_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudIpsecpoliciesGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudIpsecpoliciesGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIPSecPolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudIpsecpoliciesPut : Update IPSec Policy
// update an IPSec Policy.
func (powervs *PowervsV1) PcloudIpsecpoliciesPut(pcloudIpsecpoliciesPutOptions *PcloudIpsecpoliciesPutOptions) (result *IPSecPolicy, response *core.DetailedResponse, err error) {
	return powervs.PcloudIpsecpoliciesPutWithContext(context.Background(), pcloudIpsecpoliciesPutOptions)
}

// PcloudIpsecpoliciesPutWithContext is an alternate form of the PcloudIpsecpoliciesPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudIpsecpoliciesPutWithContext(ctx context.Context, pcloudIpsecpoliciesPutOptions *PcloudIpsecpoliciesPutOptions) (result *IPSecPolicy, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudIpsecpoliciesPutOptions, "pcloudIpsecpoliciesPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudIpsecpoliciesPutOptions, "pcloudIpsecpoliciesPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudIpsecpoliciesPutOptions.CloudInstanceID,
		"ipsec_policy_id": *pcloudIpsecpoliciesPutOptions.IpsecPolicyID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/vpn/ipsec-policies/{ipsec_policy_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudIpsecpoliciesPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudIpsecpoliciesPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	_, err = builder.SetBodyContentJSON(pcloudIpsecpoliciesPutOptions.Body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalIPSecPolicy)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVolumegroupsGetall : Get all volume groups
func (powervs *PowervsV1) PcloudVolumegroupsGetall(pcloudVolumegroupsGetallOptions *PcloudVolumegroupsGetallOptions) (result *VolumeGroups, response *core.DetailedResponse, err error) {
	return powervs.PcloudVolumegroupsGetallWithContext(context.Background(), pcloudVolumegroupsGetallOptions)
}

// PcloudVolumegroupsGetallWithContext is an alternate form of the PcloudVolumegroupsGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudVolumegroupsGetallWithContext(ctx context.Context, pcloudVolumegroupsGetallOptions *PcloudVolumegroupsGetallOptions) (result *VolumeGroups, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVolumegroupsGetallOptions, "pcloudVolumegroupsGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVolumegroupsGetallOptions, "pcloudVolumegroupsGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVolumegroupsGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volume-groups`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVolumegroupsGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVolumegroupsGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeGroups)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVolumegroupsPost : Create a new volume group
func (powervs *PowervsV1) PcloudVolumegroupsPost(pcloudVolumegroupsPostOptions *PcloudVolumegroupsPostOptions) (result *VolumeGroupCreateResponse, response *core.DetailedResponse, err error) {
	return powervs.PcloudVolumegroupsPostWithContext(context.Background(), pcloudVolumegroupsPostOptions)
}

// PcloudVolumegroupsPostWithContext is an alternate form of the PcloudVolumegroupsPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudVolumegroupsPostWithContext(ctx context.Context, pcloudVolumegroupsPostOptions *PcloudVolumegroupsPostOptions) (result *VolumeGroupCreateResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVolumegroupsPostOptions, "pcloudVolumegroupsPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVolumegroupsPostOptions, "pcloudVolumegroupsPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVolumegroupsPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volume-groups`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVolumegroupsPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVolumegroupsPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudVolumegroupsPostOptions.VolumeIDs != nil {
		body["volumeIDs"] = pcloudVolumegroupsPostOptions.VolumeIDs
	}
	if pcloudVolumegroupsPostOptions.ConsistencyGroupName != nil {
		body["consistencyGroupName"] = pcloudVolumegroupsPostOptions.ConsistencyGroupName
	}
	if pcloudVolumegroupsPostOptions.Name != nil {
		body["name"] = pcloudVolumegroupsPostOptions.Name
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeGroupCreateResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVolumegroupsGetallDetails : Get all volume groups with details
func (powervs *PowervsV1) PcloudVolumegroupsGetallDetails(pcloudVolumegroupsGetallDetailsOptions *PcloudVolumegroupsGetallDetailsOptions) (result *VolumeGroupsDetails, response *core.DetailedResponse, err error) {
	return powervs.PcloudVolumegroupsGetallDetailsWithContext(context.Background(), pcloudVolumegroupsGetallDetailsOptions)
}

// PcloudVolumegroupsGetallDetailsWithContext is an alternate form of the PcloudVolumegroupsGetallDetails method which supports a Context parameter
func (powervs *PowervsV1) PcloudVolumegroupsGetallDetailsWithContext(ctx context.Context, pcloudVolumegroupsGetallDetailsOptions *PcloudVolumegroupsGetallDetailsOptions) (result *VolumeGroupsDetails, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVolumegroupsGetallDetailsOptions, "pcloudVolumegroupsGetallDetailsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVolumegroupsGetallDetailsOptions, "pcloudVolumegroupsGetallDetailsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVolumegroupsGetallDetailsOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volume-groups/details`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVolumegroupsGetallDetailsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVolumegroupsGetallDetails")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeGroupsDetails)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVolumegroupsDelete : Delete a cloud instance volume group
func (powervs *PowervsV1) PcloudVolumegroupsDelete(pcloudVolumegroupsDeleteOptions *PcloudVolumegroupsDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudVolumegroupsDeleteWithContext(context.Background(), pcloudVolumegroupsDeleteOptions)
}

// PcloudVolumegroupsDeleteWithContext is an alternate form of the PcloudVolumegroupsDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudVolumegroupsDeleteWithContext(ctx context.Context, pcloudVolumegroupsDeleteOptions *PcloudVolumegroupsDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVolumegroupsDeleteOptions, "pcloudVolumegroupsDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVolumegroupsDeleteOptions, "pcloudVolumegroupsDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVolumegroupsDeleteOptions.CloudInstanceID,
		"volume_group_id": *pcloudVolumegroupsDeleteOptions.VolumeGroupID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volume-groups/{volume_group_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVolumegroupsDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVolumegroupsDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVolumegroupsGet : Get volume Group
func (powervs *PowervsV1) PcloudVolumegroupsGet(pcloudVolumegroupsGetOptions *PcloudVolumegroupsGetOptions) (result *VolumeGroup, response *core.DetailedResponse, err error) {
	return powervs.PcloudVolumegroupsGetWithContext(context.Background(), pcloudVolumegroupsGetOptions)
}

// PcloudVolumegroupsGetWithContext is an alternate form of the PcloudVolumegroupsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudVolumegroupsGetWithContext(ctx context.Context, pcloudVolumegroupsGetOptions *PcloudVolumegroupsGetOptions) (result *VolumeGroup, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVolumegroupsGetOptions, "pcloudVolumegroupsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVolumegroupsGetOptions, "pcloudVolumegroupsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVolumegroupsGetOptions.CloudInstanceID,
		"volume_group_id": *pcloudVolumegroupsGetOptions.VolumeGroupID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volume-groups/{volume_group_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVolumegroupsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVolumegroupsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeGroup)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVolumegroupsPut : updates the volume group
func (powervs *PowervsV1) PcloudVolumegroupsPut(pcloudVolumegroupsPutOptions *PcloudVolumegroupsPutOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudVolumegroupsPutWithContext(context.Background(), pcloudVolumegroupsPutOptions)
}

// PcloudVolumegroupsPutWithContext is an alternate form of the PcloudVolumegroupsPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudVolumegroupsPutWithContext(ctx context.Context, pcloudVolumegroupsPutOptions *PcloudVolumegroupsPutOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVolumegroupsPutOptions, "pcloudVolumegroupsPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVolumegroupsPutOptions, "pcloudVolumegroupsPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVolumegroupsPutOptions.CloudInstanceID,
		"volume_group_id": *pcloudVolumegroupsPutOptions.VolumeGroupID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volume-groups/{volume_group_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVolumegroupsPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVolumegroupsPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudVolumegroupsPutOptions.AddVolumes != nil {
		body["addVolumes"] = pcloudVolumegroupsPutOptions.AddVolumes
	}
	if pcloudVolumegroupsPutOptions.RemoveVolumes != nil {
		body["removeVolumes"] = pcloudVolumegroupsPutOptions.RemoveVolumes
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVolumegroupsActionPost : Perform an action (start stop reset ) on a volume group
func (powervs *PowervsV1) PcloudVolumegroupsActionPost(pcloudVolumegroupsActionPostOptions *PcloudVolumegroupsActionPostOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudVolumegroupsActionPostWithContext(context.Background(), pcloudVolumegroupsActionPostOptions)
}

// PcloudVolumegroupsActionPostWithContext is an alternate form of the PcloudVolumegroupsActionPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudVolumegroupsActionPostWithContext(ctx context.Context, pcloudVolumegroupsActionPostOptions *PcloudVolumegroupsActionPostOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVolumegroupsActionPostOptions, "pcloudVolumegroupsActionPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVolumegroupsActionPostOptions, "pcloudVolumegroupsActionPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVolumegroupsActionPostOptions.CloudInstanceID,
		"volume_group_id": *pcloudVolumegroupsActionPostOptions.VolumeGroupID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volume-groups/{volume_group_id}/action`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVolumegroupsActionPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVolumegroupsActionPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	_, err = builder.SetBodyContentJSON(pcloudVolumegroupsActionPostOptions.Body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVolumegroupsGetDetails : Get volume Group details
func (powervs *PowervsV1) PcloudVolumegroupsGetDetails(pcloudVolumegroupsGetDetailsOptions *PcloudVolumegroupsGetDetailsOptions) (result *VolumeGroupDetails, response *core.DetailedResponse, err error) {
	return powervs.PcloudVolumegroupsGetDetailsWithContext(context.Background(), pcloudVolumegroupsGetDetailsOptions)
}

// PcloudVolumegroupsGetDetailsWithContext is an alternate form of the PcloudVolumegroupsGetDetails method which supports a Context parameter
func (powervs *PowervsV1) PcloudVolumegroupsGetDetailsWithContext(ctx context.Context, pcloudVolumegroupsGetDetailsOptions *PcloudVolumegroupsGetDetailsOptions) (result *VolumeGroupDetails, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVolumegroupsGetDetailsOptions, "pcloudVolumegroupsGetDetailsOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVolumegroupsGetDetailsOptions, "pcloudVolumegroupsGetDetailsOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVolumegroupsGetDetailsOptions.CloudInstanceID,
		"volume_group_id": *pcloudVolumegroupsGetDetailsOptions.VolumeGroupID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volume-groups/{volume_group_id}/details`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVolumegroupsGetDetailsOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVolumegroupsGetDetails")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeGroupDetails)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVolumegroupsRemoteCopyRelationshipsGet : Get remote copy relationships of the volume belonging to volume group
func (powervs *PowervsV1) PcloudVolumegroupsRemoteCopyRelationshipsGet(pcloudVolumegroupsRemoteCopyRelationshipsGetOptions *PcloudVolumegroupsRemoteCopyRelationshipsGetOptions) (result *VolumeGroupRemoteCopyRelationships, response *core.DetailedResponse, err error) {
	return powervs.PcloudVolumegroupsRemoteCopyRelationshipsGetWithContext(context.Background(), pcloudVolumegroupsRemoteCopyRelationshipsGetOptions)
}

// PcloudVolumegroupsRemoteCopyRelationshipsGetWithContext is an alternate form of the PcloudVolumegroupsRemoteCopyRelationshipsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudVolumegroupsRemoteCopyRelationshipsGetWithContext(ctx context.Context, pcloudVolumegroupsRemoteCopyRelationshipsGetOptions *PcloudVolumegroupsRemoteCopyRelationshipsGetOptions) (result *VolumeGroupRemoteCopyRelationships, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVolumegroupsRemoteCopyRelationshipsGetOptions, "pcloudVolumegroupsRemoteCopyRelationshipsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVolumegroupsRemoteCopyRelationshipsGetOptions, "pcloudVolumegroupsRemoteCopyRelationshipsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVolumegroupsRemoteCopyRelationshipsGetOptions.CloudInstanceID,
		"volume_group_id": *pcloudVolumegroupsRemoteCopyRelationshipsGetOptions.VolumeGroupID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volume-groups/{volume_group_id}/remote-copy-relationships`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVolumegroupsRemoteCopyRelationshipsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVolumegroupsRemoteCopyRelationshipsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeGroupRemoteCopyRelationships)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVolumegroupsStorageDetailsGet : Get storage details of volume group
func (powervs *PowervsV1) PcloudVolumegroupsStorageDetailsGet(pcloudVolumegroupsStorageDetailsGetOptions *PcloudVolumegroupsStorageDetailsGetOptions) (result *VolumeGroupStorageDetails, response *core.DetailedResponse, err error) {
	return powervs.PcloudVolumegroupsStorageDetailsGetWithContext(context.Background(), pcloudVolumegroupsStorageDetailsGetOptions)
}

// PcloudVolumegroupsStorageDetailsGetWithContext is an alternate form of the PcloudVolumegroupsStorageDetailsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudVolumegroupsStorageDetailsGetWithContext(ctx context.Context, pcloudVolumegroupsStorageDetailsGetOptions *PcloudVolumegroupsStorageDetailsGetOptions) (result *VolumeGroupStorageDetails, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVolumegroupsStorageDetailsGetOptions, "pcloudVolumegroupsStorageDetailsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVolumegroupsStorageDetailsGetOptions, "pcloudVolumegroupsStorageDetailsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVolumegroupsStorageDetailsGetOptions.CloudInstanceID,
		"volume_group_id": *pcloudVolumegroupsStorageDetailsGetOptions.VolumeGroupID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volume-groups/{volume_group_id}/storage-details`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVolumegroupsStorageDetailsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVolumegroupsStorageDetailsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeGroupStorageDetails)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVolumeOnboardingGetall : List all volume onboardings for this cloud instance
func (powervs *PowervsV1) PcloudVolumeOnboardingGetall(pcloudVolumeOnboardingGetallOptions *PcloudVolumeOnboardingGetallOptions) (result *VolumeOnboardings, response *core.DetailedResponse, err error) {
	return powervs.PcloudVolumeOnboardingGetallWithContext(context.Background(), pcloudVolumeOnboardingGetallOptions)
}

// PcloudVolumeOnboardingGetallWithContext is an alternate form of the PcloudVolumeOnboardingGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudVolumeOnboardingGetallWithContext(ctx context.Context, pcloudVolumeOnboardingGetallOptions *PcloudVolumeOnboardingGetallOptions) (result *VolumeOnboardings, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVolumeOnboardingGetallOptions, "pcloudVolumeOnboardingGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVolumeOnboardingGetallOptions, "pcloudVolumeOnboardingGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVolumeOnboardingGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volumes/onboarding`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVolumeOnboardingGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVolumeOnboardingGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeOnboardings)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVolumeOnboardingPost : Onboard auxiliary volumes to target site
func (powervs *PowervsV1) PcloudVolumeOnboardingPost(pcloudVolumeOnboardingPostOptions *PcloudVolumeOnboardingPostOptions) (result *VolumeOnboardingCreateResponse, response *core.DetailedResponse, err error) {
	return powervs.PcloudVolumeOnboardingPostWithContext(context.Background(), pcloudVolumeOnboardingPostOptions)
}

// PcloudVolumeOnboardingPostWithContext is an alternate form of the PcloudVolumeOnboardingPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudVolumeOnboardingPostWithContext(ctx context.Context, pcloudVolumeOnboardingPostOptions *PcloudVolumeOnboardingPostOptions) (result *VolumeOnboardingCreateResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVolumeOnboardingPostOptions, "pcloudVolumeOnboardingPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVolumeOnboardingPostOptions, "pcloudVolumeOnboardingPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVolumeOnboardingPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volumes/onboarding`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVolumeOnboardingPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVolumeOnboardingPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudVolumeOnboardingPostOptions.Volumes != nil {
		body["Volumes"] = pcloudVolumeOnboardingPostOptions.Volumes
	}
	if pcloudVolumeOnboardingPostOptions.Description != nil {
		body["description"] = pcloudVolumeOnboardingPostOptions.Description
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeOnboardingCreateResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVolumeOnboardingGet : Get the information of volume onboarding operation
func (powervs *PowervsV1) PcloudVolumeOnboardingGet(pcloudVolumeOnboardingGetOptions *PcloudVolumeOnboardingGetOptions) (result *VolumeOnboarding, response *core.DetailedResponse, err error) {
	return powervs.PcloudVolumeOnboardingGetWithContext(context.Background(), pcloudVolumeOnboardingGetOptions)
}

// PcloudVolumeOnboardingGetWithContext is an alternate form of the PcloudVolumeOnboardingGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudVolumeOnboardingGetWithContext(ctx context.Context, pcloudVolumeOnboardingGetOptions *PcloudVolumeOnboardingGetOptions) (result *VolumeOnboarding, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudVolumeOnboardingGetOptions, "pcloudVolumeOnboardingGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVolumeOnboardingGetOptions, "pcloudVolumeOnboardingGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVolumeOnboardingGetOptions.CloudInstanceID,
		"volume_onboarding_id": *pcloudVolumeOnboardingGetOptions.VolumeOnboardingID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volumes/onboarding/{volume_onboarding_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVolumeOnboardingGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVolumeOnboardingGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeOnboarding)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesVolumesGetall : List all volumes attached to a PVM Instance
func (powervs *PowervsV1) PcloudPvminstancesVolumesGetall(pcloudPvminstancesVolumesGetallOptions *PcloudPvminstancesVolumesGetallOptions) (result *Volumes, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesVolumesGetallWithContext(context.Background(), pcloudPvminstancesVolumesGetallOptions)
}

// PcloudPvminstancesVolumesGetallWithContext is an alternate form of the PcloudPvminstancesVolumesGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesVolumesGetallWithContext(ctx context.Context, pcloudPvminstancesVolumesGetallOptions *PcloudPvminstancesVolumesGetallOptions) (result *Volumes, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesVolumesGetallOptions, "pcloudPvminstancesVolumesGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesVolumesGetallOptions, "pcloudPvminstancesVolumesGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesVolumesGetallOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesVolumesGetallOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/volumes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesVolumesGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesVolumesGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumes)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesVolumesDelete : Detach a volume from a PVMInstance
func (powervs *PowervsV1) PcloudPvminstancesVolumesDelete(pcloudPvminstancesVolumesDeleteOptions *PcloudPvminstancesVolumesDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesVolumesDeleteWithContext(context.Background(), pcloudPvminstancesVolumesDeleteOptions)
}

// PcloudPvminstancesVolumesDeleteWithContext is an alternate form of the PcloudPvminstancesVolumesDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesVolumesDeleteWithContext(ctx context.Context, pcloudPvminstancesVolumesDeleteOptions *PcloudPvminstancesVolumesDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesVolumesDeleteOptions, "pcloudPvminstancesVolumesDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesVolumesDeleteOptions, "pcloudPvminstancesVolumesDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesVolumesDeleteOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesVolumesDeleteOptions.PvmInstanceID,
		"volume_id": *pcloudPvminstancesVolumesDeleteOptions.VolumeID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/volumes/{volume_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesVolumesDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesVolumesDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesVolumesGet : Detailed info of a volume attached to a PVMInstance
func (powervs *PowervsV1) PcloudPvminstancesVolumesGet(pcloudPvminstancesVolumesGetOptions *PcloudPvminstancesVolumesGetOptions) (result *Volume, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesVolumesGetWithContext(context.Background(), pcloudPvminstancesVolumesGetOptions)
}

// PcloudPvminstancesVolumesGetWithContext is an alternate form of the PcloudPvminstancesVolumesGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesVolumesGetWithContext(ctx context.Context, pcloudPvminstancesVolumesGetOptions *PcloudPvminstancesVolumesGetOptions) (result *Volume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesVolumesGetOptions, "pcloudPvminstancesVolumesGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesVolumesGetOptions, "pcloudPvminstancesVolumesGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesVolumesGetOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesVolumesGetOptions.PvmInstanceID,
		"volume_id": *pcloudPvminstancesVolumesGetOptions.VolumeID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/volumes/{volume_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesVolumesGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesVolumesGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolume)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesVolumesPost : Attach a volume to a PVMInstance
func (powervs *PowervsV1) PcloudPvminstancesVolumesPost(pcloudPvminstancesVolumesPostOptions *PcloudPvminstancesVolumesPostOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesVolumesPostWithContext(context.Background(), pcloudPvminstancesVolumesPostOptions)
}

// PcloudPvminstancesVolumesPostWithContext is an alternate form of the PcloudPvminstancesVolumesPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesVolumesPostWithContext(ctx context.Context, pcloudPvminstancesVolumesPostOptions *PcloudPvminstancesVolumesPostOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesVolumesPostOptions, "pcloudPvminstancesVolumesPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesVolumesPostOptions, "pcloudPvminstancesVolumesPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesVolumesPostOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesVolumesPostOptions.PvmInstanceID,
		"volume_id": *pcloudPvminstancesVolumesPostOptions.VolumeID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/volumes/{volume_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesVolumesPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesVolumesPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesVolumesPut : Update a volume attached to a PVMInstance
func (powervs *PowervsV1) PcloudPvminstancesVolumesPut(pcloudPvminstancesVolumesPutOptions *PcloudPvminstancesVolumesPutOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesVolumesPutWithContext(context.Background(), pcloudPvminstancesVolumesPutOptions)
}

// PcloudPvminstancesVolumesPutWithContext is an alternate form of the PcloudPvminstancesVolumesPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesVolumesPutWithContext(ctx context.Context, pcloudPvminstancesVolumesPutOptions *PcloudPvminstancesVolumesPutOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesVolumesPutOptions, "pcloudPvminstancesVolumesPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesVolumesPutOptions, "pcloudPvminstancesVolumesPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesVolumesPutOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesVolumesPutOptions.PvmInstanceID,
		"volume_id": *pcloudPvminstancesVolumesPutOptions.VolumeID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/volumes/{volume_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesVolumesPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesVolumesPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudPvminstancesVolumesPutOptions.DeleteOnTermination != nil {
		body["deleteOnTermination"] = pcloudPvminstancesVolumesPutOptions.DeleteOnTermination
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudPvminstancesVolumesSetbootPut : Set the PVMInstance volume as the boot volume
func (powervs *PowervsV1) PcloudPvminstancesVolumesSetbootPut(pcloudPvminstancesVolumesSetbootPutOptions *PcloudPvminstancesVolumesSetbootPutOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudPvminstancesVolumesSetbootPutWithContext(context.Background(), pcloudPvminstancesVolumesSetbootPutOptions)
}

// PcloudPvminstancesVolumesSetbootPutWithContext is an alternate form of the PcloudPvminstancesVolumesSetbootPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudPvminstancesVolumesSetbootPutWithContext(ctx context.Context, pcloudPvminstancesVolumesSetbootPutOptions *PcloudPvminstancesVolumesSetbootPutOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudPvminstancesVolumesSetbootPutOptions, "pcloudPvminstancesVolumesSetbootPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudPvminstancesVolumesSetbootPutOptions, "pcloudPvminstancesVolumesSetbootPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudPvminstancesVolumesSetbootPutOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudPvminstancesVolumesSetbootPutOptions.PvmInstanceID,
		"volume_id": *pcloudPvminstancesVolumesSetbootPutOptions.VolumeID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/volumes/{volume_id}/setboot`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudPvminstancesVolumesSetbootPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudPvminstancesVolumesSetbootPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesVolumesGetall : List all volumes for this cloud instance
func (powervs *PowervsV1) PcloudCloudinstancesVolumesGetall(pcloudCloudinstancesVolumesGetallOptions *PcloudCloudinstancesVolumesGetallOptions) (result *Volumes, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesVolumesGetallWithContext(context.Background(), pcloudCloudinstancesVolumesGetallOptions)
}

// PcloudCloudinstancesVolumesGetallWithContext is an alternate form of the PcloudCloudinstancesVolumesGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesVolumesGetallWithContext(ctx context.Context, pcloudCloudinstancesVolumesGetallOptions *PcloudCloudinstancesVolumesGetallOptions) (result *Volumes, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesVolumesGetallOptions, "pcloudCloudinstancesVolumesGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesVolumesGetallOptions, "pcloudCloudinstancesVolumesGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesVolumesGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volumes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesVolumesGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesVolumesGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if pcloudCloudinstancesVolumesGetallOptions.ReplicationEnabled != nil {
		builder.AddQuery("replicationEnabled", fmt.Sprint(*pcloudCloudinstancesVolumesGetallOptions.ReplicationEnabled))
	}
	if pcloudCloudinstancesVolumesGetallOptions.Affinity != nil {
		builder.AddQuery("affinity", fmt.Sprint(*pcloudCloudinstancesVolumesGetallOptions.Affinity))
	}
	if pcloudCloudinstancesVolumesGetallOptions.Auxiliary != nil {
		builder.AddQuery("auxiliary", fmt.Sprint(*pcloudCloudinstancesVolumesGetallOptions.Auxiliary))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumes)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesVolumesPost : Create a new data Volume
func (powervs *PowervsV1) PcloudCloudinstancesVolumesPost(pcloudCloudinstancesVolumesPostOptions *PcloudCloudinstancesVolumesPostOptions) (result *Volume, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesVolumesPostWithContext(context.Background(), pcloudCloudinstancesVolumesPostOptions)
}

// PcloudCloudinstancesVolumesPostWithContext is an alternate form of the PcloudCloudinstancesVolumesPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesVolumesPostWithContext(ctx context.Context, pcloudCloudinstancesVolumesPostOptions *PcloudCloudinstancesVolumesPostOptions) (result *Volume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesVolumesPostOptions, "pcloudCloudinstancesVolumesPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesVolumesPostOptions, "pcloudCloudinstancesVolumesPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesVolumesPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volumes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesVolumesPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesVolumesPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudCloudinstancesVolumesPostOptions.Name != nil {
		body["name"] = pcloudCloudinstancesVolumesPostOptions.Name
	}
	if pcloudCloudinstancesVolumesPostOptions.Size != nil {
		body["size"] = pcloudCloudinstancesVolumesPostOptions.Size
	}
	if pcloudCloudinstancesVolumesPostOptions.AffinityPvmInstance != nil {
		body["affinityPVMInstance"] = pcloudCloudinstancesVolumesPostOptions.AffinityPvmInstance
	}
	if pcloudCloudinstancesVolumesPostOptions.AffinityPolicy != nil {
		body["affinityPolicy"] = pcloudCloudinstancesVolumesPostOptions.AffinityPolicy
	}
	if pcloudCloudinstancesVolumesPostOptions.AffinityVolume != nil {
		body["affinityVolume"] = pcloudCloudinstancesVolumesPostOptions.AffinityVolume
	}
	if pcloudCloudinstancesVolumesPostOptions.AntiAffinityPvmInstances != nil {
		body["antiAffinityPVMInstances"] = pcloudCloudinstancesVolumesPostOptions.AntiAffinityPvmInstances
	}
	if pcloudCloudinstancesVolumesPostOptions.AntiAffinityVolumes != nil {
		body["antiAffinityVolumes"] = pcloudCloudinstancesVolumesPostOptions.AntiAffinityVolumes
	}
	if pcloudCloudinstancesVolumesPostOptions.DiskType != nil {
		body["diskType"] = pcloudCloudinstancesVolumesPostOptions.DiskType
	}
	if pcloudCloudinstancesVolumesPostOptions.ReplicationEnabled != nil {
		body["replicationEnabled"] = pcloudCloudinstancesVolumesPostOptions.ReplicationEnabled
	}
	if pcloudCloudinstancesVolumesPostOptions.Shareable != nil {
		body["shareable"] = pcloudCloudinstancesVolumesPostOptions.Shareable
	}
	if pcloudCloudinstancesVolumesPostOptions.VolumePool != nil {
		body["volumePool"] = pcloudCloudinstancesVolumesPostOptions.VolumePool
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolume)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudVolumesClonePost : Create a volume clone for specified volumes
// This API is deprecated, use v2 clone API to perform the volume clone.
//
// >*Note*: Support for this API will be available till 31st March 2023.
// Deprecated: this method is deprecated and may be removed in a future release.
func (powervs *PowervsV1) PcloudVolumesClonePost(pcloudVolumesClonePostOptions *PcloudVolumesClonePostOptions) (result *VolumesCloneResponse, response *core.DetailedResponse, err error) {
	return powervs.PcloudVolumesClonePostWithContext(context.Background(), pcloudVolumesClonePostOptions)
}

// PcloudVolumesClonePostWithContext is an alternate form of the PcloudVolumesClonePost method which supports a Context parameter
// Deprecated: this method is deprecated and may be removed in a future release.
func (powervs *PowervsV1) PcloudVolumesClonePostWithContext(ctx context.Context, pcloudVolumesClonePostOptions *PcloudVolumesClonePostOptions) (result *VolumesCloneResponse, response *core.DetailedResponse, err error) {
	core.GetLogger().Warn("A deprecated operation has been invoked: PcloudVolumesClonePost")
	err = core.ValidateNotNil(pcloudVolumesClonePostOptions, "pcloudVolumesClonePostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudVolumesClonePostOptions, "pcloudVolumesClonePostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudVolumesClonePostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volumes/clone`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudVolumesClonePostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudVolumesClonePost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudVolumesClonePostOptions.DisplayName != nil {
		body["displayName"] = pcloudVolumesClonePostOptions.DisplayName
	}
	if pcloudVolumesClonePostOptions.VolumeIDs != nil {
		body["volumeIDs"] = pcloudVolumesClonePostOptions.VolumeIDs
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumesCloneResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesVolumesDelete : Delete a cloud instance volume
func (powervs *PowervsV1) PcloudCloudinstancesVolumesDelete(pcloudCloudinstancesVolumesDeleteOptions *PcloudCloudinstancesVolumesDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesVolumesDeleteWithContext(context.Background(), pcloudCloudinstancesVolumesDeleteOptions)
}

// PcloudCloudinstancesVolumesDeleteWithContext is an alternate form of the PcloudCloudinstancesVolumesDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesVolumesDeleteWithContext(ctx context.Context, pcloudCloudinstancesVolumesDeleteOptions *PcloudCloudinstancesVolumesDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesVolumesDeleteOptions, "pcloudCloudinstancesVolumesDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesVolumesDeleteOptions, "pcloudCloudinstancesVolumesDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesVolumesDeleteOptions.CloudInstanceID,
		"volume_id": *pcloudCloudinstancesVolumesDeleteOptions.VolumeID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volumes/{volume_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesVolumesDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesVolumesDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesVolumesGet : Detailed info of a volume
func (powervs *PowervsV1) PcloudCloudinstancesVolumesGet(pcloudCloudinstancesVolumesGetOptions *PcloudCloudinstancesVolumesGetOptions) (result *Volume, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesVolumesGetWithContext(context.Background(), pcloudCloudinstancesVolumesGetOptions)
}

// PcloudCloudinstancesVolumesGetWithContext is an alternate form of the PcloudCloudinstancesVolumesGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesVolumesGetWithContext(ctx context.Context, pcloudCloudinstancesVolumesGetOptions *PcloudCloudinstancesVolumesGetOptions) (result *Volume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesVolumesGetOptions, "pcloudCloudinstancesVolumesGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesVolumesGetOptions, "pcloudCloudinstancesVolumesGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesVolumesGetOptions.CloudInstanceID,
		"volume_id": *pcloudCloudinstancesVolumesGetOptions.VolumeID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volumes/{volume_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesVolumesGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesVolumesGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolume)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesVolumesPut : Update a cloud instance volume
func (powervs *PowervsV1) PcloudCloudinstancesVolumesPut(pcloudCloudinstancesVolumesPutOptions *PcloudCloudinstancesVolumesPutOptions) (result *Volume, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesVolumesPutWithContext(context.Background(), pcloudCloudinstancesVolumesPutOptions)
}

// PcloudCloudinstancesVolumesPutWithContext is an alternate form of the PcloudCloudinstancesVolumesPut method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesVolumesPutWithContext(ctx context.Context, pcloudCloudinstancesVolumesPutOptions *PcloudCloudinstancesVolumesPutOptions) (result *Volume, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesVolumesPutOptions, "pcloudCloudinstancesVolumesPutOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesVolumesPutOptions, "pcloudCloudinstancesVolumesPutOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesVolumesPutOptions.CloudInstanceID,
		"volume_id": *pcloudCloudinstancesVolumesPutOptions.VolumeID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volumes/{volume_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesVolumesPutOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesVolumesPut")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudCloudinstancesVolumesPutOptions.Bootable != nil {
		body["bootable"] = pcloudCloudinstancesVolumesPutOptions.Bootable
	}
	if pcloudCloudinstancesVolumesPutOptions.Name != nil {
		body["name"] = pcloudCloudinstancesVolumesPutOptions.Name
	}
	if pcloudCloudinstancesVolumesPutOptions.Shareable != nil {
		body["shareable"] = pcloudCloudinstancesVolumesPutOptions.Shareable
	}
	if pcloudCloudinstancesVolumesPutOptions.Size != nil {
		body["size"] = pcloudCloudinstancesVolumesPutOptions.Size
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolume)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesVolumesActionPost : Perform an action on a Volume
func (powervs *PowervsV1) PcloudCloudinstancesVolumesActionPost(pcloudCloudinstancesVolumesActionPostOptions *PcloudCloudinstancesVolumesActionPostOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesVolumesActionPostWithContext(context.Background(), pcloudCloudinstancesVolumesActionPostOptions)
}

// PcloudCloudinstancesVolumesActionPostWithContext is an alternate form of the PcloudCloudinstancesVolumesActionPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesVolumesActionPostWithContext(ctx context.Context, pcloudCloudinstancesVolumesActionPostOptions *PcloudCloudinstancesVolumesActionPostOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesVolumesActionPostOptions, "pcloudCloudinstancesVolumesActionPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesVolumesActionPostOptions, "pcloudCloudinstancesVolumesActionPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesVolumesActionPostOptions.CloudInstanceID,
		"volume_id": *pcloudCloudinstancesVolumesActionPostOptions.VolumeID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volumes/{volume_id}/action`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesVolumesActionPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesVolumesActionPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudCloudinstancesVolumesActionPostOptions.ReplicationEnabled != nil {
		body["replicationEnabled"] = pcloudCloudinstancesVolumesActionPostOptions.ReplicationEnabled
	}
	if pcloudCloudinstancesVolumesActionPostOptions.TargetStorageTier != nil {
		body["targetStorageTier"] = pcloudCloudinstancesVolumesActionPostOptions.TargetStorageTier
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesVolumesFlashCopyMappingsGet : Get a list of flashcopy mappings of a given volume
func (powervs *PowervsV1) PcloudCloudinstancesVolumesFlashCopyMappingsGet(pcloudCloudinstancesVolumesFlashCopyMappingsGetOptions *PcloudCloudinstancesVolumesFlashCopyMappingsGetOptions) (result []FlashCopyMapping, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesVolumesFlashCopyMappingsGetWithContext(context.Background(), pcloudCloudinstancesVolumesFlashCopyMappingsGetOptions)
}

// PcloudCloudinstancesVolumesFlashCopyMappingsGetWithContext is an alternate form of the PcloudCloudinstancesVolumesFlashCopyMappingsGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesVolumesFlashCopyMappingsGetWithContext(ctx context.Context, pcloudCloudinstancesVolumesFlashCopyMappingsGetOptions *PcloudCloudinstancesVolumesFlashCopyMappingsGetOptions) (result []FlashCopyMapping, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesVolumesFlashCopyMappingsGetOptions, "pcloudCloudinstancesVolumesFlashCopyMappingsGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesVolumesFlashCopyMappingsGetOptions, "pcloudCloudinstancesVolumesFlashCopyMappingsGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesVolumesFlashCopyMappingsGetOptions.CloudInstanceID,
		"volume_id": *pcloudCloudinstancesVolumesFlashCopyMappingsGetOptions.VolumeID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volumes/{volume_id}/flash-copy-mappings`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesVolumesFlashCopyMappingsGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesVolumesFlashCopyMappingsGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse []json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalFlashCopyMapping)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudCloudinstancesVolumesRemoteCopyRelationshipGet : Get remote copy relationship of a volume
func (powervs *PowervsV1) PcloudCloudinstancesVolumesRemoteCopyRelationshipGet(pcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions *PcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions) (result *VolumeRemoteCopyRelationship, response *core.DetailedResponse, err error) {
	return powervs.PcloudCloudinstancesVolumesRemoteCopyRelationshipGetWithContext(context.Background(), pcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions)
}

// PcloudCloudinstancesVolumesRemoteCopyRelationshipGetWithContext is an alternate form of the PcloudCloudinstancesVolumesRemoteCopyRelationshipGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudCloudinstancesVolumesRemoteCopyRelationshipGetWithContext(ctx context.Context, pcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions *PcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions) (result *VolumeRemoteCopyRelationship, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions, "pcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions, "pcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions.CloudInstanceID,
		"volume_id": *pcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions.VolumeID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v1/cloud-instances/{cloud_instance_id}/volumes/{volume_id}/remote-copy`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudCloudinstancesVolumesRemoteCopyRelationshipGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumeRemoteCopyRelationship)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2PvminstancesVolumesDelete : Detach multiple volumes from a PVMInstance
func (powervs *PowervsV1) PcloudV2PvminstancesVolumesDelete(pcloudV2PvminstancesVolumesDeleteOptions *PcloudV2PvminstancesVolumesDeleteOptions) (result *VolumesDetachmentResponse, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2PvminstancesVolumesDeleteWithContext(context.Background(), pcloudV2PvminstancesVolumesDeleteOptions)
}

// PcloudV2PvminstancesVolumesDeleteWithContext is an alternate form of the PcloudV2PvminstancesVolumesDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2PvminstancesVolumesDeleteWithContext(ctx context.Context, pcloudV2PvminstancesVolumesDeleteOptions *PcloudV2PvminstancesVolumesDeleteOptions) (result *VolumesDetachmentResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2PvminstancesVolumesDeleteOptions, "pcloudV2PvminstancesVolumesDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2PvminstancesVolumesDeleteOptions, "pcloudV2PvminstancesVolumesDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2PvminstancesVolumesDeleteOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudV2PvminstancesVolumesDeleteOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/volumes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2PvminstancesVolumesDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2PvminstancesVolumesDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudV2PvminstancesVolumesDeleteOptions.DetachAllVolumes != nil {
		body["detachAllVolumes"] = pcloudV2PvminstancesVolumesDeleteOptions.DetachAllVolumes
	}
	if pcloudV2PvminstancesVolumesDeleteOptions.DetachPrimaryBootVolume != nil {
		body["detachPrimaryBootVolume"] = pcloudV2PvminstancesVolumesDeleteOptions.DetachPrimaryBootVolume
	}
	if pcloudV2PvminstancesVolumesDeleteOptions.VolumeIDs != nil {
		body["volumeIDs"] = pcloudV2PvminstancesVolumesDeleteOptions.VolumeIDs
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumesDetachmentResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2PvminstancesVolumesPost : Attach all volumes to a PVMInstance
func (powervs *PowervsV1) PcloudV2PvminstancesVolumesPost(pcloudV2PvminstancesVolumesPostOptions *PcloudV2PvminstancesVolumesPostOptions) (result *VolumesAttachmentResponse, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2PvminstancesVolumesPostWithContext(context.Background(), pcloudV2PvminstancesVolumesPostOptions)
}

// PcloudV2PvminstancesVolumesPostWithContext is an alternate form of the PcloudV2PvminstancesVolumesPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2PvminstancesVolumesPostWithContext(ctx context.Context, pcloudV2PvminstancesVolumesPostOptions *PcloudV2PvminstancesVolumesPostOptions) (result *VolumesAttachmentResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2PvminstancesVolumesPostOptions, "pcloudV2PvminstancesVolumesPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2PvminstancesVolumesPostOptions, "pcloudV2PvminstancesVolumesPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2PvminstancesVolumesPostOptions.CloudInstanceID,
		"pvm_instance_id": *pcloudV2PvminstancesVolumesPostOptions.PvmInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/pvm-instances/{pvm_instance_id}/volumes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2PvminstancesVolumesPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2PvminstancesVolumesPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudV2PvminstancesVolumesPostOptions.VolumeIDs != nil {
		body["volumeIDs"] = pcloudV2PvminstancesVolumesPostOptions.VolumeIDs
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumesAttachmentResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2VolumesDelete : Delete all volumes
func (powervs *PowervsV1) PcloudV2VolumesDelete(pcloudV2VolumesDeleteOptions *PcloudV2VolumesDeleteOptions) (result *VolumesDeleteResponse, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2VolumesDeleteWithContext(context.Background(), pcloudV2VolumesDeleteOptions)
}

// PcloudV2VolumesDeleteWithContext is an alternate form of the PcloudV2VolumesDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2VolumesDeleteWithContext(ctx context.Context, pcloudV2VolumesDeleteOptions *PcloudV2VolumesDeleteOptions) (result *VolumesDeleteResponse, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2VolumesDeleteOptions, "pcloudV2VolumesDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2VolumesDeleteOptions, "pcloudV2VolumesDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2VolumesDeleteOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/volumes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2VolumesDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2VolumesDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudV2VolumesDeleteOptions.VolumeIDs != nil {
		body["volumeIDs"] = pcloudV2VolumesDeleteOptions.VolumeIDs
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumesDeleteResponse)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2VolumesPost : Create multiple data volumes from a single definition
func (powervs *PowervsV1) PcloudV2VolumesPost(pcloudV2VolumesPostOptions *PcloudV2VolumesPostOptions) (result *Volumes, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2VolumesPostWithContext(context.Background(), pcloudV2VolumesPostOptions)
}

// PcloudV2VolumesPostWithContext is an alternate form of the PcloudV2VolumesPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2VolumesPostWithContext(ctx context.Context, pcloudV2VolumesPostOptions *PcloudV2VolumesPostOptions) (result *Volumes, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2VolumesPostOptions, "pcloudV2VolumesPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2VolumesPostOptions, "pcloudV2VolumesPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2VolumesPostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/volumes`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2VolumesPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2VolumesPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudV2VolumesPostOptions.Name != nil {
		body["name"] = pcloudV2VolumesPostOptions.Name
	}
	if pcloudV2VolumesPostOptions.Size != nil {
		body["size"] = pcloudV2VolumesPostOptions.Size
	}
	if pcloudV2VolumesPostOptions.AffinityPvmInstance != nil {
		body["affinityPVMInstance"] = pcloudV2VolumesPostOptions.AffinityPvmInstance
	}
	if pcloudV2VolumesPostOptions.AffinityPolicy != nil {
		body["affinityPolicy"] = pcloudV2VolumesPostOptions.AffinityPolicy
	}
	if pcloudV2VolumesPostOptions.AffinityVolume != nil {
		body["affinityVolume"] = pcloudV2VolumesPostOptions.AffinityVolume
	}
	if pcloudV2VolumesPostOptions.AntiAffinityPvmInstances != nil {
		body["antiAffinityPVMInstances"] = pcloudV2VolumesPostOptions.AntiAffinityPvmInstances
	}
	if pcloudV2VolumesPostOptions.AntiAffinityVolumes != nil {
		body["antiAffinityVolumes"] = pcloudV2VolumesPostOptions.AntiAffinityVolumes
	}
	if pcloudV2VolumesPostOptions.Count != nil {
		body["count"] = pcloudV2VolumesPostOptions.Count
	}
	if pcloudV2VolumesPostOptions.DiskType != nil {
		body["diskType"] = pcloudV2VolumesPostOptions.DiskType
	}
	if pcloudV2VolumesPostOptions.ReplicationEnabled != nil {
		body["replicationEnabled"] = pcloudV2VolumesPostOptions.ReplicationEnabled
	}
	if pcloudV2VolumesPostOptions.Shareable != nil {
		body["shareable"] = pcloudV2VolumesPostOptions.Shareable
	}
	if pcloudV2VolumesPostOptions.VolumePool != nil {
		body["volumePool"] = pcloudV2VolumesPostOptions.VolumePool
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumes)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2VolumescloneGetall : Get the list of volumes-clone request for a cloud instance
func (powervs *PowervsV1) PcloudV2VolumescloneGetall(pcloudV2VolumescloneGetallOptions *PcloudV2VolumescloneGetallOptions) (result *VolumesClones, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2VolumescloneGetallWithContext(context.Background(), pcloudV2VolumescloneGetallOptions)
}

// PcloudV2VolumescloneGetallWithContext is an alternate form of the PcloudV2VolumescloneGetall method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2VolumescloneGetallWithContext(ctx context.Context, pcloudV2VolumescloneGetallOptions *PcloudV2VolumescloneGetallOptions) (result *VolumesClones, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2VolumescloneGetallOptions, "pcloudV2VolumescloneGetallOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2VolumescloneGetallOptions, "pcloudV2VolumescloneGetallOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2VolumescloneGetallOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/volumes-clone`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2VolumescloneGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2VolumescloneGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	if pcloudV2VolumescloneGetallOptions.Filter != nil {
		builder.AddQuery("filter", fmt.Sprint(*pcloudV2VolumescloneGetallOptions.Filter))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumesClones)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2VolumesclonePost : Create a new volumes clone request and initiates the Prepare action
// Requires a minimum of two volumes.  Requires a minimum of one volume to be in the `in-use` state.  Requires a unique
// volumes clone name.  Prepare action does the preparatory work for creating the snapshot volumes.
// >**Note**: If there is an existing prepare, user cannot trigger another prepare for the same set of volumes. Prepare
// should be followed by start and execute. If existing prepare does not have to be used then it should be first
// cancelled before the next prepare operation.
func (powervs *PowervsV1) PcloudV2VolumesclonePost(pcloudV2VolumesclonePostOptions *PcloudV2VolumesclonePostOptions) (result *VolumesClone, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2VolumesclonePostWithContext(context.Background(), pcloudV2VolumesclonePostOptions)
}

// PcloudV2VolumesclonePostWithContext is an alternate form of the PcloudV2VolumesclonePost method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2VolumesclonePostWithContext(ctx context.Context, pcloudV2VolumesclonePostOptions *PcloudV2VolumesclonePostOptions) (result *VolumesClone, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2VolumesclonePostOptions, "pcloudV2VolumesclonePostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2VolumesclonePostOptions, "pcloudV2VolumesclonePostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2VolumesclonePostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/volumes-clone`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2VolumesclonePostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2VolumesclonePost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudV2VolumesclonePostOptions.Name != nil {
		body["name"] = pcloudV2VolumesclonePostOptions.Name
	}
	if pcloudV2VolumesclonePostOptions.VolumeIDs != nil {
		body["volumeIDs"] = pcloudV2VolumesclonePostOptions.VolumeIDs
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumesClone)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2VolumescloneDelete : Delete a volumes-clone request
func (powervs *PowervsV1) PcloudV2VolumescloneDelete(pcloudV2VolumescloneDeleteOptions *PcloudV2VolumescloneDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2VolumescloneDeleteWithContext(context.Background(), pcloudV2VolumescloneDeleteOptions)
}

// PcloudV2VolumescloneDeleteWithContext is an alternate form of the PcloudV2VolumescloneDelete method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2VolumescloneDeleteWithContext(ctx context.Context, pcloudV2VolumescloneDeleteOptions *PcloudV2VolumescloneDeleteOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2VolumescloneDeleteOptions, "pcloudV2VolumescloneDeleteOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2VolumescloneDeleteOptions, "pcloudV2VolumescloneDeleteOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2VolumescloneDeleteOptions.CloudInstanceID,
		"volumes_clone_id": *pcloudV2VolumescloneDeleteOptions.VolumesCloneID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/volumes-clone/{volumes_clone_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2VolumescloneDeleteOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2VolumescloneDelete")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2VolumescloneGet : Get the details for a volumes-clone request
func (powervs *PowervsV1) PcloudV2VolumescloneGet(pcloudV2VolumescloneGetOptions *PcloudV2VolumescloneGetOptions) (result *VolumesCloneDetail, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2VolumescloneGetWithContext(context.Background(), pcloudV2VolumescloneGetOptions)
}

// PcloudV2VolumescloneGetWithContext is an alternate form of the PcloudV2VolumescloneGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2VolumescloneGetWithContext(ctx context.Context, pcloudV2VolumescloneGetOptions *PcloudV2VolumescloneGetOptions) (result *VolumesCloneDetail, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2VolumescloneGetOptions, "pcloudV2VolumescloneGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2VolumescloneGetOptions, "pcloudV2VolumescloneGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2VolumescloneGetOptions.CloudInstanceID,
		"volumes_clone_id": *pcloudV2VolumescloneGetOptions.VolumesCloneID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/volumes-clone/{volumes_clone_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2VolumescloneGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2VolumescloneGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumesCloneDetail)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2VolumescloneCancelPost : Cancel a volumes-clone request
// Initiates the cleanup action that performs the cleanup of the preparatory clones and snapshot volumes.
func (powervs *PowervsV1) PcloudV2VolumescloneCancelPost(pcloudV2VolumescloneCancelPostOptions *PcloudV2VolumescloneCancelPostOptions) (result *VolumesClone, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2VolumescloneCancelPostWithContext(context.Background(), pcloudV2VolumescloneCancelPostOptions)
}

// PcloudV2VolumescloneCancelPostWithContext is an alternate form of the PcloudV2VolumescloneCancelPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2VolumescloneCancelPostWithContext(ctx context.Context, pcloudV2VolumescloneCancelPostOptions *PcloudV2VolumescloneCancelPostOptions) (result *VolumesClone, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2VolumescloneCancelPostOptions, "pcloudV2VolumescloneCancelPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2VolumescloneCancelPostOptions, "pcloudV2VolumescloneCancelPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2VolumescloneCancelPostOptions.CloudInstanceID,
		"volumes_clone_id": *pcloudV2VolumescloneCancelPostOptions.VolumesCloneID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/volumes-clone/{volumes_clone_id}/cancel`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2VolumescloneCancelPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2VolumescloneCancelPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudV2VolumescloneCancelPostOptions.Force != nil {
		body["force"] = pcloudV2VolumescloneCancelPostOptions.Force
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumesClone)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2VolumescloneExecutePost : Initiate the Execute action for a volumes-clone request
// Execute action creates the cloned volumes using the volume snapshots.
func (powervs *PowervsV1) PcloudV2VolumescloneExecutePost(pcloudV2VolumescloneExecutePostOptions *PcloudV2VolumescloneExecutePostOptions) (result *VolumesClone, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2VolumescloneExecutePostWithContext(context.Background(), pcloudV2VolumescloneExecutePostOptions)
}

// PcloudV2VolumescloneExecutePostWithContext is an alternate form of the PcloudV2VolumescloneExecutePost method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2VolumescloneExecutePostWithContext(ctx context.Context, pcloudV2VolumescloneExecutePostOptions *PcloudV2VolumescloneExecutePostOptions) (result *VolumesClone, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2VolumescloneExecutePostOptions, "pcloudV2VolumescloneExecutePostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2VolumescloneExecutePostOptions, "pcloudV2VolumescloneExecutePostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2VolumescloneExecutePostOptions.CloudInstanceID,
		"volumes_clone_id": *pcloudV2VolumescloneExecutePostOptions.VolumesCloneID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/volumes-clone/{volumes_clone_id}/execute`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2VolumescloneExecutePostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2VolumescloneExecutePost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudV2VolumescloneExecutePostOptions.Name != nil {
		body["name"] = pcloudV2VolumescloneExecutePostOptions.Name
	}
	if pcloudV2VolumescloneExecutePostOptions.RollbackPrepare != nil {
		body["rollbackPrepare"] = pcloudV2VolumescloneExecutePostOptions.RollbackPrepare
	}
	if pcloudV2VolumescloneExecutePostOptions.TargetReplicationEnabled != nil {
		body["targetReplicationEnabled"] = pcloudV2VolumescloneExecutePostOptions.TargetReplicationEnabled
	}
	if pcloudV2VolumescloneExecutePostOptions.TargetStorageTier != nil {
		body["targetStorageTier"] = pcloudV2VolumescloneExecutePostOptions.TargetStorageTier
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumesClone)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2VolumescloneStartPost : Initiate the Start action for a volumes-clone request
// Start action starts the consistency group to initiate the flash copy.
func (powervs *PowervsV1) PcloudV2VolumescloneStartPost(pcloudV2VolumescloneStartPostOptions *PcloudV2VolumescloneStartPostOptions) (result *VolumesClone, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2VolumescloneStartPostWithContext(context.Background(), pcloudV2VolumescloneStartPostOptions)
}

// PcloudV2VolumescloneStartPostWithContext is an alternate form of the PcloudV2VolumescloneStartPost method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2VolumescloneStartPostWithContext(ctx context.Context, pcloudV2VolumescloneStartPostOptions *PcloudV2VolumescloneStartPostOptions) (result *VolumesClone, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2VolumescloneStartPostOptions, "pcloudV2VolumescloneStartPostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2VolumescloneStartPostOptions, "pcloudV2VolumescloneStartPostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2VolumescloneStartPostOptions.CloudInstanceID,
		"volumes_clone_id": *pcloudV2VolumescloneStartPostOptions.VolumesCloneID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/volumes-clone/{volumes_clone_id}/start`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2VolumescloneStartPostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2VolumescloneStartPost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalVolumesClone)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2VolumesClonePost : Create a volume clone for specified volumes
func (powervs *PowervsV1) PcloudV2VolumesClonePost(pcloudV2VolumesClonePostOptions *PcloudV2VolumesClonePostOptions) (result *CloneTaskReference, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2VolumesClonePostWithContext(context.Background(), pcloudV2VolumesClonePostOptions)
}

// PcloudV2VolumesClonePostWithContext is an alternate form of the PcloudV2VolumesClonePost method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2VolumesClonePostWithContext(ctx context.Context, pcloudV2VolumesClonePostOptions *PcloudV2VolumesClonePostOptions) (result *CloneTaskReference, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2VolumesClonePostOptions, "pcloudV2VolumesClonePostOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2VolumesClonePostOptions, "pcloudV2VolumesClonePostOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2VolumesClonePostOptions.CloudInstanceID,
	}

	builder := core.NewRequestBuilder(core.POST)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/volumes/clone`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2VolumesClonePostOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2VolumesClonePost")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")

	body := make(map[string]interface{})
	if pcloudV2VolumesClonePostOptions.Name != nil {
		body["name"] = pcloudV2VolumesClonePostOptions.Name
	}
	if pcloudV2VolumesClonePostOptions.VolumeIDs != nil {
		body["volumeIDs"] = pcloudV2VolumesClonePostOptions.VolumeIDs
	}
	if pcloudV2VolumesClonePostOptions.TargetReplicationEnabled != nil {
		body["targetReplicationEnabled"] = pcloudV2VolumesClonePostOptions.TargetReplicationEnabled
	}
	if pcloudV2VolumesClonePostOptions.TargetStorageTier != nil {
		body["targetStorageTier"] = pcloudV2VolumesClonePostOptions.TargetStorageTier
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCloneTaskReference)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// PcloudV2VolumesClonetasksGet : Get the status of a volumes clone request for the specified clone task ID
func (powervs *PowervsV1) PcloudV2VolumesClonetasksGet(pcloudV2VolumesClonetasksGetOptions *PcloudV2VolumesClonetasksGetOptions) (result *CloneTaskStatus, response *core.DetailedResponse, err error) {
	return powervs.PcloudV2VolumesClonetasksGetWithContext(context.Background(), pcloudV2VolumesClonetasksGetOptions)
}

// PcloudV2VolumesClonetasksGetWithContext is an alternate form of the PcloudV2VolumesClonetasksGet method which supports a Context parameter
func (powervs *PowervsV1) PcloudV2VolumesClonetasksGetWithContext(ctx context.Context, pcloudV2VolumesClonetasksGetOptions *PcloudV2VolumesClonetasksGetOptions) (result *CloneTaskStatus, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(pcloudV2VolumesClonetasksGetOptions, "pcloudV2VolumesClonetasksGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(pcloudV2VolumesClonetasksGetOptions, "pcloudV2VolumesClonetasksGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"cloud_instance_id": *pcloudV2VolumesClonetasksGetOptions.CloudInstanceID,
		"clone_task_id": *pcloudV2VolumesClonetasksGetOptions.CloneTaskID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/pcloud/v2/cloud-instances/{cloud_instance_id}/volumes/clone-tasks/{clone_task_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range pcloudV2VolumesClonetasksGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "PcloudV2VolumesClonetasksGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if pcloudV2VolumesClonetasksGetOptions.Accept != nil {
		builder.AddHeader("Accept", fmt.Sprint(*pcloudV2VolumesClonetasksGetOptions.Accept))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalCloneTaskStatus)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBindingUnbinding : deprovision of a service binding
func (powervs *PowervsV1) ServiceBindingUnbinding(serviceBindingUnbindingOptions *ServiceBindingUnbindingOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.ServiceBindingUnbindingWithContext(context.Background(), serviceBindingUnbindingOptions)
}

// ServiceBindingUnbindingWithContext is an alternate form of the ServiceBindingUnbinding method which supports a Context parameter
func (powervs *PowervsV1) ServiceBindingUnbindingWithContext(ctx context.Context, serviceBindingUnbindingOptions *ServiceBindingUnbindingOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceBindingUnbindingOptions, "serviceBindingUnbindingOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceBindingUnbindingOptions, "serviceBindingUnbindingOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *serviceBindingUnbindingOptions.InstanceID,
		"binding_id": *serviceBindingUnbindingOptions.BindingID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/v2/service_instances/{instance_id}/service_bindings/{binding_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBindingUnbindingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBindingUnbinding")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if serviceBindingUnbindingOptions.XBrokerApiVersion != nil {
		builder.AddHeader("X-Broker-API-Version", fmt.Sprint(*serviceBindingUnbindingOptions.XBrokerApiVersion))
	}
	if serviceBindingUnbindingOptions.XBrokerApiOriginatingIdentity != nil {
		builder.AddHeader("X-Broker-API-Originating-Identity", fmt.Sprint(*serviceBindingUnbindingOptions.XBrokerApiOriginatingIdentity))
	}

	builder.AddQuery("service_id", fmt.Sprint(*serviceBindingUnbindingOptions.ServiceID))
	builder.AddQuery("plan_id", fmt.Sprint(*serviceBindingUnbindingOptions.PlanID))
	if serviceBindingUnbindingOptions.AcceptsIncomplete != nil {
		builder.AddQuery("accepts_incomplete", fmt.Sprint(*serviceBindingUnbindingOptions.AcceptsIncomplete))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBindingGet : gets a service binding
func (powervs *PowervsV1) ServiceBindingGet(serviceBindingGetOptions *ServiceBindingGetOptions) (result *ServiceBindingResource, response *core.DetailedResponse, err error) {
	return powervs.ServiceBindingGetWithContext(context.Background(), serviceBindingGetOptions)
}

// ServiceBindingGetWithContext is an alternate form of the ServiceBindingGet method which supports a Context parameter
func (powervs *PowervsV1) ServiceBindingGetWithContext(ctx context.Context, serviceBindingGetOptions *ServiceBindingGetOptions) (result *ServiceBindingResource, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceBindingGetOptions, "serviceBindingGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceBindingGetOptions, "serviceBindingGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *serviceBindingGetOptions.InstanceID,
		"binding_id": *serviceBindingGetOptions.BindingID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/v2/service_instances/{instance_id}/service_bindings/{binding_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBindingGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBindingGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if serviceBindingGetOptions.XBrokerApiVersion != nil {
		builder.AddHeader("X-Broker-API-Version", fmt.Sprint(*serviceBindingGetOptions.XBrokerApiVersion))
	}
	if serviceBindingGetOptions.XBrokerApiOriginatingIdentity != nil {
		builder.AddHeader("X-Broker-API-Originating-Identity", fmt.Sprint(*serviceBindingGetOptions.XBrokerApiOriginatingIdentity))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalServiceBindingResource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBindingBinding : generation of a service binding
func (powervs *PowervsV1) ServiceBindingBinding(serviceBindingBindingOptions *ServiceBindingBindingOptions) (result *ServiceBinding, response *core.DetailedResponse, err error) {
	return powervs.ServiceBindingBindingWithContext(context.Background(), serviceBindingBindingOptions)
}

// ServiceBindingBindingWithContext is an alternate form of the ServiceBindingBinding method which supports a Context parameter
func (powervs *PowervsV1) ServiceBindingBindingWithContext(ctx context.Context, serviceBindingBindingOptions *ServiceBindingBindingOptions) (result *ServiceBinding, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceBindingBindingOptions, "serviceBindingBindingOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceBindingBindingOptions, "serviceBindingBindingOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *serviceBindingBindingOptions.InstanceID,
		"binding_id": *serviceBindingBindingOptions.BindingID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/v2/service_instances/{instance_id}/service_bindings/{binding_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBindingBindingOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBindingBinding")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if serviceBindingBindingOptions.XBrokerApiVersion != nil {
		builder.AddHeader("X-Broker-API-Version", fmt.Sprint(*serviceBindingBindingOptions.XBrokerApiVersion))
	}
	if serviceBindingBindingOptions.XBrokerApiOriginatingIdentity != nil {
		builder.AddHeader("X-Broker-API-Originating-Identity", fmt.Sprint(*serviceBindingBindingOptions.XBrokerApiOriginatingIdentity))
	}

	if serviceBindingBindingOptions.AcceptsIncomplete != nil {
		builder.AddQuery("accepts_incomplete", fmt.Sprint(*serviceBindingBindingOptions.AcceptsIncomplete))
	}

	body := make(map[string]interface{})
	if serviceBindingBindingOptions.PlanID != nil {
		body["plan_id"] = serviceBindingBindingOptions.PlanID
	}
	if serviceBindingBindingOptions.ServiceID != nil {
		body["service_id"] = serviceBindingBindingOptions.ServiceID
	}
	if serviceBindingBindingOptions.AppGuid != nil {
		body["app_guid"] = serviceBindingBindingOptions.AppGuid
	}
	if serviceBindingBindingOptions.BindResource != nil {
		body["bind_resource"] = serviceBindingBindingOptions.BindResource
	}
	if serviceBindingBindingOptions.Context != nil {
		body["context"] = serviceBindingBindingOptions.Context
	}
	if serviceBindingBindingOptions.Parameters != nil {
		body["parameters"] = serviceBindingBindingOptions.Parameters
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalServiceBinding)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBindingLastOperationGet : last requested operation state for service binding
func (powervs *PowervsV1) ServiceBindingLastOperationGet(serviceBindingLastOperationGetOptions *ServiceBindingLastOperationGetOptions) (result *LastOperationResource, response *core.DetailedResponse, err error) {
	return powervs.ServiceBindingLastOperationGetWithContext(context.Background(), serviceBindingLastOperationGetOptions)
}

// ServiceBindingLastOperationGetWithContext is an alternate form of the ServiceBindingLastOperationGet method which supports a Context parameter
func (powervs *PowervsV1) ServiceBindingLastOperationGetWithContext(ctx context.Context, serviceBindingLastOperationGetOptions *ServiceBindingLastOperationGetOptions) (result *LastOperationResource, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceBindingLastOperationGetOptions, "serviceBindingLastOperationGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceBindingLastOperationGetOptions, "serviceBindingLastOperationGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *serviceBindingLastOperationGetOptions.InstanceID,
		"binding_id": *serviceBindingLastOperationGetOptions.BindingID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/v2/service_instances/{instance_id}/service_bindings/{binding_id}/last_operation`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBindingLastOperationGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBindingLastOperationGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if serviceBindingLastOperationGetOptions.XBrokerApiVersion != nil {
		builder.AddHeader("X-Broker-API-Version", fmt.Sprint(*serviceBindingLastOperationGetOptions.XBrokerApiVersion))
	}

	if serviceBindingLastOperationGetOptions.ServiceID != nil {
		builder.AddQuery("service_id", fmt.Sprint(*serviceBindingLastOperationGetOptions.ServiceID))
	}
	if serviceBindingLastOperationGetOptions.PlanID != nil {
		builder.AddQuery("plan_id", fmt.Sprint(*serviceBindingLastOperationGetOptions.PlanID))
	}
	if serviceBindingLastOperationGetOptions.Operation != nil {
		builder.AddQuery("operation", fmt.Sprint(*serviceBindingLastOperationGetOptions.Operation))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLastOperationResource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceInstanceDeprovision : deprovision a service instance
func (powervs *PowervsV1) ServiceInstanceDeprovision(serviceInstanceDeprovisionOptions *ServiceInstanceDeprovisionOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.ServiceInstanceDeprovisionWithContext(context.Background(), serviceInstanceDeprovisionOptions)
}

// ServiceInstanceDeprovisionWithContext is an alternate form of the ServiceInstanceDeprovision method which supports a Context parameter
func (powervs *PowervsV1) ServiceInstanceDeprovisionWithContext(ctx context.Context, serviceInstanceDeprovisionOptions *ServiceInstanceDeprovisionOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceInstanceDeprovisionOptions, "serviceInstanceDeprovisionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceInstanceDeprovisionOptions, "serviceInstanceDeprovisionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *serviceInstanceDeprovisionOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.DELETE)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/v2/service_instances/{instance_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceInstanceDeprovisionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceInstanceDeprovision")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if serviceInstanceDeprovisionOptions.XBrokerApiVersion != nil {
		builder.AddHeader("X-Broker-API-Version", fmt.Sprint(*serviceInstanceDeprovisionOptions.XBrokerApiVersion))
	}
	if serviceInstanceDeprovisionOptions.XBrokerApiOriginatingIdentity != nil {
		builder.AddHeader("X-Broker-API-Originating-Identity", fmt.Sprint(*serviceInstanceDeprovisionOptions.XBrokerApiOriginatingIdentity))
	}

	builder.AddQuery("service_id", fmt.Sprint(*serviceInstanceDeprovisionOptions.ServiceID))
	builder.AddQuery("plan_id", fmt.Sprint(*serviceInstanceDeprovisionOptions.PlanID))
	if serviceInstanceDeprovisionOptions.AcceptsIncomplete != nil {
		builder.AddQuery("accepts_incomplete", fmt.Sprint(*serviceInstanceDeprovisionOptions.AcceptsIncomplete))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceInstanceGet : gets a service instance
func (powervs *PowervsV1) ServiceInstanceGet(serviceInstanceGetOptions *ServiceInstanceGetOptions) (result *ServiceInstanceResource, response *core.DetailedResponse, err error) {
	return powervs.ServiceInstanceGetWithContext(context.Background(), serviceInstanceGetOptions)
}

// ServiceInstanceGetWithContext is an alternate form of the ServiceInstanceGet method which supports a Context parameter
func (powervs *PowervsV1) ServiceInstanceGetWithContext(ctx context.Context, serviceInstanceGetOptions *ServiceInstanceGetOptions) (result *ServiceInstanceResource, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceInstanceGetOptions, "serviceInstanceGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceInstanceGetOptions, "serviceInstanceGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *serviceInstanceGetOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/v2/service_instances/{instance_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceInstanceGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceInstanceGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if serviceInstanceGetOptions.XBrokerApiVersion != nil {
		builder.AddHeader("X-Broker-API-Version", fmt.Sprint(*serviceInstanceGetOptions.XBrokerApiVersion))
	}
	if serviceInstanceGetOptions.XBrokerApiOriginatingIdentity != nil {
		builder.AddHeader("X-Broker-API-Originating-Identity", fmt.Sprint(*serviceInstanceGetOptions.XBrokerApiOriginatingIdentity))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalServiceInstanceResource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceInstanceUpdate : update a service instance
func (powervs *PowervsV1) ServiceInstanceUpdate(serviceInstanceUpdateOptions *ServiceInstanceUpdateOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.ServiceInstanceUpdateWithContext(context.Background(), serviceInstanceUpdateOptions)
}

// ServiceInstanceUpdateWithContext is an alternate form of the ServiceInstanceUpdate method which supports a Context parameter
func (powervs *PowervsV1) ServiceInstanceUpdateWithContext(ctx context.Context, serviceInstanceUpdateOptions *ServiceInstanceUpdateOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceInstanceUpdateOptions, "serviceInstanceUpdateOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceInstanceUpdateOptions, "serviceInstanceUpdateOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *serviceInstanceUpdateOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.PATCH)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/v2/service_instances/{instance_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceInstanceUpdateOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceInstanceUpdate")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if serviceInstanceUpdateOptions.XBrokerApiVersion != nil {
		builder.AddHeader("X-Broker-API-Version", fmt.Sprint(*serviceInstanceUpdateOptions.XBrokerApiVersion))
	}
	if serviceInstanceUpdateOptions.XBrokerApiOriginatingIdentity != nil {
		builder.AddHeader("X-Broker-API-Originating-Identity", fmt.Sprint(*serviceInstanceUpdateOptions.XBrokerApiOriginatingIdentity))
	}

	if serviceInstanceUpdateOptions.AcceptsIncomplete != nil {
		builder.AddQuery("accepts_incomplete", fmt.Sprint(*serviceInstanceUpdateOptions.AcceptsIncomplete))
	}

	body := make(map[string]interface{})
	if serviceInstanceUpdateOptions.ServiceID != nil {
		body["service_id"] = serviceInstanceUpdateOptions.ServiceID
	}
	if serviceInstanceUpdateOptions.Context != nil {
		body["context"] = serviceInstanceUpdateOptions.Context
	}
	if serviceInstanceUpdateOptions.Parameters != nil {
		body["parameters"] = serviceInstanceUpdateOptions.Parameters
	}
	if serviceInstanceUpdateOptions.PlanID != nil {
		body["plan_id"] = serviceInstanceUpdateOptions.PlanID
	}
	if serviceInstanceUpdateOptions.PreviousValues != nil {
		body["previous_values"] = serviceInstanceUpdateOptions.PreviousValues
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceInstanceProvision : provision a service instance
func (powervs *PowervsV1) ServiceInstanceProvision(serviceInstanceProvisionOptions *ServiceInstanceProvisionOptions) (result *ServiceInstanceProvision, response *core.DetailedResponse, err error) {
	return powervs.ServiceInstanceProvisionWithContext(context.Background(), serviceInstanceProvisionOptions)
}

// ServiceInstanceProvisionWithContext is an alternate form of the ServiceInstanceProvision method which supports a Context parameter
func (powervs *PowervsV1) ServiceInstanceProvisionWithContext(ctx context.Context, serviceInstanceProvisionOptions *ServiceInstanceProvisionOptions) (result *ServiceInstanceProvision, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceInstanceProvisionOptions, "serviceInstanceProvisionOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceInstanceProvisionOptions, "serviceInstanceProvisionOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *serviceInstanceProvisionOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.PUT)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/v2/service_instances/{instance_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceInstanceProvisionOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceInstanceProvision")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	builder.AddHeader("Content-Type", "application/json")
	if serviceInstanceProvisionOptions.XBrokerApiVersion != nil {
		builder.AddHeader("X-Broker-API-Version", fmt.Sprint(*serviceInstanceProvisionOptions.XBrokerApiVersion))
	}
	if serviceInstanceProvisionOptions.XBrokerApiOriginatingIdentity != nil {
		builder.AddHeader("X-Broker-API-Originating-Identity", fmt.Sprint(*serviceInstanceProvisionOptions.XBrokerApiOriginatingIdentity))
	}

	if serviceInstanceProvisionOptions.AcceptsIncomplete != nil {
		builder.AddQuery("accepts_incomplete", fmt.Sprint(*serviceInstanceProvisionOptions.AcceptsIncomplete))
	}

	body := make(map[string]interface{})
	if serviceInstanceProvisionOptions.PlanID != nil {
		body["plan_id"] = serviceInstanceProvisionOptions.PlanID
	}
	if serviceInstanceProvisionOptions.ServiceID != nil {
		body["service_id"] = serviceInstanceProvisionOptions.ServiceID
	}
	if serviceInstanceProvisionOptions.Context != nil {
		body["context"] = serviceInstanceProvisionOptions.Context
	}
	if serviceInstanceProvisionOptions.OrganizationGuid != nil {
		body["organization_guid"] = serviceInstanceProvisionOptions.OrganizationGuid
	}
	if serviceInstanceProvisionOptions.Parameters != nil {
		body["parameters"] = serviceInstanceProvisionOptions.Parameters
	}
	if serviceInstanceProvisionOptions.SpaceGuid != nil {
		body["space_guid"] = serviceInstanceProvisionOptions.SpaceGuid
	}
	_, err = builder.SetBodyContentJSON(body)
	if err != nil {
		return
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalServiceInstanceProvision)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceInstanceLastOperationGet : last requested operation state for service instance
func (powervs *PowervsV1) ServiceInstanceLastOperationGet(serviceInstanceLastOperationGetOptions *ServiceInstanceLastOperationGetOptions) (result *LastOperationResource, response *core.DetailedResponse, err error) {
	return powervs.ServiceInstanceLastOperationGetWithContext(context.Background(), serviceInstanceLastOperationGetOptions)
}

// ServiceInstanceLastOperationGetWithContext is an alternate form of the ServiceInstanceLastOperationGet method which supports a Context parameter
func (powervs *PowervsV1) ServiceInstanceLastOperationGetWithContext(ctx context.Context, serviceInstanceLastOperationGetOptions *ServiceInstanceLastOperationGetOptions) (result *LastOperationResource, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(serviceInstanceLastOperationGetOptions, "serviceInstanceLastOperationGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(serviceInstanceLastOperationGetOptions, "serviceInstanceLastOperationGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"instance_id": *serviceInstanceLastOperationGetOptions.InstanceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/v2/service_instances/{instance_id}/last_operation`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceInstanceLastOperationGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceInstanceLastOperationGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if serviceInstanceLastOperationGetOptions.XBrokerApiVersion != nil {
		builder.AddHeader("X-Broker-API-Version", fmt.Sprint(*serviceInstanceLastOperationGetOptions.XBrokerApiVersion))
	}

	if serviceInstanceLastOperationGetOptions.ServiceID != nil {
		builder.AddQuery("service_id", fmt.Sprint(*serviceInstanceLastOperationGetOptions.ServiceID))
	}
	if serviceInstanceLastOperationGetOptions.PlanID != nil {
		builder.AddQuery("plan_id", fmt.Sprint(*serviceInstanceLastOperationGetOptions.PlanID))
	}
	if serviceInstanceLastOperationGetOptions.Operation != nil {
		builder.AddQuery("operation", fmt.Sprint(*serviceInstanceLastOperationGetOptions.Operation))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalLastOperationResource)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerStoragetypesGet : Available storage types in a region
// This API is deprecated for /pcloud/v1/cloud-instances/{cloud_instance_id}/storage-tiers.
//
// >*Note*: Support for this API will be available till 31st October 2023.
// Deprecated: this method is deprecated and may be removed in a future release.
func (powervs *PowervsV1) ServiceBrokerStoragetypesGet(serviceBrokerStoragetypesGetOptions *ServiceBrokerStoragetypesGetOptions) (result map[string][]StorageType, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerStoragetypesGetWithContext(context.Background(), serviceBrokerStoragetypesGetOptions)
}

// ServiceBrokerStoragetypesGetWithContext is an alternate form of the ServiceBrokerStoragetypesGet method which supports a Context parameter
// Deprecated: this method is deprecated and may be removed in a future release.
func (powervs *PowervsV1) ServiceBrokerStoragetypesGetWithContext(ctx context.Context, serviceBrokerStoragetypesGetOptions *ServiceBrokerStoragetypesGetOptions) (result map[string][]StorageType, response *core.DetailedResponse, err error) {
	core.GetLogger().Warn("A deprecated operation has been invoked: ServiceBrokerStoragetypesGet")
	err = core.ValidateStruct(serviceBrokerStoragetypesGetOptions, "serviceBrokerStoragetypesGetOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/broker/v1/storage-types`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerStoragetypesGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerStoragetypesGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalStorageType)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// ServiceBrokerSwaggerspec : Get swagger json spec
func (powervs *PowervsV1) ServiceBrokerSwaggerspec(serviceBrokerSwaggerspecOptions *ServiceBrokerSwaggerspecOptions) (result *Object, response *core.DetailedResponse, err error) {
	return powervs.ServiceBrokerSwaggerspecWithContext(context.Background(), serviceBrokerSwaggerspecOptions)
}

// ServiceBrokerSwaggerspecWithContext is an alternate form of the ServiceBrokerSwaggerspec method which supports a Context parameter
func (powervs *PowervsV1) ServiceBrokerSwaggerspecWithContext(ctx context.Context, serviceBrokerSwaggerspecOptions *ServiceBrokerSwaggerspecOptions) (result *Object, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(serviceBrokerSwaggerspecOptions, "serviceBrokerSwaggerspecOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/v1/swagger.json`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range serviceBrokerSwaggerspecOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "ServiceBrokerSwaggerspec")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalObject)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// WorkspacesGetall : Get all Workspaces information and capabilities for a tenant
func (powervs *PowervsV1) WorkspacesGetall(v1WorkspacesGetallOptions *V1WorkspacesGetallOptions) (result *Workspaces, response *core.DetailedResponse, err error) {
	return powervs.WorkspacesGetallWithContext(context.Background(), v1WorkspacesGetallOptions)
}

// WorkspacesGetallWithContext is an alternate form of the WorkspacesGetall method which supports a Context parameter
func (powervs *PowervsV1) WorkspacesGetallWithContext(ctx context.Context, v1WorkspacesGetallOptions *V1WorkspacesGetallOptions) (result *Workspaces, response *core.DetailedResponse, err error) {
	err = core.ValidateStruct(v1WorkspacesGetallOptions, "v1WorkspacesGetallOptions")
	if err != nil {
		return
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/v1/workspaces`, nil)
	if err != nil {
		return
	}

	for headerName, headerValue := range v1WorkspacesGetallOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "WorkspacesGetall")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if v1WorkspacesGetallOptions.Accept != nil {
		builder.AddHeader("Accept", fmt.Sprint(*v1WorkspacesGetallOptions.Accept))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalWorkspaces)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// WorkspacesGet : Get a Workspace's information and capabilities
func (powervs *PowervsV1) WorkspacesGet(v1WorkspacesGetOptions *V1WorkspacesGetOptions) (result *Workspace, response *core.DetailedResponse, err error) {
	return powervs.WorkspacesGetWithContext(context.Background(), v1WorkspacesGetOptions)
}

// WorkspacesGetWithContext is an alternate form of the WorkspacesGet method which supports a Context parameter
func (powervs *PowervsV1) WorkspacesGetWithContext(ctx context.Context, v1WorkspacesGetOptions *V1WorkspacesGetOptions) (result *Workspace, response *core.DetailedResponse, err error) {
	err = core.ValidateNotNil(v1WorkspacesGetOptions, "v1WorkspacesGetOptions cannot be nil")
	if err != nil {
		return
	}
	err = core.ValidateStruct(v1WorkspacesGetOptions, "v1WorkspacesGetOptions")
	if err != nil {
		return
	}

	pathParamsMap := map[string]string{
		"workspace_id": *v1WorkspacesGetOptions.WorkspaceID,
	}

	builder := core.NewRequestBuilder(core.GET)
	builder = builder.WithContext(ctx)
	builder.EnableGzipCompression = powervs.GetEnableGzipCompression()
	_, err = builder.ResolveRequestURL(powervs.Service.Options.URL, `/v1/workspaces/{workspace_id}`, pathParamsMap)
	if err != nil {
		return
	}

	for headerName, headerValue := range v1WorkspacesGetOptions.Headers {
		builder.AddHeader(headerName, headerValue)
	}

	sdkHeaders := common.GetSdkHeaders("powervs", "V1", "WorkspacesGet")
	for headerName, headerValue := range sdkHeaders {
		builder.AddHeader(headerName, headerValue)
	}
	builder.AddHeader("Accept", "application/json")
	if v1WorkspacesGetOptions.Accept != nil {
		builder.AddHeader("Accept", fmt.Sprint(*v1WorkspacesGetOptions.Accept))
	}

	request, err := builder.Build()
	if err != nil {
		return
	}

	var rawResponse map[string]json.RawMessage
	response, err = powervs.Service.Request(request, &rawResponse)
	if err != nil {
		return
	}
	if rawResponse != nil {
		err = core.UnmarshalModel(rawResponse, "", &result, UnmarshalWorkspace)
		if err != nil {
			return
		}
		response.Result = result
	}

	return
}

// AccessToken : AccessToken struct
type AccessToken struct {
	// Access Token.
	AccessToken *string `json:"accessToken" validate:"required"`
}

// UnmarshalAccessToken unmarshals an instance of AccessToken from the specified map of raw messages.
func UnmarshalAccessToken(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AccessToken)
	err = core.UnmarshalPrimitive(m, "accessToken", &obj.AccessToken)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AuxiliaryVolumeForOnboarding : AuxiliaryVolumeForOnboarding struct
type AuxiliaryVolumeForOnboarding struct {
	// auxiliary volume name at storage host level.
	AuxVolumeName *string `json:"auxVolumeName" validate:"required"`

	// display name of auxVolumeName once onboarded,auxVolumeName will be set to display name if not provided.
	Name *string `json:"name,omitempty"`
}

// NewAuxiliaryVolumeForOnboarding : Instantiate AuxiliaryVolumeForOnboarding (Generic Model Constructor)
func (*PowervsV1) NewAuxiliaryVolumeForOnboarding(auxVolumeName string) (_model *AuxiliaryVolumeForOnboarding, err error) {
	_model = &AuxiliaryVolumeForOnboarding{
		AuxVolumeName: core.StringPtr(auxVolumeName),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalAuxiliaryVolumeForOnboarding unmarshals an instance of AuxiliaryVolumeForOnboarding from the specified map of raw messages.
func UnmarshalAuxiliaryVolumeForOnboarding(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AuxiliaryVolumeForOnboarding)
	err = core.UnmarshalPrimitive(m, "auxVolumeName", &obj.AuxVolumeName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// AuxiliaryVolumesForOnboarding : AuxiliaryVolumesForOnboarding struct
type AuxiliaryVolumesForOnboarding struct {
	AuxiliaryVolumes []AuxiliaryVolumeForOnboarding `json:"auxiliaryVolumes" validate:"required"`

	// CRN of source ServiceBroker instance from where auxiliary volumes need to be onboarded.
	SourceCRN *string `json:"sourceCRN" validate:"required"`
}

// NewAuxiliaryVolumesForOnboarding : Instantiate AuxiliaryVolumesForOnboarding (Generic Model Constructor)
func (*PowervsV1) NewAuxiliaryVolumesForOnboarding(auxiliaryVolumes []AuxiliaryVolumeForOnboarding, sourceCRN string) (_model *AuxiliaryVolumesForOnboarding, err error) {
	_model = &AuxiliaryVolumesForOnboarding{
		AuxiliaryVolumes: auxiliaryVolumes,
		SourceCRN: core.StringPtr(sourceCRN),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalAuxiliaryVolumesForOnboarding unmarshals an instance of AuxiliaryVolumesForOnboarding from the specified map of raw messages.
func UnmarshalAuxiliaryVolumesForOnboarding(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(AuxiliaryVolumesForOnboarding)
	err = core.UnmarshalModel(m, "auxiliaryVolumes", &obj.AuxiliaryVolumes, UnmarshalAuxiliaryVolumeForOnboarding)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceCRN", &obj.SourceCRN)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// BluemixServiceInstanceGetOptions : The BluemixServiceInstanceGet options.
type BluemixServiceInstanceGetOptions struct {
	// instance id of instance to provision.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewBluemixServiceInstanceGetOptions : Instantiate BluemixServiceInstanceGetOptions
func (*PowervsV1) NewBluemixServiceInstanceGetOptions(instanceID string) *BluemixServiceInstanceGetOptions {
	return &BluemixServiceInstanceGetOptions{
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *BluemixServiceInstanceGetOptions) SetInstanceID(instanceID string) *BluemixServiceInstanceGetOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *BluemixServiceInstanceGetOptions) SetHeaders(param map[string]string) *BluemixServiceInstanceGetOptions {
	options.Headers = param
	return options
}

// BluemixServiceInstancePutOptions : The BluemixServiceInstancePut options.
type BluemixServiceInstancePutOptions struct {
	// instance id of instance to provision.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// Indicates the current state of the service instance.
	Enabled *bool `json:"enabled" validate:"required"`

	// Optional string stating the reason code for the service instance state change. Valid values are BMX_ACCT_ACTIVATE,
	// BMX_SERVICE_INSTANCE_BELOW_CAP for enable calls, and BMX_ACCT_SUSPEND, BMX_SERVICE_INSTANCE_ABOVE_CAP for disable
	// calls.
	InitiatorID *string `json:"initiator_id,omitempty"`

	// Optional string showing the user id initiating the call.
	ReasonCode *string `json:"reason_code,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewBluemixServiceInstancePutOptions : Instantiate BluemixServiceInstancePutOptions
func (*PowervsV1) NewBluemixServiceInstancePutOptions(instanceID string, enabled bool) *BluemixServiceInstancePutOptions {
	return &BluemixServiceInstancePutOptions{
		InstanceID: core.StringPtr(instanceID),
		Enabled: core.BoolPtr(enabled),
	}
}

// SetInstanceID : Allow user to set InstanceID
func (_options *BluemixServiceInstancePutOptions) SetInstanceID(instanceID string) *BluemixServiceInstancePutOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetEnabled : Allow user to set Enabled
func (_options *BluemixServiceInstancePutOptions) SetEnabled(enabled bool) *BluemixServiceInstancePutOptions {
	_options.Enabled = core.BoolPtr(enabled)
	return _options
}

// SetInitiatorID : Allow user to set InitiatorID
func (_options *BluemixServiceInstancePutOptions) SetInitiatorID(initiatorID string) *BluemixServiceInstancePutOptions {
	_options.InitiatorID = core.StringPtr(initiatorID)
	return _options
}

// SetReasonCode : Allow user to set ReasonCode
func (_options *BluemixServiceInstancePutOptions) SetReasonCode(reasonCode string) *BluemixServiceInstancePutOptions {
	_options.ReasonCode = core.StringPtr(reasonCode)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *BluemixServiceInstancePutOptions) SetHeaders(param map[string]string) *BluemixServiceInstancePutOptions {
	options.Headers = param
	return options
}

// Catalog : Catalog struct
type Catalog struct {
	Services []Service `json:"services,omitempty"`
}

// UnmarshalCatalog unmarshals an instance of Catalog from the specified map of raw messages.
func UnmarshalCatalog(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Catalog)
	err = core.UnmarshalModel(m, "services", &obj.Services, UnmarshalService)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CatalogGetOptions : The CatalogGet options.
type CatalogGetOptions struct {
	// version number of the Service Broker API that the Platform will use.
	XBrokerApiVersion *string `json:"X-Broker-API-Version" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewCatalogGetOptions : Instantiate CatalogGetOptions
func (*PowervsV1) NewCatalogGetOptions(xBrokerApiVersion string) *CatalogGetOptions {
	return &CatalogGetOptions{
		XBrokerApiVersion: core.StringPtr(xBrokerApiVersion),
	}
}

// SetXBrokerApiVersion : Allow user to set XBrokerApiVersion
func (_options *CatalogGetOptions) SetXBrokerApiVersion(xBrokerApiVersion string) *CatalogGetOptions {
	_options.XBrokerApiVersion = core.StringPtr(xBrokerApiVersion)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *CatalogGetOptions) SetHeaders(param map[string]string) *CatalogGetOptions {
	options.Headers = param
	return options
}

// CloneTaskReference : CloneTaskReference struct
type CloneTaskReference struct {
	// ID of a long running PowerVC clone task.
	CloneTaskID *string `json:"cloneTaskID" validate:"required"`

	// Link to PowerVC clone task resource.
	Href *string `json:"href" validate:"required"`
}

// UnmarshalCloneTaskReference unmarshals an instance of CloneTaskReference from the specified map of raw messages.
func UnmarshalCloneTaskReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloneTaskReference)
	err = core.UnmarshalPrimitive(m, "cloneTaskID", &obj.CloneTaskID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloneTaskStatus : CloneTaskStatus struct
type CloneTaskStatus struct {
	// List of cloned volumes created from the clone volumes task.
	ClonedVolumes []ClonedVolume `json:"clonedVolumes,omitempty"`

	// The reason the clone volumes task has failed.
	FailedReason *string `json:"failedReason,omitempty"`

	// Snapshot completion percentage.
	PercentComplete *int64 `json:"percentComplete" validate:"required"`

	// Status of the clone volumes task.
	Status *string `json:"status" validate:"required"`
}

// Constants associated with the CloneTaskStatus.Status property.
// Status of the clone volumes task.
const (
	CloneTaskStatusStatusCompletedConst = "completed"
	CloneTaskStatusStatusFailedConst = "failed"
	CloneTaskStatusStatusRunningConst = "running"
	CloneTaskStatusStatusUnknownConst = "unknown"
)

// UnmarshalCloneTaskStatus unmarshals an instance of CloneTaskStatus from the specified map of raw messages.
func UnmarshalCloneTaskStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloneTaskStatus)
	err = core.UnmarshalModel(m, "clonedVolumes", &obj.ClonedVolumes, UnmarshalClonedVolume)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "failedReason", &obj.FailedReason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "percentComplete", &obj.PercentComplete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ClonedVolume : ClonedVolume struct
type ClonedVolume struct {
	// ID of the new cloned volume.
	ClonedVolumeID *string `json:"clonedVolumeID,omitempty"`

	// ID of the source volume to be cloned.
	SourceVolumeID *string `json:"sourceVolumeID,omitempty"`
}

// UnmarshalClonedVolume unmarshals an instance of ClonedVolume from the specified map of raw messages.
func UnmarshalClonedVolume(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ClonedVolume)
	err = core.UnmarshalPrimitive(m, "clonedVolumeID", &obj.ClonedVolumeID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceVolumeID", &obj.SourceVolumeID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ClonedVolumeDetail : ClonedVolumeDetail struct
type ClonedVolumeDetail struct {
	Clone *VolumeInfo `json:"clone" validate:"required"`

	Source *VolumeInfo `json:"source" validate:"required"`
}

// UnmarshalClonedVolumeDetail unmarshals an instance of ClonedVolumeDetail from the specified map of raw messages.
func UnmarshalClonedVolumeDetail(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ClonedVolumeDetail)
	err = core.UnmarshalModel(m, "clone", &obj.Clone, UnmarshalVolumeInfo)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "source", &obj.Source, UnmarshalVolumeInfo)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudConnection : CloudConnection struct
type CloudConnection struct {
	Classic *CloudConnectionEndpointClassic `json:"classic,omitempty"`

	// cloud connection ID.
	CloudConnectionID *string `json:"cloudConnectionID" validate:"required"`

	// type of service the gateway is attached to.
	ConnectionMode *string `json:"connectionMode,omitempty"`

	// creation date.
	CreationDate *strfmt.DateTime `json:"creationDate" validate:"required"`

	// enable global routing for this cloud connection (default=false).
	GlobalRouting *bool `json:"globalRouting" validate:"required"`

	// IBM IP address.
	IBMIPAddress *string `json:"ibmIPAddress" validate:"required"`

	// link status.
	LinkStatus *string `json:"linkStatus" validate:"required"`

	// metered.
	Metered *bool `json:"metered" validate:"required"`

	// name of the cloud connection.
	Name *string `json:"name" validate:"required"`

	// Network References.
	Networks []NetworkReference `json:"networks,omitempty"`

	// port.
	Port *string `json:"port" validate:"required"`

	// speed of the cloud connection (speed in megabits per second).
	Speed *int64 `json:"speed" validate:"required"`

	// user IP address.
	UserIPAddress *string `json:"userIPAddress" validate:"required"`

	VPC *CloudConnectionEndpointVPC `json:"vpc,omitempty"`
}

// UnmarshalCloudConnection unmarshals an instance of CloudConnection from the specified map of raw messages.
func UnmarshalCloudConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudConnection)
	err = core.UnmarshalModel(m, "classic", &obj.Classic, UnmarshalCloudConnectionEndpointClassic)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cloudConnectionID", &obj.CloudConnectionID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "connectionMode", &obj.ConnectionMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "creationDate", &obj.CreationDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "globalRouting", &obj.GlobalRouting)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ibmIPAddress", &obj.IBMIPAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "linkStatus", &obj.LinkStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metered", &obj.Metered)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "networks", &obj.Networks, UnmarshalNetworkReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "port", &obj.Port)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "speed", &obj.Speed)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "userIPAddress", &obj.UserIPAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpc", &obj.VPC, UnmarshalCloudConnectionEndpointVPC)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudConnectionEndpointClassic : CloudConnectionEndpointClassic struct
type CloudConnectionEndpointClassic struct {
	// enable classic endpoint destination (default=false).
	Enabled *bool `json:"enabled,omitempty"`

	Gre *CloudConnectionGreTunnel `json:"gre,omitempty"`
}

// UnmarshalCloudConnectionEndpointClassic unmarshals an instance of CloudConnectionEndpointClassic from the specified map of raw messages.
func UnmarshalCloudConnectionEndpointClassic(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudConnectionEndpointClassic)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "gre", &obj.Gre, UnmarshalCloudConnectionGreTunnel)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudConnectionEndpointClassicUpdate : CloudConnectionEndpointClassicUpdate struct
type CloudConnectionEndpointClassicUpdate struct {
	// enable classic endpoint destination (default=false).
	Enabled *bool `json:"enabled,omitempty"`

	Gre *CloudConnectionGreTunnelCreate `json:"gre,omitempty"`
}

// UnmarshalCloudConnectionEndpointClassicUpdate unmarshals an instance of CloudConnectionEndpointClassicUpdate from the specified map of raw messages.
func UnmarshalCloudConnectionEndpointClassicUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudConnectionEndpointClassicUpdate)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "gre", &obj.Gre, UnmarshalCloudConnectionGreTunnelCreate)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudConnectionEndpointVPC : CloudConnectionEndpointVPC struct
type CloudConnectionEndpointVPC struct {
	// enable vpc for this cloud connection (default=false).
	Enabled *bool `json:"enabled,omitempty"`

	// vpc connections.
	Vpcs []CloudConnectionVPC `json:"vpcs,omitempty"`
}

// UnmarshalCloudConnectionEndpointVPC unmarshals an instance of CloudConnectionEndpointVPC from the specified map of raw messages.
func UnmarshalCloudConnectionEndpointVPC(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudConnectionEndpointVPC)
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vpcs", &obj.Vpcs, UnmarshalCloudConnectionVPC)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudConnectionGreTunnel : CloudConnectionGreTunnel struct
type CloudConnectionGreTunnel struct {
	// gre destination IP address.
	DestIPAddress *string `json:"destIPAddress" validate:"required"`

	// gre auto-assigned source IP address.
	SourceIPAddress *string `json:"sourceIPAddress" validate:"required"`
}

// UnmarshalCloudConnectionGreTunnel unmarshals an instance of CloudConnectionGreTunnel from the specified map of raw messages.
func UnmarshalCloudConnectionGreTunnel(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudConnectionGreTunnel)
	err = core.UnmarshalPrimitive(m, "destIPAddress", &obj.DestIPAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceIPAddress", &obj.SourceIPAddress)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudConnectionGreTunnelCreate : CloudConnectionGreTunnelCreate struct
type CloudConnectionGreTunnelCreate struct {
	// gre network in CIDR notation (192.168.0.0/24).
	CIDR *string `json:"cidr" validate:"required"`

	// gre destination IP address.
	DestIPAddress *string `json:"destIPAddress" validate:"required"`
}

// NewCloudConnectionGreTunnelCreate : Instantiate CloudConnectionGreTunnelCreate (Generic Model Constructor)
func (*PowervsV1) NewCloudConnectionGreTunnelCreate(cidr string, destIPAddress string) (_model *CloudConnectionGreTunnelCreate, err error) {
	_model = &CloudConnectionGreTunnelCreate{
		CIDR: core.StringPtr(cidr),
		DestIPAddress: core.StringPtr(destIPAddress),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalCloudConnectionGreTunnelCreate unmarshals an instance of CloudConnectionGreTunnelCreate from the specified map of raw messages.
func UnmarshalCloudConnectionGreTunnelCreate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudConnectionGreTunnelCreate)
	err = core.UnmarshalPrimitive(m, "cidr", &obj.CIDR)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "destIPAddress", &obj.DestIPAddress)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudConnectionVPC : CloudConnectionVPC struct
type CloudConnectionVPC struct {
	// vpc name.
	Name *string `json:"name,omitempty"`

	// vpc id.
	VPCID *string `json:"vpcID" validate:"required"`
}

// NewCloudConnectionVPC : Instantiate CloudConnectionVPC (Generic Model Constructor)
func (*PowervsV1) NewCloudConnectionVPC(vpcID string) (_model *CloudConnectionVPC, err error) {
	_model = &CloudConnectionVPC{
		VPCID: core.StringPtr(vpcID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalCloudConnectionVPC unmarshals an instance of CloudConnectionVPC from the specified map of raw messages.
func UnmarshalCloudConnectionVPC(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudConnectionVPC)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vpcID", &obj.VPCID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudConnectionVirtualPrivateClouds : CloudConnectionVirtualPrivateClouds struct
type CloudConnectionVirtualPrivateClouds struct {
	// list of available virtual private clouds.
	VirtualPrivateClouds []CloudConnectionVirtualPrivateCloudsVirtualPrivateCloudsItem `json:"virtualPrivateClouds" validate:"required"`
}

// UnmarshalCloudConnectionVirtualPrivateClouds unmarshals an instance of CloudConnectionVirtualPrivateClouds from the specified map of raw messages.
func UnmarshalCloudConnectionVirtualPrivateClouds(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudConnectionVirtualPrivateClouds)
	err = core.UnmarshalModel(m, "virtualPrivateClouds", &obj.VirtualPrivateClouds, UnmarshalCloudConnectionVirtualPrivateCloudsVirtualPrivateCloudsItem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudConnectionVirtualPrivateCloudsVirtualPrivateCloudsItem : CloudConnectionVirtualPrivateCloudsVirtualPrivateCloudsItem struct
type CloudConnectionVirtualPrivateCloudsVirtualPrivateCloudsItem struct {
	// indicates if vpc uses classic architecture.
	ClassicAccess *bool `json:"classicAccess" validate:"required"`

	// name for the vpc.
	Name *string `json:"name" validate:"required"`

	// status of this vpc.
	Status *string `json:"status" validate:"required"`

	// virtual private cloud id.
	VPCID *string `json:"vpcID" validate:"required"`
}

// UnmarshalCloudConnectionVirtualPrivateCloudsVirtualPrivateCloudsItem unmarshals an instance of CloudConnectionVirtualPrivateCloudsVirtualPrivateCloudsItem from the specified map of raw messages.
func UnmarshalCloudConnectionVirtualPrivateCloudsVirtualPrivateCloudsItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudConnectionVirtualPrivateCloudsVirtualPrivateCloudsItem)
	err = core.UnmarshalPrimitive(m, "classicAccess", &obj.ClassicAccess)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vpcID", &obj.VPCID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudConnections : CloudConnections struct
type CloudConnections struct {
	// Cloud Connections.
	CloudConnections []CloudConnection `json:"cloudConnections" validate:"required"`
}

// UnmarshalCloudConnections unmarshals an instance of CloudConnections from the specified map of raw messages.
func UnmarshalCloudConnections(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudConnections)
	err = core.UnmarshalModel(m, "cloudConnections", &obj.CloudConnections, UnmarshalCloudConnection)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudInitialization : CloudInitialization struct
type CloudInitialization struct {
	// Virtual Machine's Cloud Initialization Virtual Optical Device.
	VirtualOpticalDevice *string `json:"virtualOpticalDevice,omitempty"`
}

// Constants associated with the CloudInitialization.VirtualOpticalDevice property.
// Virtual Machine's Cloud Initialization Virtual Optical Device.
const (
	CloudInitializationVirtualOpticalDeviceAttachConst = "attach"
	CloudInitializationVirtualOpticalDeviceDetachConst = "detach"
)

// UnmarshalCloudInitialization unmarshals an instance of CloudInitialization from the specified map of raw messages.
func UnmarshalCloudInitialization(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudInitialization)
	err = core.UnmarshalPrimitive(m, "virtualOpticalDevice", &obj.VirtualOpticalDevice)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudInstance : CloudInstance struct
type CloudInstance struct {
	// Cloud Instance Capabilities.
	Capabilities []string `json:"capabilities,omitempty"`

	// Cloud Instance ID.
	CloudInstanceID *string `json:"cloudInstanceID" validate:"required"`

	// Indicates if the cloud instance is enabled.
	Enabled *bool `json:"enabled" validate:"required"`

	// Indicates if the cloud instance is initialized and ready for use.
	Initialized *bool `json:"initialized" validate:"required"`

	Limits *CloudInstanceUsageLimits `json:"limits" validate:"required"`

	// Cloud Instance Name.
	Name *string `json:"name" validate:"required"`

	// The open stack ID that controls this cloud instance.
	OpenstackID *string `json:"openstackID" validate:"required"`

	// PVM instances owned by the Cloud Instance.
	PvmInstances []PvmInstanceReference `json:"pvmInstances" validate:"required"`

	// The region the cloud instance lives.
	Region *string `json:"region" validate:"required"`

	// The tenant ID that owns this cloud instance.
	TenantID *string `json:"tenantID" validate:"required"`

	Usage *CloudInstanceUsageLimits `json:"usage" validate:"required"`
}

// UnmarshalCloudInstance unmarshals an instance of CloudInstance from the specified map of raw messages.
func UnmarshalCloudInstance(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudInstance)
	err = core.UnmarshalPrimitive(m, "capabilities", &obj.Capabilities)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cloudInstanceID", &obj.CloudInstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "initialized", &obj.Initialized)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "limits", &obj.Limits, UnmarshalCloudInstanceUsageLimits)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "openstackID", &obj.OpenstackID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "pvmInstances", &obj.PvmInstances, UnmarshalPvmInstanceReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tenantID", &obj.TenantID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "usage", &obj.Usage, UnmarshalCloudInstanceUsageLimits)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudInstanceReference : CloudInstanceReference struct
type CloudInstanceReference struct {
	// Cloud Instance Capabilities.
	Capabilities []string `json:"capabilities,omitempty"`

	// Cloud Instance ID.
	CloudInstanceID *string `json:"cloudInstanceID" validate:"required"`

	// Indicates if the cloud instance is enabled.
	Enabled *bool `json:"enabled" validate:"required"`

	// Link to Cloud Instance resource.
	Href *string `json:"href" validate:"required"`

	// Indicates if the cloud instance is initialized and ready for use.
	Initialized *bool `json:"initialized" validate:"required"`

	Limits *CloudInstanceUsageLimits `json:"limits" validate:"required"`

	// Cloud Instance Name.
	Name *string `json:"name" validate:"required"`

	// The region the cloud instance lives.
	Region *string `json:"region" validate:"required"`
}

// UnmarshalCloudInstanceReference unmarshals an instance of CloudInstanceReference from the specified map of raw messages.
func UnmarshalCloudInstanceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudInstanceReference)
	err = core.UnmarshalPrimitive(m, "capabilities", &obj.Capabilities)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cloudInstanceID", &obj.CloudInstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "initialized", &obj.Initialized)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "limits", &obj.Limits, UnmarshalCloudInstanceUsageLimits)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// CloudInstanceUsageLimits : CloudInstanceUsageLimits struct
type CloudInstanceUsageLimits struct {
	// Maximum memory (in GB) per PVMInstance.
	InstanceMemory *float64 `json:"instanceMemory,omitempty"`

	// Maximum proc units per PVMInstance.
	InstanceProcUnits *float64 `json:"instanceProcUnits,omitempty"`

	// Number of power instances allowed.
	Instances *float64 `json:"instances" validate:"required"`

	// Amount of memory allowed.
	Memory *float64 `json:"memory" validate:"required"`

	// Maximum network bandwidth to GCP Mbps.
	PeeringBandwidth *int64 `json:"peeringBandwidth,omitempty"`

	// Amount of peering networks allowed.
	PeeringNetworks *int64 `json:"peeringNetworks,omitempty"`

	// Number of processor units allowed.
	ProcUnits *float64 `json:"procUnits" validate:"required"`

	// Number of processors allowed.
	Processors *float64 `json:"processors" validate:"required"`

	// Amount of storage allowed (TB).
	Storage *float64 `json:"storage" validate:"required"`

	// Amount of SSD storage allowed (TB).
	StorageSsd *float64 `json:"storageSSD,omitempty"`

	// Amount of standard (HDD) storage allowed (TB).
	StorageStandard *float64 `json:"storageStandard,omitempty"`
}

// UnmarshalCloudInstanceUsageLimits unmarshals an instance of CloudInstanceUsageLimits from the specified map of raw messages.
func UnmarshalCloudInstanceUsageLimits(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(CloudInstanceUsageLimits)
	err = core.UnmarshalPrimitive(m, "instanceMemory", &obj.InstanceMemory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instanceProcUnits", &obj.InstanceProcUnits)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instances", &obj.Instances)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peeringBandwidth", &obj.PeeringBandwidth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peeringNetworks", &obj.PeeringNetworks)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "procUnits", &obj.ProcUnits)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "processors", &obj.Processors)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storage", &obj.Storage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storageSSD", &obj.StorageSsd)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storageStandard", &obj.StorageStandard)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ConsoleLanguage : ConsoleLanguage struct
type ConsoleLanguage struct {
	// language code.
	Code *string `json:"code" validate:"required"`

	// language description.
	Language *string `json:"language,omitempty"`
}

// NewConsoleLanguage : Instantiate ConsoleLanguage (Generic Model Constructor)
func (*PowervsV1) NewConsoleLanguage(code string) (_model *ConsoleLanguage, err error) {
	_model = &ConsoleLanguage{
		Code: core.StringPtr(code),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalConsoleLanguage unmarshals an instance of ConsoleLanguage from the specified map of raw messages.
func UnmarshalConsoleLanguage(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ConsoleLanguage)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "language", &obj.Language)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ConsoleLanguages : ConsoleLanguages struct
type ConsoleLanguages struct {
	// console languages.
	ConsoleLanguages []ConsoleLanguage `json:"consoleLanguages" validate:"required"`
}

// UnmarshalConsoleLanguages unmarshals an instance of ConsoleLanguages from the specified map of raw messages.
func UnmarshalConsoleLanguages(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ConsoleLanguages)
	err = core.UnmarshalModel(m, "consoleLanguages", &obj.ConsoleLanguages, UnmarshalConsoleLanguage)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Context : See [Context
// Conventions](https://github.com/openservicebrokerapi/servicebroker/blob/master/profile.md#context-object) for more
// details.
type Context struct {

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// SetProperty allows the user to set an arbitrary property on an instance of Context
func (o *Context) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of Context
func (o *Context) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of Context
func (o *Context) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of Context
func (o *Context) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of Context
func (o *Context) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalContext unmarshals an instance of Context from the specified map of raw messages.
func UnmarshalContext(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Context)
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DhcpServer : DhcpServer struct
type DhcpServer struct {
	// The ID of the DHCP Server.
	ID *string `json:"id" validate:"required"`

	Network *DhcpServerNetwork `json:"network" validate:"required"`

	// The status of the DHCP Server.
	Status *string `json:"status" validate:"required"`
}

// UnmarshalDhcpServer unmarshals an instance of DhcpServer from the specified map of raw messages.
func UnmarshalDhcpServer(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DhcpServer)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network", &obj.Network, UnmarshalDhcpServerNetwork)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DhcpServerDetail : DhcpServerDetail struct
type DhcpServerDetail struct {
	// The ID of the DHCP Server.
	ID *string `json:"id" validate:"required"`

	// The list of DHCP Server PVM Instance leases.
	Leases []DhcpServerLeases `json:"leases,omitempty"`

	Network *DhcpServerNetwork `json:"network" validate:"required"`

	// The status of the DHCP Server.
	Status *string `json:"status" validate:"required"`
}

// UnmarshalDhcpServerDetail unmarshals an instance of DhcpServerDetail from the specified map of raw messages.
func UnmarshalDhcpServerDetail(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DhcpServerDetail)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "leases", &obj.Leases, UnmarshalDhcpServerLeases)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "network", &obj.Network, UnmarshalDhcpServerNetwork)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DhcpServerLeases : DhcpServerLeases struct
type DhcpServerLeases struct {
	// The IP of the PVM Instance.
	InstanceIP *string `json:"instanceIP" validate:"required"`

	// The MAC Address of the PVM Instance.
	InstanceMacAddress *string `json:"instanceMacAddress" validate:"required"`
}

// UnmarshalDhcpServerLeases unmarshals an instance of DhcpServerLeases from the specified map of raw messages.
func UnmarshalDhcpServerLeases(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DhcpServerLeases)
	err = core.UnmarshalPrimitive(m, "instanceIP", &obj.InstanceIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "instanceMacAddress", &obj.InstanceMacAddress)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DhcpServerNetwork : DhcpServerNetwork struct
type DhcpServerNetwork struct {
	// The ID of the network.
	ID *string `json:"id" validate:"required"`

	// The name of the network.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalDhcpServerNetwork unmarshals an instance of DhcpServerNetwork from the specified map of raw messages.
func UnmarshalDhcpServerNetwork(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DhcpServerNetwork)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DashboardClient : DashboardClient struct
type DashboardClient struct {
	ID *string `json:"id,omitempty"`

	RedirectURI *string `json:"redirect_uri,omitempty"`

	Secret *string `json:"secret,omitempty"`
}

// UnmarshalDashboardClient unmarshals an instance of DashboardClient from the specified map of raw messages.
func UnmarshalDashboardClient(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DashboardClient)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "redirect_uri", &obj.RedirectURI)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "secret", &obj.Secret)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Datacenter : Datacenter struct
type Datacenter struct {
	// Datacenter Capabilities.
	Capabilities map[string]bool `json:"capabilities" validate:"required"`

	// Link to Datacenter Region.
	Href *string `json:"href,omitempty"`

	Location *DatacenterLocation `json:"location" validate:"required"`

	// The Datacenter status.
	Status *string `json:"status" validate:"required"`

	// The Datacenter type.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the Datacenter.Status property.
// The Datacenter status.
const (
	DatacenterStatusActiveConst = "active"
	DatacenterStatusDownConst = "down"
	DatacenterStatusMaintenanceConst = "maintenance"
)

// Constants associated with the Datacenter.Type property.
// The Datacenter type.
const (
	DatacenterTypeOffPremisesConst = "off-premises"
	DatacenterTypeOnPremisesConst = "on-premises"
)

// UnmarshalDatacenter unmarshals an instance of Datacenter from the specified map of raw messages.
func UnmarshalDatacenter(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Datacenter)
	err = core.UnmarshalPrimitive(m, "capabilities", &obj.Capabilities)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "location", &obj.Location, UnmarshalDatacenterLocation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DatacenterLocation : DatacenterLocation struct
type DatacenterLocation struct {
	// The Datacenter location region zone.
	Region *string `json:"region" validate:"required"`

	// The Datacenter location region type.
	Type *string `json:"type" validate:"required"`

	// The Datacenter location region url.
	URL *string `json:"url" validate:"required"`
}

// UnmarshalDatacenterLocation unmarshals an instance of DatacenterLocation from the specified map of raw messages.
func UnmarshalDatacenterLocation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DatacenterLocation)
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Datacenters : Datacenters struct
type Datacenters struct {
	// Power Systems Virtual Server available Datacenters.
	Datacenters []Datacenter `json:"datacenters" validate:"required"`
}

// UnmarshalDatacenters unmarshals an instance of Datacenters from the specified map of raw messages.
func UnmarshalDatacenters(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Datacenters)
	err = core.UnmarshalModel(m, "datacenters", &obj.Datacenters, UnmarshalDatacenter)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DeadPeerDetection : Dead Peer Detection of the VPN Connection.
type DeadPeerDetection struct {
	// Action to take when a Peer Gateway stops responding.
	Action *string `json:"action" validate:"required"`

	// How often to test that the Peer Gateway is responsive.
	Interval *int64 `json:"interval" validate:"required"`

	// The number of attempts to connect before tearing down the connection.
	Threshold *int64 `json:"threshold" validate:"required"`
}

// Constants associated with the DeadPeerDetection.Action property.
// Action to take when a Peer Gateway stops responding.
const (
	DeadPeerDetectionActionRestartConst = "restart"
)

// UnmarshalDeadPeerDetection unmarshals an instance of DeadPeerDetection from the specified map of raw messages.
func UnmarshalDeadPeerDetection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DeadPeerDetection)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "threshold", &obj.Threshold)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DeviceCode : DeviceCode struct
type DeviceCode struct {
	// This code lets the device running the app securely determine whether the user has granted or denied access.
	DeviceCode *string `json:"deviceCode" validate:"required"`

	// The length of time, in seconds, that the device_code and user_code are valid.
	ExpiresIn *float64 `json:"expiresIn" validate:"required"`

	// The length of time, in seconds, that your device should wait between polling requests.
	Interval *float64 `json:"interval" validate:"required"`

	// The value given to the user to enter on device authentication page.
	UserCode *string `json:"userCode" validate:"required"`

	// A URL that the user must navigate to, on a separate device, to enter the user_code and grant or deny access to your
	// application. Your user interface will also display this value.
	VerificationURL *string `json:"verificationURL" validate:"required"`
}

// UnmarshalDeviceCode unmarshals an instance of DeviceCode from the specified map of raw messages.
func UnmarshalDeviceCode(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DeviceCode)
	err = core.UnmarshalPrimitive(m, "deviceCode", &obj.DeviceCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "expiresIn", &obj.ExpiresIn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "interval", &obj.Interval)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "userCode", &obj.UserCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "verificationURL", &obj.VerificationURL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DisasterRecoveryLocation : DisasterRecoveryLocation struct
type DisasterRecoveryLocation struct {
	// regionZone of a site.
	Location *string `json:"location,omitempty"`

	// list of Replication Sites.
	ReplicationSites []Site `json:"replicationSites,omitempty"`
}

// UnmarshalDisasterRecoveryLocation unmarshals an instance of DisasterRecoveryLocation from the specified map of raw messages.
func UnmarshalDisasterRecoveryLocation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DisasterRecoveryLocation)
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "replicationSites", &obj.ReplicationSites, UnmarshalSite)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// DisasterRecoveryLocations : DisasterRecoveryLocations struct
type DisasterRecoveryLocations struct {
	// The list of Disaster Recovery Locations.
	DisasterRecoveryLocations []DisasterRecoveryLocation `json:"disasterRecoveryLocations" validate:"required"`
}

// UnmarshalDisasterRecoveryLocations unmarshals an instance of DisasterRecoveryLocations from the specified map of raw messages.
func UnmarshalDisasterRecoveryLocations(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(DisasterRecoveryLocations)
	err = core.UnmarshalModel(m, "disasterRecoveryLocations", &obj.DisasterRecoveryLocations, UnmarshalDisasterRecoveryLocation)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Event : Event struct
type Event struct {
	// Type of action for this event.
	Action *string `json:"action" validate:"required"`

	// ID of the Activity.
	EventID *string `json:"eventID" validate:"required"`

	// Level of the event (notice, info, warning, error).
	Level *string `json:"level" validate:"required"`

	// The (translated) message of the event.
	Message *string `json:"message" validate:"required"`

	// Any metadata associated with the event.
	Metadata map[string]interface{} `json:"metadata,omitempty"`

	// Type of resource for this event.
	Resource *string `json:"resource" validate:"required"`

	// Time of activity in ISO 8601 - RFC3339.
	Time *strfmt.DateTime `json:"time" validate:"required"`

	// Time of activity in unix epoch.
	Timestamp *int64 `json:"timestamp" validate:"required"`

	User *EventUser `json:"user,omitempty"`
}

// Constants associated with the Event.Level property.
// Level of the event (notice, info, warning, error).
const (
	EventLevelErrorConst = "error"
	EventLevelInfoConst = "info"
	EventLevelNoticeConst = "notice"
	EventLevelWarningConst = "warning"
)

// UnmarshalEvent unmarshals an instance of Event from the specified map of raw messages.
func UnmarshalEvent(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Event)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "eventID", &obj.EventID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "level", &obj.Level)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "metadata", &obj.Metadata)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resource", &obj.Resource)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "time", &obj.Time)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "timestamp", &obj.Timestamp)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "user", &obj.User, UnmarshalEventUser)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// EventUser : EventUser struct
type EventUser struct {
	// Email of the User.
	Email *string `json:"email,omitempty"`

	// Name of the User.
	Name *string `json:"name,omitempty"`

	// ID of user who created/caused the event.
	UserID *string `json:"userID" validate:"required"`
}

// UnmarshalEventUser unmarshals an instance of EventUser from the specified map of raw messages.
func UnmarshalEventUser(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(EventUser)
	err = core.UnmarshalPrimitive(m, "email", &obj.Email)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "userID", &obj.UserID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Events : Events struct
type Events struct {
	// Events.
	Events []Event `json:"events" validate:"required"`
}

// UnmarshalEvents unmarshals an instance of Events from the specified map of raw messages.
func UnmarshalEvents(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Events)
	err = core.UnmarshalModel(m, "events", &obj.Events, UnmarshalEvent)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// FlashCopyMapping : FlashCopyMapping struct
type FlashCopyMapping struct {
	// Indicates the rate of flash copy operation of a volume.
	CopyRate *int64 `json:"copyRate,omitempty"`

	// Indicates flash copy name of the volume.
	FlashCopyName *string `json:"flashCopyName" validate:"required"`

	// Indicates the progress of flash copy operation.
	Progress *int64 `json:"progress,omitempty"`

	// Indicates name of the source volume.
	SourceVolumeName *string `json:"sourceVolumeName,omitempty"`

	// Indicates the start time of flash copy operation.
	StartTime *strfmt.DateTime `json:"startTime,omitempty"`

	// Copy status of a volume.
	Status *string `json:"status,omitempty"`

	// Indicates name of the target volume.
	TargetVolumeName *string `json:"targetVolumeName,omitempty"`
}

// UnmarshalFlashCopyMapping unmarshals an instance of FlashCopyMapping from the specified map of raw messages.
func UnmarshalFlashCopyMapping(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(FlashCopyMapping)
	err = core.UnmarshalPrimitive(m, "copyRate", &obj.CopyRate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "flashCopyName", &obj.FlashCopyName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "progress", &obj.Progress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sourceVolumeName", &obj.SourceVolumeName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "startTime", &obj.StartTime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "targetVolumeName", &obj.TargetVolumeName)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HardwarePlatform : Hardware platform detailing its limits and statistics.
type HardwarePlatform struct {
	// Description.
	Description *string `json:"description,omitempty"`

	// The DataCenter list of servers and their available resources.
	HostsResources []HostResources `json:"hostsResources,omitempty"`

	// Configured Memory GB.
	Memory *float64 `json:"memory,omitempty"`

	// Processor to Memory (GB) Ratio.
	ProcessorMemoryRatio *float64 `json:"processorMemoryRatio,omitempty"`

	// Configured Processors.
	Processors *float64 `json:"processors,omitempty"`

	// Allowable granularity for shared processors.
	SharedProcessorStep *float64 `json:"sharedProcessorStep,omitempty"`

	// Short code for hardware.
	Type *string `json:"type,omitempty"`
}

// UnmarshalHardwarePlatform unmarshals an instance of HardwarePlatform from the specified map of raw messages.
func UnmarshalHardwarePlatform(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HardwarePlatform)
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "hostsResources", &obj.HostsResources, UnmarshalHostResources)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "processorMemoryRatio", &obj.ProcessorMemoryRatio)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "processors", &obj.Processors)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sharedProcessorStep", &obj.SharedProcessorStep)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Health : Health struct
type Health struct {
	// Returns a description of the current servers health.
	Status *string `json:"status" validate:"required"`
}

// UnmarshalHealth unmarshals an instance of Health from the specified map of raw messages.
func UnmarshalHealth(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Health)
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HostInfo : HostInfo struct
type HostInfo struct {
	Cores *HostResource `json:"cores" validate:"required"`

	// Hostname.
	Hostname *string `json:"hostname" validate:"required"`

	// IP Address.
	IPAddress *string `json:"ipAddress" validate:"required"`

	Memory *HostResource `json:"memory" validate:"required"`

	// PVM Instances on host.
	PvmInstances []HostPvmInstance `json:"pvmInstances" validate:"required"`
}

// UnmarshalHostInfo unmarshals an instance of HostInfo from the specified map of raw messages.
func UnmarshalHostInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HostInfo)
	err = core.UnmarshalModel(m, "cores", &obj.Cores, UnmarshalHostResource)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "hostname", &obj.Hostname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ipAddress", &obj.IPAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "memory", &obj.Memory, UnmarshalHostResource)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "pvmInstances", &obj.PvmInstances, UnmarshalHostPvmInstance)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HostPvmInstance : A pvm instance on host.
type HostPvmInstance struct {
	// Cloud Instance ID pvm instance is a member of.
	CloudInstanceID *string `json:"cloudInstanceID" validate:"required"`

	Owner *OwnerInfo `json:"owner" validate:"required"`

	// Instance ID.
	PvmInstanceID *string `json:"pvmInstanceID" validate:"required"`

	// Instance name.
	PvmName *string `json:"pvmName" validate:"required"`

	// State of pvm instance.
	State *string `json:"state" validate:"required"`

	// Tenant ID of pvm instance.
	TenantID *string `json:"tenantID" validate:"required"`
}

// UnmarshalHostPvmInstance unmarshals an instance of HostPvmInstance from the specified map of raw messages.
func UnmarshalHostPvmInstance(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HostPvmInstance)
	err = core.UnmarshalPrimitive(m, "cloudInstanceID", &obj.CloudInstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "owner", &obj.Owner, UnmarshalOwnerInfo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pvmInstanceID", &obj.PvmInstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pvmName", &obj.PvmName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tenantID", &obj.TenantID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HostResource : HostResource struct
type HostResource struct {
	// Free.
	Free *float64 `json:"free" validate:"required"`

	// Total.
	Total *float64 `json:"total" validate:"required"`

	// Used.
	Used *float64 `json:"used" validate:"required"`
}

// UnmarshalHostResource unmarshals an instance of HostResource from the specified map of raw messages.
func UnmarshalHostResource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HostResource)
	err = core.UnmarshalPrimitive(m, "free", &obj.Free)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total", &obj.Total)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "used", &obj.Used)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// HostResources : HostResources struct
type HostResources struct {
	// The host available Processor units.
	Cores *float64 `json:"cores" validate:"required"`

	// The host identifier.
	ID *int64 `json:"id" validate:"required"`

	// The host available RAM memory in GiB.
	Memory *int64 `json:"memory" validate:"required"`
}

// UnmarshalHostResources unmarshals an instance of HostResources from the specified map of raw messages.
func UnmarshalHostResources(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(HostResources)
	err = core.UnmarshalPrimitive(m, "cores", &obj.Cores)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IkePolicies : IkePolicies struct
type IkePolicies struct {
	// IKE Policies array.
	IkePolicies []IkePolicy `json:"ikePolicies" validate:"required"`
}

// UnmarshalIkePolicies unmarshals an instance of IkePolicies from the specified map of raw messages.
func UnmarshalIkePolicies(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicies)
	err = core.UnmarshalModel(m, "ikePolicies", &obj.IkePolicies, UnmarshalIkePolicy)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IkePolicy : IKE Policy object.
type IkePolicy struct {
	// authentication of the IKE policy.
	Authentication *string `json:"authentication" validate:"required"`

	// DH group of the IKE Policy.
	DhGroup *int64 `json:"dhGroup" validate:"required"`

	// encryption of the IKE Policy.
	Encryption *string `json:"encryption" validate:"required"`

	// unique identifier of the IKE Policy object.
	ID *string `json:"id" validate:"required"`

	// Policy key lifetime.
	KeyLifetime *int64 `json:"keyLifetime" validate:"required"`

	// name of the IKE Policy.
	Name *string `json:"name" validate:"required"`

	// version of the IKE Policy.
	Version *int64 `json:"version" validate:"required"`
}

// Constants associated with the IkePolicy.Authentication property.
// authentication of the IKE policy.
const (
	IkePolicyAuthenticationNoneConst = "none"
	IkePolicyAuthenticationSha1Const = "sha1"
	IkePolicyAuthenticationSha256Const = "sha-256"
	IkePolicyAuthenticationSha384Const = "sha-384"
)

// Constants associated with the IkePolicy.Encryption property.
// encryption of the IKE Policy.
const (
	IkePolicyEncryptionAes128CbcConst = "aes-128-cbc"
	IkePolicyEncryptionAes128GcmConst = "aes-128-gcm"
	IkePolicyEncryptionAes192CbcConst = "aes-192-cbc"
	IkePolicyEncryptionAes256CbcConst = "aes-256-cbc"
	IkePolicyEncryptionAes256GcmConst = "aes-256-gcm"
)

// UnmarshalIkePolicy unmarshals an instance of IkePolicy from the specified map of raw messages.
func UnmarshalIkePolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicy)
	err = core.UnmarshalPrimitive(m, "authentication", &obj.Authentication)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dhGroup", &obj.DhGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encryption", &obj.Encryption)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "keyLifetime", &obj.KeyLifetime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IkePolicyRef : IKE Policy reference object.
type IkePolicyRef struct {
	// unique identifier of IKE Policy.
	ID *string `json:"id" validate:"required"`

	// name of IKE Policy.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalIkePolicyRef unmarshals an instance of IkePolicyRef from the specified map of raw messages.
func UnmarshalIkePolicyRef(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicyRef)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IkePolicyUpdate : IKE Policy object used for update.
type IkePolicyUpdate struct {
	// authentication of the IKE policy.
	Authentication *string `json:"authentication,omitempty"`

	// DH group of the IKE Policy.
	DhGroup *int64 `json:"dhGroup,omitempty"`

	// encryption of the IKE Policy.
	Encryption *string `json:"encryption,omitempty"`

	// Policy key lifetime.
	KeyLifetime *int64 `json:"keyLifetime,omitempty"`

	// name of the IKE Policy.
	Name *string `json:"name,omitempty"`

	// Preshared key used in this IKE Policy (length of preshared key must be even).
	PresharedKey *string `json:"presharedKey,omitempty"`

	// version of the IKE Policy.
	Version *int64 `json:"version,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// Constants associated with the IkePolicyUpdate.Authentication property.
// authentication of the IKE policy.
const (
	IkePolicyUpdateAuthenticationNoneConst = "none"
	IkePolicyUpdateAuthenticationSha1Const = "sha1"
	IkePolicyUpdateAuthenticationSha256Const = "sha-256"
	IkePolicyUpdateAuthenticationSha384Const = "sha-384"
)

// Constants associated with the IkePolicyUpdate.Encryption property.
// encryption of the IKE Policy.
const (
	IkePolicyUpdateEncryptionAes128CbcConst = "aes-128-cbc"
	IkePolicyUpdateEncryptionAes128GcmConst = "aes-128-gcm"
	IkePolicyUpdateEncryptionAes192CbcConst = "aes-192-cbc"
	IkePolicyUpdateEncryptionAes256CbcConst = "aes-256-cbc"
	IkePolicyUpdateEncryptionAes256GcmConst = "aes-256-gcm"
)

// SetProperty allows the user to set an arbitrary property on an instance of IkePolicyUpdate
func (o *IkePolicyUpdate) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of IkePolicyUpdate
func (o *IkePolicyUpdate) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of IkePolicyUpdate
func (o *IkePolicyUpdate) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of IkePolicyUpdate
func (o *IkePolicyUpdate) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of IkePolicyUpdate
func (o *IkePolicyUpdate) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.Authentication != nil {
		m["authentication"] = o.Authentication
	}
	if o.DhGroup != nil {
		m["dhGroup"] = o.DhGroup
	}
	if o.Encryption != nil {
		m["encryption"] = o.Encryption
	}
	if o.KeyLifetime != nil {
		m["keyLifetime"] = o.KeyLifetime
	}
	if o.Name != nil {
		m["name"] = o.Name
	}
	if o.PresharedKey != nil {
		m["presharedKey"] = o.PresharedKey
	}
	if o.Version != nil {
		m["version"] = o.Version
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalIkePolicyUpdate unmarshals an instance of IkePolicyUpdate from the specified map of raw messages.
func UnmarshalIkePolicyUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IkePolicyUpdate)
	err = core.UnmarshalPrimitive(m, "authentication", &obj.Authentication)
	if err != nil {
		return
	}
	delete(m, "authentication")
	err = core.UnmarshalPrimitive(m, "dhGroup", &obj.DhGroup)
	if err != nil {
		return
	}
	delete(m, "dhGroup")
	err = core.UnmarshalPrimitive(m, "encryption", &obj.Encryption)
	if err != nil {
		return
	}
	delete(m, "encryption")
	err = core.UnmarshalPrimitive(m, "keyLifetime", &obj.KeyLifetime)
	if err != nil {
		return
	}
	delete(m, "keyLifetime")
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	delete(m, "name")
	err = core.UnmarshalPrimitive(m, "presharedKey", &obj.PresharedKey)
	if err != nil {
		return
	}
	delete(m, "presharedKey")
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		return
	}
	delete(m, "version")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPAddressRange : IPAddressRange struct
type IPAddressRange struct {
	// Ending IP Address.
	EndingIPAddress *string `json:"endingIPAddress" validate:"required"`

	// Starting IP Address.
	StartingIPAddress *string `json:"startingIPAddress" validate:"required"`
}

// NewIPAddressRange : Instantiate IPAddressRange (Generic Model Constructor)
func (*PowervsV1) NewIPAddressRange(endingIPAddress string, startingIPAddress string) (_model *IPAddressRange, err error) {
	_model = &IPAddressRange{
		EndingIPAddress: core.StringPtr(endingIPAddress),
		StartingIPAddress: core.StringPtr(startingIPAddress),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalIPAddressRange unmarshals an instance of IPAddressRange from the specified map of raw messages.
func UnmarshalIPAddressRange(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPAddressRange)
	err = core.UnmarshalPrimitive(m, "endingIPAddress", &obj.EndingIPAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "startingIPAddress", &obj.StartingIPAddress)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPSecPolicies : IPSecPolicies struct
type IPSecPolicies struct {
	// IPSec Policies array.
	IPSecPolicies []IPSecPolicy `json:"ipSecPolicies" validate:"required"`
}

// UnmarshalIPSecPolicies unmarshals an instance of IPSecPolicies from the specified map of raw messages.
func UnmarshalIPSecPolicies(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPSecPolicies)
	err = core.UnmarshalModel(m, "ipSecPolicies", &obj.IPSecPolicies, UnmarshalIPSecPolicy)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPSecPolicy : IPSec Policy object.
type IPSecPolicy struct {
	// authentication for IPSec policy.
	Authentication *string `json:"authentication" validate:"required"`

	// Diffie-Hellman group.
	DhGroup *int64 `json:"dhGroup" validate:"required"`

	// connection encryption policy.
	Encryption *string `json:"encryption" validate:"required"`

	// unique identifier of the IPSec Policy.
	ID *string `json:"id" validate:"required"`

	// Policy key lifetime.
	KeyLifetime *int64 `json:"keyLifetime" validate:"required"`

	// IPSec Policy name.
	Name *string `json:"name" validate:"required"`

	// Perfect Forward Secrecy.
	Pfs *bool `json:"pfs" validate:"required"`
}

// Constants associated with the IPSecPolicy.Authentication property.
// authentication for IPSec policy.
const (
	IPSecPolicyAuthenticationHmacSha196Const = "hmac-sha1-96"
	IPSecPolicyAuthenticationHmacSha256128Const = "hmac-sha-256-128"
	IPSecPolicyAuthenticationNoneConst = "none"
)

// Constants associated with the IPSecPolicy.Encryption property.
// connection encryption policy.
const (
	IPSecPolicyEncryptionAes128CbcConst = "aes-128-cbc"
	IPSecPolicyEncryptionAes128GcmConst = "aes-128-gcm"
	IPSecPolicyEncryptionAes192CbcConst = "aes-192-cbc"
	IPSecPolicyEncryptionAes192GcmConst = "aes-192-gcm"
	IPSecPolicyEncryptionAes256CbcConst = "aes-256-cbc"
	IPSecPolicyEncryptionAes256GcmConst = "aes-256-gcm"
)

// UnmarshalIPSecPolicy unmarshals an instance of IPSecPolicy from the specified map of raw messages.
func UnmarshalIPSecPolicy(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPSecPolicy)
	err = core.UnmarshalPrimitive(m, "authentication", &obj.Authentication)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dhGroup", &obj.DhGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "encryption", &obj.Encryption)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "keyLifetime", &obj.KeyLifetime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pfs", &obj.Pfs)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPSecPolicyRef : IPSec Policy reference object.
type IPSecPolicyRef struct {
	// unique identifier of IPSec Policy.
	ID *string `json:"id" validate:"required"`

	// name of IPSec Policy.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalIPSecPolicyRef unmarshals an instance of IPSecPolicyRef from the specified map of raw messages.
func UnmarshalIPSecPolicyRef(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPSecPolicyRef)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// IPSecPolicyUpdate : IPSEc Policy object used for update.
type IPSecPolicyUpdate struct {
	// authentication for IPSec policy.
	Authentication *string `json:"authentication,omitempty"`

	// Diffie-Hellman group.
	DhGroup *int64 `json:"dhGroup,omitempty"`

	// connection encryption policy.
	Encryption *string `json:"encryption,omitempty"`

	// Policy key lifetime.
	KeyLifetime *int64 `json:"keyLifetime,omitempty"`

	// IPSec Policy name.
	Name *string `json:"name,omitempty"`

	// Perfect Forward Secrecy.
	Pfs *bool `json:"pfs,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// Constants associated with the IPSecPolicyUpdate.Authentication property.
// authentication for IPSec policy.
const (
	IPSecPolicyUpdateAuthenticationHmacSha196Const = "hmac-sha1-96"
	IPSecPolicyUpdateAuthenticationHmacSha256128Const = "hmac-sha-256-128"
	IPSecPolicyUpdateAuthenticationNoneConst = "none"
)

// Constants associated with the IPSecPolicyUpdate.Encryption property.
// connection encryption policy.
const (
	IPSecPolicyUpdateEncryptionAes128CbcConst = "aes-128-cbc"
	IPSecPolicyUpdateEncryptionAes128GcmConst = "aes-128-gcm"
	IPSecPolicyUpdateEncryptionAes192CbcConst = "aes-192-cbc"
	IPSecPolicyUpdateEncryptionAes192GcmConst = "aes-192-gcm"
	IPSecPolicyUpdateEncryptionAes256CbcConst = "aes-256-cbc"
	IPSecPolicyUpdateEncryptionAes256GcmConst = "aes-256-gcm"
)

// SetProperty allows the user to set an arbitrary property on an instance of IPSecPolicyUpdate
func (o *IPSecPolicyUpdate) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of IPSecPolicyUpdate
func (o *IPSecPolicyUpdate) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of IPSecPolicyUpdate
func (o *IPSecPolicyUpdate) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of IPSecPolicyUpdate
func (o *IPSecPolicyUpdate) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of IPSecPolicyUpdate
func (o *IPSecPolicyUpdate) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.Authentication != nil {
		m["authentication"] = o.Authentication
	}
	if o.DhGroup != nil {
		m["dhGroup"] = o.DhGroup
	}
	if o.Encryption != nil {
		m["encryption"] = o.Encryption
	}
	if o.KeyLifetime != nil {
		m["keyLifetime"] = o.KeyLifetime
	}
	if o.Name != nil {
		m["name"] = o.Name
	}
	if o.Pfs != nil {
		m["pfs"] = o.Pfs
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalIPSecPolicyUpdate unmarshals an instance of IPSecPolicyUpdate from the specified map of raw messages.
func UnmarshalIPSecPolicyUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(IPSecPolicyUpdate)
	err = core.UnmarshalPrimitive(m, "authentication", &obj.Authentication)
	if err != nil {
		return
	}
	delete(m, "authentication")
	err = core.UnmarshalPrimitive(m, "dhGroup", &obj.DhGroup)
	if err != nil {
		return
	}
	delete(m, "dhGroup")
	err = core.UnmarshalPrimitive(m, "encryption", &obj.Encryption)
	if err != nil {
		return
	}
	delete(m, "encryption")
	err = core.UnmarshalPrimitive(m, "keyLifetime", &obj.KeyLifetime)
	if err != nil {
		return
	}
	delete(m, "keyLifetime")
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	delete(m, "name")
	err = core.UnmarshalPrimitive(m, "pfs", &obj.Pfs)
	if err != nil {
		return
	}
	delete(m, "pfs")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Image : Image struct
type Image struct {
	// Creation Date.
	CreationDate *strfmt.DateTime `json:"creationDate" validate:"required"`

	// Description.
	Description *string `json:"description,omitempty"`

	// Image ID.
	ImageID *string `json:"imageID" validate:"required"`

	// Last Update Date.
	LastUpdateDate *strfmt.DateTime `json:"lastUpdateDate" validate:"required"`

	// Maximum image volume size for multi-volume image.
	MaxImageVolumeSize *float64 `json:"maxImageVolumeSize" validate:"required"`

	// Image Name.
	Name *string `json:"name" validate:"required"`

	// List of Servers that have deployed the image.
	Servers []string `json:"servers,omitempty"`

	// Image Size.
	Size *float64 `json:"size" validate:"required"`

	Specifications *ImageSpecifications `json:"specifications,omitempty"`

	// Image State.
	State *string `json:"state,omitempty"`

	// Storage pool where the image resides.
	StoragePool *string `json:"storagePool" validate:"required"`

	// Storage type for image.
	StorageType *string `json:"storageType" validate:"required"`

	Taskref *TaskReference `json:"taskref,omitempty"`

	// Image Volumes.
	Volumes []ImageVolume `json:"volumes,omitempty"`
}

// UnmarshalImage unmarshals an instance of Image from the specified map of raw messages.
func UnmarshalImage(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Image)
	err = core.UnmarshalPrimitive(m, "creationDate", &obj.CreationDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "imageID", &obj.ImageID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lastUpdateDate", &obj.LastUpdateDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "maxImageVolumeSize", &obj.MaxImageVolumeSize)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "servers", &obj.Servers)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "size", &obj.Size)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "specifications", &obj.Specifications, UnmarshalImageSpecifications)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storagePool", &obj.StoragePool)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storageType", &obj.StorageType)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "taskref", &obj.Taskref, UnmarshalTaskReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volumes", &obj.Volumes, UnmarshalImageVolume)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageReference : ImageReference struct
type ImageReference struct {
	// Creation Date.
	CreationDate *strfmt.DateTime `json:"creationDate" validate:"required"`

	// Description.
	Description *string `json:"description" validate:"required"`

	// Link to Image resource.
	Href *string `json:"href" validate:"required"`

	// Image ID.
	ImageID *string `json:"imageID" validate:"required"`

	// Last Update Date.
	LastUpdateDate *strfmt.DateTime `json:"lastUpdateDate" validate:"required"`

	// Image Name.
	Name *string `json:"name" validate:"required"`

	Specifications *ImageSpecifications `json:"specifications" validate:"required"`

	// Image State.
	State *string `json:"state" validate:"required"`

	// Storage pool where image resides.
	StoragePool *string `json:"storagePool" validate:"required"`

	// Storage type for image.
	StorageType *string `json:"storageType" validate:"required"`
}

// UnmarshalImageReference unmarshals an instance of ImageReference from the specified map of raw messages.
func UnmarshalImageReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageReference)
	err = core.UnmarshalPrimitive(m, "creationDate", &obj.CreationDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "imageID", &obj.ImageID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lastUpdateDate", &obj.LastUpdateDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "specifications", &obj.Specifications, UnmarshalImageSpecifications)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storagePool", &obj.StoragePool)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storageType", &obj.StorageType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageSpecifications : ImageSpecifications struct
type ImageSpecifications struct {
	// Architecture.
	Architecture *string `json:"architecture,omitempty"`

	// Container Format.
	ContainerFormat *string `json:"containerFormat,omitempty"`

	// Disk Format.
	DiskFormat *string `json:"diskFormat,omitempty"`

	// Endianness.
	Endianness *string `json:"endianness,omitempty"`

	// Hypervisor Type.
	HypervisorType *string `json:"hypervisorType,omitempty"`

	// Image Type.
	ImageType *string `json:"imageType,omitempty"`

	// Operating System.
	OperatingSystem *string `json:"operatingSystem,omitempty"`
}

// UnmarshalImageSpecifications unmarshals an instance of ImageSpecifications from the specified map of raw messages.
func UnmarshalImageSpecifications(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageSpecifications)
	err = core.UnmarshalPrimitive(m, "architecture", &obj.Architecture)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "containerFormat", &obj.ContainerFormat)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "diskFormat", &obj.DiskFormat)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "endianness", &obj.Endianness)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "hypervisorType", &obj.HypervisorType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "imageType", &obj.ImageType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "operatingSystem", &obj.OperatingSystem)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ImageVolume : ImageVolume struct
type ImageVolume struct {
	// Indicates if the volume is boot capable.
	Bootable *bool `json:"bootable" validate:"required"`

	// Volume Name.
	Name *string `json:"name" validate:"required"`

	// Volume Size.
	Size *float64 `json:"size" validate:"required"`

	// Volume ID.
	VolumeID *string `json:"volumeID" validate:"required"`
}

// UnmarshalImageVolume unmarshals an instance of ImageVolume from the specified map of raw messages.
func UnmarshalImageVolume(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ImageVolume)
	err = core.UnmarshalPrimitive(m, "bootable", &obj.Bootable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "size", &obj.Size)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "volumeID", &obj.VolumeID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Images : Images struct
type Images struct {
	// Images.
	Images []ImageReference `json:"images" validate:"required"`
}

// UnmarshalImages unmarshals an instance of Images from the specified map of raw messages.
func UnmarshalImages(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Images)
	err = core.UnmarshalModel(m, "images", &obj.Images, UnmarshalImageReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// InternalV1PowervsInstancesGetOptions : The InternalV1PowervsInstancesGet options.
type InternalV1PowervsInstancesGetOptions struct {
	// The PowerVS Location.
	PowervsLocation *string `json:"powervs_location,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewInternalV1PowervsInstancesGetOptions : Instantiate InternalV1PowervsInstancesGetOptions
func (*PowervsV1) NewInternalV1PowervsInstancesGetOptions() *InternalV1PowervsInstancesGetOptions {
	return &InternalV1PowervsInstancesGetOptions{}
}

// SetPowervsLocation : Allow user to set PowervsLocation
func (_options *InternalV1PowervsInstancesGetOptions) SetPowervsLocation(powervsLocation string) *InternalV1PowervsInstancesGetOptions {
	_options.PowervsLocation = core.StringPtr(powervsLocation)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *InternalV1PowervsInstancesGetOptions) SetHeaders(param map[string]string) *InternalV1PowervsInstancesGetOptions {
	options.Headers = param
	return options
}

// InternalV1PowervsLocationsTransitgatewayGetOptions : The InternalV1PowervsLocationsTransitgatewayGet options.
type InternalV1PowervsLocationsTransitgatewayGetOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewInternalV1PowervsLocationsTransitgatewayGetOptions : Instantiate InternalV1PowervsLocationsTransitgatewayGetOptions
func (*PowervsV1) NewInternalV1PowervsLocationsTransitgatewayGetOptions() *InternalV1PowervsLocationsTransitgatewayGetOptions {
	return &InternalV1PowervsLocationsTransitgatewayGetOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *InternalV1PowervsLocationsTransitgatewayGetOptions) SetHeaders(param map[string]string) *InternalV1PowervsLocationsTransitgatewayGetOptions {
	options.Headers = param
	return options
}

// InternalV1StorageRegionsStoragePoolsGetOptions : The InternalV1StorageRegionsStoragePoolsGet options.
type InternalV1StorageRegionsStoragePoolsGetOptions struct {
	// ID of a Power Cloud Region Zone.
	RegionZoneID *string `json:"region_zone_id" validate:"required,ne="`

	// Storage pool name.
	StoragePoolName *string `json:"storage_pool_name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewInternalV1StorageRegionsStoragePoolsGetOptions : Instantiate InternalV1StorageRegionsStoragePoolsGetOptions
func (*PowervsV1) NewInternalV1StorageRegionsStoragePoolsGetOptions(regionZoneID string, storagePoolName string) *InternalV1StorageRegionsStoragePoolsGetOptions {
	return &InternalV1StorageRegionsStoragePoolsGetOptions{
		RegionZoneID: core.StringPtr(regionZoneID),
		StoragePoolName: core.StringPtr(storagePoolName),
	}
}

// SetRegionZoneID : Allow user to set RegionZoneID
func (_options *InternalV1StorageRegionsStoragePoolsGetOptions) SetRegionZoneID(regionZoneID string) *InternalV1StorageRegionsStoragePoolsGetOptions {
	_options.RegionZoneID = core.StringPtr(regionZoneID)
	return _options
}

// SetStoragePoolName : Allow user to set StoragePoolName
func (_options *InternalV1StorageRegionsStoragePoolsGetOptions) SetStoragePoolName(storagePoolName string) *InternalV1StorageRegionsStoragePoolsGetOptions {
	_options.StoragePoolName = core.StringPtr(storagePoolName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *InternalV1StorageRegionsStoragePoolsGetOptions) SetHeaders(param map[string]string) *InternalV1StorageRegionsStoragePoolsGetOptions {
	options.Headers = param
	return options
}

// InternalV1StorageRegionsStoragePoolsGetallOptions : The InternalV1StorageRegionsStoragePoolsGetall options.
type InternalV1StorageRegionsStoragePoolsGetallOptions struct {
	// ID of a Power Cloud Region Zone.
	RegionZoneID *string `json:"region_zone_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewInternalV1StorageRegionsStoragePoolsGetallOptions : Instantiate InternalV1StorageRegionsStoragePoolsGetallOptions
func (*PowervsV1) NewInternalV1StorageRegionsStoragePoolsGetallOptions(regionZoneID string) *InternalV1StorageRegionsStoragePoolsGetallOptions {
	return &InternalV1StorageRegionsStoragePoolsGetallOptions{
		RegionZoneID: core.StringPtr(regionZoneID),
	}
}

// SetRegionZoneID : Allow user to set RegionZoneID
func (_options *InternalV1StorageRegionsStoragePoolsGetallOptions) SetRegionZoneID(regionZoneID string) *InternalV1StorageRegionsStoragePoolsGetallOptions {
	_options.RegionZoneID = core.StringPtr(regionZoneID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *InternalV1StorageRegionsStoragePoolsGetallOptions) SetHeaders(param map[string]string) *InternalV1StorageRegionsStoragePoolsGetallOptions {
	options.Headers = param
	return options
}

// InternalV1StorageRegionsStoragePoolsPutOptions : The InternalV1StorageRegionsStoragePoolsPut options.
type InternalV1StorageRegionsStoragePoolsPutOptions struct {
	// ID of a Power Cloud Region Zone.
	RegionZoneID *string `json:"region_zone_id" validate:"required,ne="`

	// Storage pool name.
	StoragePoolName *string `json:"storage_pool_name" validate:"required,ne="`

	// display name of storage pool.
	DisplayName *string `json:"displayName,omitempty"`

	// indicates if the storage pool is disaster recovery (dr) enabled.
	DrEnabled *bool `json:"drEnabled,omitempty"`

	// storage threshold settings.
	OverrideThresholds *Thresholds `json:"overrideThresholds,omitempty"`

	// state of storage pool.
	State *string `json:"state,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the InternalV1StorageRegionsStoragePoolsPutOptions.State property.
// state of storage pool.
const (
	InternalV1StorageRegionsStoragePoolsPutOptionsStateClosedConst = "closed"
	InternalV1StorageRegionsStoragePoolsPutOptionsStateOpenedConst = "opened"
)

// NewInternalV1StorageRegionsStoragePoolsPutOptions : Instantiate InternalV1StorageRegionsStoragePoolsPutOptions
func (*PowervsV1) NewInternalV1StorageRegionsStoragePoolsPutOptions(regionZoneID string, storagePoolName string) *InternalV1StorageRegionsStoragePoolsPutOptions {
	return &InternalV1StorageRegionsStoragePoolsPutOptions{
		RegionZoneID: core.StringPtr(regionZoneID),
		StoragePoolName: core.StringPtr(storagePoolName),
	}
}

// SetRegionZoneID : Allow user to set RegionZoneID
func (_options *InternalV1StorageRegionsStoragePoolsPutOptions) SetRegionZoneID(regionZoneID string) *InternalV1StorageRegionsStoragePoolsPutOptions {
	_options.RegionZoneID = core.StringPtr(regionZoneID)
	return _options
}

// SetStoragePoolName : Allow user to set StoragePoolName
func (_options *InternalV1StorageRegionsStoragePoolsPutOptions) SetStoragePoolName(storagePoolName string) *InternalV1StorageRegionsStoragePoolsPutOptions {
	_options.StoragePoolName = core.StringPtr(storagePoolName)
	return _options
}

// SetDisplayName : Allow user to set DisplayName
func (_options *InternalV1StorageRegionsStoragePoolsPutOptions) SetDisplayName(displayName string) *InternalV1StorageRegionsStoragePoolsPutOptions {
	_options.DisplayName = core.StringPtr(displayName)
	return _options
}

// SetDrEnabled : Allow user to set DrEnabled
func (_options *InternalV1StorageRegionsStoragePoolsPutOptions) SetDrEnabled(drEnabled bool) *InternalV1StorageRegionsStoragePoolsPutOptions {
	_options.DrEnabled = core.BoolPtr(drEnabled)
	return _options
}

// SetOverrideThresholds : Allow user to set OverrideThresholds
func (_options *InternalV1StorageRegionsStoragePoolsPutOptions) SetOverrideThresholds(overrideThresholds *Thresholds) *InternalV1StorageRegionsStoragePoolsPutOptions {
	_options.OverrideThresholds = overrideThresholds
	return _options
}

// SetState : Allow user to set State
func (_options *InternalV1StorageRegionsStoragePoolsPutOptions) SetState(state string) *InternalV1StorageRegionsStoragePoolsPutOptions {
	_options.State = core.StringPtr(state)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *InternalV1StorageRegionsStoragePoolsPutOptions) SetHeaders(param map[string]string) *InternalV1StorageRegionsStoragePoolsPutOptions {
	options.Headers = param
	return options
}

// InternalV1StorageRegionsThresholdsGetOptions : The InternalV1StorageRegionsThresholdsGet options.
type InternalV1StorageRegionsThresholdsGetOptions struct {
	// ID of a Power Cloud Region Zone.
	RegionZoneID *string `json:"region_zone_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewInternalV1StorageRegionsThresholdsGetOptions : Instantiate InternalV1StorageRegionsThresholdsGetOptions
func (*PowervsV1) NewInternalV1StorageRegionsThresholdsGetOptions(regionZoneID string) *InternalV1StorageRegionsThresholdsGetOptions {
	return &InternalV1StorageRegionsThresholdsGetOptions{
		RegionZoneID: core.StringPtr(regionZoneID),
	}
}

// SetRegionZoneID : Allow user to set RegionZoneID
func (_options *InternalV1StorageRegionsThresholdsGetOptions) SetRegionZoneID(regionZoneID string) *InternalV1StorageRegionsThresholdsGetOptions {
	_options.RegionZoneID = core.StringPtr(regionZoneID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *InternalV1StorageRegionsThresholdsGetOptions) SetHeaders(param map[string]string) *InternalV1StorageRegionsThresholdsGetOptions {
	options.Headers = param
	return options
}

// InternalV1StorageRegionsThresholdsPutOptions : The InternalV1StorageRegionsThresholdsPut options.
type InternalV1StorageRegionsThresholdsPutOptions struct {
	// ID of a Power Cloud Region Zone.
	RegionZoneID *string `json:"region_zone_id" validate:"required,ne="`

	Capacity *StorageEntities `json:"capacity,omitempty"`

	Overcommit *StorageEntities `json:"overcommit,omitempty"`

	PhysicalCapacity *StorageEntities `json:"physicalCapacity,omitempty"`

	VdiskCapacity *StorageEntities `json:"vdiskCapacity,omitempty"`

	VdiskLimit *StorageEntities `json:"vdiskLimit,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewInternalV1StorageRegionsThresholdsPutOptions : Instantiate InternalV1StorageRegionsThresholdsPutOptions
func (*PowervsV1) NewInternalV1StorageRegionsThresholdsPutOptions(regionZoneID string) *InternalV1StorageRegionsThresholdsPutOptions {
	return &InternalV1StorageRegionsThresholdsPutOptions{
		RegionZoneID: core.StringPtr(regionZoneID),
	}
}

// SetRegionZoneID : Allow user to set RegionZoneID
func (_options *InternalV1StorageRegionsThresholdsPutOptions) SetRegionZoneID(regionZoneID string) *InternalV1StorageRegionsThresholdsPutOptions {
	_options.RegionZoneID = core.StringPtr(regionZoneID)
	return _options
}

// SetCapacity : Allow user to set Capacity
func (_options *InternalV1StorageRegionsThresholdsPutOptions) SetCapacity(capacity *StorageEntities) *InternalV1StorageRegionsThresholdsPutOptions {
	_options.Capacity = capacity
	return _options
}

// SetOvercommit : Allow user to set Overcommit
func (_options *InternalV1StorageRegionsThresholdsPutOptions) SetOvercommit(overcommit *StorageEntities) *InternalV1StorageRegionsThresholdsPutOptions {
	_options.Overcommit = overcommit
	return _options
}

// SetPhysicalCapacity : Allow user to set PhysicalCapacity
func (_options *InternalV1StorageRegionsThresholdsPutOptions) SetPhysicalCapacity(physicalCapacity *StorageEntities) *InternalV1StorageRegionsThresholdsPutOptions {
	_options.PhysicalCapacity = physicalCapacity
	return _options
}

// SetVdiskCapacity : Allow user to set VdiskCapacity
func (_options *InternalV1StorageRegionsThresholdsPutOptions) SetVdiskCapacity(vdiskCapacity *StorageEntities) *InternalV1StorageRegionsThresholdsPutOptions {
	_options.VdiskCapacity = vdiskCapacity
	return _options
}

// SetVdiskLimit : Allow user to set VdiskLimit
func (_options *InternalV1StorageRegionsThresholdsPutOptions) SetVdiskLimit(vdiskLimit *StorageEntities) *InternalV1StorageRegionsThresholdsPutOptions {
	_options.VdiskLimit = vdiskLimit
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *InternalV1StorageRegionsThresholdsPutOptions) SetHeaders(param map[string]string) *InternalV1StorageRegionsThresholdsPutOptions {
	options.Headers = param
	return options
}

// InternalV1TransitgatewayGetOptions : The InternalV1TransitgatewayGet options.
type InternalV1TransitgatewayGetOptions struct {
	// The PowerVS Service Instance CRN (Targeting).
	PowervsServiceCRN *string `json:"powervs_service_crn" validate:"required,ne="`

	// Authentication of the user that initiated the request from the TGW Platform.
	IBMUserAuthorization *string `json:"IBM-UserAuthorization" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewInternalV1TransitgatewayGetOptions : Instantiate InternalV1TransitgatewayGetOptions
func (*PowervsV1) NewInternalV1TransitgatewayGetOptions(powervsServiceCRN string, ibmUserAuthorization string) *InternalV1TransitgatewayGetOptions {
	return &InternalV1TransitgatewayGetOptions{
		PowervsServiceCRN: core.StringPtr(powervsServiceCRN),
		IBMUserAuthorization: core.StringPtr(ibmUserAuthorization),
	}
}

// SetPowervsServiceCRN : Allow user to set PowervsServiceCRN
func (_options *InternalV1TransitgatewayGetOptions) SetPowervsServiceCRN(powervsServiceCRN string) *InternalV1TransitgatewayGetOptions {
	_options.PowervsServiceCRN = core.StringPtr(powervsServiceCRN)
	return _options
}

// SetIBMUserAuthorization : Allow user to set IBMUserAuthorization
func (_options *InternalV1TransitgatewayGetOptions) SetIBMUserAuthorization(ibmUserAuthorization string) *InternalV1TransitgatewayGetOptions {
	_options.IBMUserAuthorization = core.StringPtr(ibmUserAuthorization)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *InternalV1TransitgatewayGetOptions) SetHeaders(param map[string]string) *InternalV1TransitgatewayGetOptions {
	options.Headers = param
	return options
}

// JSONSchemaObject : JSONSchemaObject struct
type JSONSchemaObject struct {

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// SetProperty allows the user to set an arbitrary property on an instance of JSONSchemaObject
func (o *JSONSchemaObject) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of JSONSchemaObject
func (o *JSONSchemaObject) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of JSONSchemaObject
func (o *JSONSchemaObject) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of JSONSchemaObject
func (o *JSONSchemaObject) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of JSONSchemaObject
func (o *JSONSchemaObject) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalJSONSchemaObject unmarshals an instance of JSONSchemaObject from the specified map of raw messages.
func UnmarshalJSONSchemaObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(JSONSchemaObject)
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Job : Job struct
type Job struct {
	// create timestamp for the job.
	CreateTimestamp *strfmt.DateTime `json:"createTimestamp,omitempty"`

	// id of a job.
	ID *string `json:"id" validate:"required"`

	Operation *Operation `json:"operation" validate:"required"`

	Status *Status `json:"status" validate:"required"`
}

// UnmarshalJob unmarshals an instance of Job from the specified map of raw messages.
func UnmarshalJob(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Job)
	err = core.UnmarshalPrimitive(m, "createTimestamp", &obj.CreateTimestamp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "operation", &obj.Operation, UnmarshalOperation)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "status", &obj.Status, UnmarshalStatus)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// JobReference : JobReference struct
type JobReference struct {
	// Link to job resource.
	Href *string `json:"href" validate:"required"`

	// id of a job used to get status of long running operation.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalJobReference unmarshals an instance of JobReference from the specified map of raw messages.
func UnmarshalJobReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(JobReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Jobs : Jobs struct
type Jobs struct {
	// Jobs.
	Jobs []Job `json:"jobs" validate:"required"`
}

// UnmarshalJobs unmarshals an instance of Jobs from the specified map of raw messages.
func UnmarshalJobs(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Jobs)
	err = core.UnmarshalModel(m, "jobs", &obj.Jobs, UnmarshalJob)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// LastOperationResource : LastOperationResource struct
type LastOperationResource struct {
	Description *string `json:"description,omitempty"`

	State *string `json:"state" validate:"required"`
}

// Constants associated with the LastOperationResource.State property.
const (
	LastOperationResourceStateFailedConst = "failed"
	LastOperationResourceStateInProgressConst = "in progress"
	LastOperationResourceStateSucceededConst = "succeeded"
)

// UnmarshalLastOperationResource unmarshals an instance of LastOperationResource from the specified map of raw messages.
func UnmarshalLastOperationResource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(LastOperationResource)
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MaximumStorageAllocation : Maximum storage allocation.
type MaximumStorageAllocation struct {
	// Maximum allocation storage size (GB).
	MaxAllocationSize *int64 `json:"maxAllocationSize" validate:"required"`

	// Storage pool.
	StoragePool *string `json:"storagePool" validate:"required"`

	// Storage type.
	StorageType *string `json:"storageType" validate:"required"`
}

// UnmarshalMaximumStorageAllocation unmarshals an instance of MaximumStorageAllocation from the specified map of raw messages.
func UnmarshalMaximumStorageAllocation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MaximumStorageAllocation)
	err = core.UnmarshalPrimitive(m, "maxAllocationSize", &obj.MaxAllocationSize)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storagePool", &obj.StoragePool)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storageType", &obj.StorageType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Metadata : See [Service Metadata
// Conventions](https://github.com/openservicebrokerapi/servicebroker/blob/master/profile.md#service-metadata) for more
// details.
type Metadata struct {

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// SetProperty allows the user to set an arbitrary property on an instance of Metadata
func (o *Metadata) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of Metadata
func (o *Metadata) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of Metadata
func (o *Metadata) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of Metadata
func (o *Metadata) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of Metadata
func (o *Metadata) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalMetadata unmarshals an instance of Metadata from the specified map of raw messages.
func UnmarshalMetadata(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Metadata)
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// MinMaxDefault : MinMaxDefault struct
type MinMaxDefault struct {
	// default value.
	Default *float64 `json:"default" validate:"required"`

	// max value.
	Max *float64 `json:"max" validate:"required"`

	// min value.
	Min *float64 `json:"min" validate:"required"`
}

// UnmarshalMinMaxDefault unmarshals an instance of MinMaxDefault from the specified map of raw messages.
func UnmarshalMinMaxDefault(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(MinMaxDefault)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Network : Network struct
type Network struct {
	// Network communication configuration (for satellite locations only)
	//   * `internal-only` - network is only used for internal host communication
	//   * `outbound-only` - network will be capable of egress traffic
	//   * `bidirectional-static-route` - network will be capable of ingress and egress traffic via static routes
	//   * `bidirectional-bgp` - network will be capable of ingress and egress traffic via bgp configuration
	//   * `bidirectional-l2out` - network will be capable of ingress and egress traffic via l2out ACI configuration.
	AccessConfig *string `json:"accessConfig,omitempty"`

	// Network in CIDR notation (192.168.0.0/24).
	CIDR *string `json:"cidr" validate:"required"`

	// (currently not available) cloud connections this network is attached.
	CloudConnections []NetworkCloudConnectionsItem `json:"cloudConnections,omitempty"`

	// DHCP Managed Network.
	DhcpManaged *bool `json:"dhcpManaged,omitempty"`

	// DNS Servers.
	DnsServers []string `json:"dnsServers" validate:"required"`

	// Gateway IP Address.
	Gateway *string `json:"gateway,omitempty"`

	// IP Address Metrics.
	IPAddressMetrics *NetworkIPAddressMetrics `json:"ipAddressMetrics" validate:"required"`

	// IP Address Ranges.
	IPAddressRanges []IPAddressRange `json:"ipAddressRanges" validate:"required"`

	// Enable MTU Jumbo Network (for multi-zone locations only).
	Jumbo *bool `json:"jumbo,omitempty"`

	// Maximum transmission unit (for satellite locations only).
	Mtu *int64 `json:"mtu,omitempty"`

	// Network Name.
	Name *string `json:"name" validate:"required"`

	// Unique Network ID.
	NetworkID *string `json:"networkID" validate:"required"`

	// Public IP Address Ranges (for pub-vlan networks).
	PublicIPAddressRanges []IPAddressRange `json:"publicIPAddressRanges,omitempty"`

	// Type of Network - 'vlan' (private network) 'pub-vlan' (public network) 'dhcp-vlan' (for satellite locations only).
	Type *string `json:"type" validate:"required"`

	// VLAN ID.
	VlanID *float64 `json:"vlanID" validate:"required"`
}

// Constants associated with the Network.AccessConfig property.
// Network communication configuration (for satellite locations only)
//   * `internal-only` - network is only used for internal host communication
//   * `outbound-only` - network will be capable of egress traffic
//   * `bidirectional-static-route` - network will be capable of ingress and egress traffic via static routes
//   * `bidirectional-bgp` - network will be capable of ingress and egress traffic via bgp configuration
//   * `bidirectional-l2out` - network will be capable of ingress and egress traffic via l2out ACI configuration.
const (
	NetworkAccessConfigBidirectionalBgpConst = "bidirectional-bgp"
	NetworkAccessConfigBidirectionalL2outConst = "bidirectional-l2out"
	NetworkAccessConfigBidirectionalStaticRouteConst = "bidirectional-static-route"
	NetworkAccessConfigInternalOnlyConst = "internal-only"
	NetworkAccessConfigOutboundOnlyConst = "outbound-only"
)

// Constants associated with the Network.Type property.
// Type of Network - 'vlan' (private network) 'pub-vlan' (public network) 'dhcp-vlan' (for satellite locations only).
const (
	NetworkTypeDhcpVlanConst = "dhcp-vlan"
	NetworkTypePubVlanConst = "pub-vlan"
	NetworkTypeVlanConst = "vlan"
)

// UnmarshalNetwork unmarshals an instance of Network from the specified map of raw messages.
func UnmarshalNetwork(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Network)
	err = core.UnmarshalPrimitive(m, "accessConfig", &obj.AccessConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cidr", &obj.CIDR)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "cloudConnections", &obj.CloudConnections, UnmarshalNetworkCloudConnectionsItem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dhcpManaged", &obj.DhcpManaged)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dnsServers", &obj.DnsServers)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "gateway", &obj.Gateway)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ipAddressMetrics", &obj.IPAddressMetrics, UnmarshalNetworkIPAddressMetrics)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ipAddressRanges", &obj.IPAddressRanges, UnmarshalIPAddressRange)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "jumbo", &obj.Jumbo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "networkID", &obj.NetworkID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "publicIPAddressRanges", &obj.PublicIPAddressRanges, UnmarshalIPAddressRange)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vlanID", &obj.VlanID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkCloudConnectionsItem : NetworkCloudConnectionsItem struct
type NetworkCloudConnectionsItem struct {
	// the cloud connection id.
	CloudConnectionID *string `json:"cloudConnectionID,omitempty"`

	// link to the cloud connection resource.
	Href *string `json:"href,omitempty"`
}

// UnmarshalNetworkCloudConnectionsItem unmarshals an instance of NetworkCloudConnectionsItem from the specified map of raw messages.
func UnmarshalNetworkCloudConnectionsItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkCloudConnectionsItem)
	err = core.UnmarshalPrimitive(m, "cloudConnectionID", &obj.CloudConnectionID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkIDs : NetworkIDs struct
type NetworkIDs struct {
	// an array of network IDs.
	NetworkIDs []string `json:"networkIDs,omitempty"`
}

// UnmarshalNetworkIDs unmarshals an instance of NetworkIDs from the specified map of raw messages.
func UnmarshalNetworkIDs(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkIDs)
	err = core.UnmarshalPrimitive(m, "networkIDs", &obj.NetworkIDs)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkIPAddressMetrics : IP Address Metrics.
type NetworkIPAddressMetrics struct {
	// Number of available IP addresses.
	Available *float64 `json:"available" validate:"required"`

	// Total number of all IP addresses in all ipAddressRanges.
	Total *float64 `json:"total" validate:"required"`

	// Number of IP addresses currently in use.
	Used *float64 `json:"used" validate:"required"`

	// Utilization of IP addresses in percent form (used / total) [0 - 100].
	Utilization *float64 `json:"utilization" validate:"required"`
}

// UnmarshalNetworkIPAddressMetrics unmarshals an instance of NetworkIPAddressMetrics from the specified map of raw messages.
func UnmarshalNetworkIPAddressMetrics(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkIPAddressMetrics)
	err = core.UnmarshalPrimitive(m, "available", &obj.Available)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "total", &obj.Total)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "used", &obj.Used)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "utilization", &obj.Utilization)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkPort : NetworkPort struct
type NetworkPort struct {
	// Description of the port (not unique or indexable).
	Description *string `json:"description" validate:"required"`

	// The external ip address (for pub-vlan networks).
	ExternalIP *string `json:"externalIP,omitempty"`

	// Link to port resource.
	Href *string `json:"href,omitempty"`

	// The ip address of this port.
	IPAddress *string `json:"ipAddress" validate:"required"`

	// The mac address of the network interface.
	MacAddress *string `json:"macAddress" validate:"required"`

	// The unique Port ID.
	PortID *string `json:"portID" validate:"required"`

	// The attached pvm-instance to this port.
	PvmInstance *NetworkPortPvmInstance `json:"pvmInstance,omitempty"`

	// Te.
	Status *string `json:"status" validate:"required"`
}

// UnmarshalNetworkPort unmarshals an instance of NetworkPort from the specified map of raw messages.
func UnmarshalNetworkPort(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkPort)
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "externalIP", &obj.ExternalIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ipAddress", &obj.IPAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "macAddress", &obj.MacAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "portID", &obj.PortID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "pvmInstance", &obj.PvmInstance, UnmarshalNetworkPortPvmInstance)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkPortPvmInstance : The attached pvm-instance to this port.
type NetworkPortPvmInstance struct {
	// Link to pvm-instance resource.
	Href *string `json:"href,omitempty"`

	// The attahed pvm-instance ID.
	PvmInstanceID *string `json:"pvmInstanceID,omitempty"`
}

// UnmarshalNetworkPortPvmInstance unmarshals an instance of NetworkPortPvmInstance from the specified map of raw messages.
func UnmarshalNetworkPortPvmInstance(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkPortPvmInstance)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pvmInstanceID", &obj.PvmInstanceID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkPorts : NetworkPorts struct
type NetworkPorts struct {
	// Network Ports.
	Ports []NetworkPort `json:"ports" validate:"required"`
}

// UnmarshalNetworkPorts unmarshals an instance of NetworkPorts from the specified map of raw messages.
func UnmarshalNetworkPorts(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkPorts)
	err = core.UnmarshalModel(m, "ports", &obj.Ports, UnmarshalNetworkPort)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// NetworkReference : NetworkReference struct
type NetworkReference struct {
	// Network communication configuration (for satellite locations only)
	//   * `internal-only` - network is only used for internal host communication
	//   * `outbound-only` - network will be capable of egress traffic
	//   * `bidirectional-static-route` - network will be capable of ingress and egress traffic via static routes
	//   * `bidirectional-bgp` - network will be capable of ingress and egress traffic via bgp configuration
	//   * `bidirectional-l2out` - network will be capable of ingress and egress traffic via l2out ACI configuration.
	AccessConfig *string `json:"accessConfig,omitempty"`

	// DHCP Managed Network.
	DhcpManaged *bool `json:"dhcpManaged,omitempty"`

	// Link to Network resource.
	Href *string `json:"href" validate:"required"`

	// Enable MTU Jumbo Network (for multi-zone locations only).
	Jumbo *bool `json:"jumbo,omitempty"`

	// Maximum transmission unit (for satellite locations only).
	Mtu *int64 `json:"mtu,omitempty"`

	// Network Name.
	Name *string `json:"name" validate:"required"`

	// Unique Network ID.
	NetworkID *string `json:"networkID" validate:"required"`

	// Type of Network - 'vlan' (private network) 'pub-vlan' (public network) 'dhcp-vlan' (for satellite locations only).
	Type *string `json:"type" validate:"required"`

	// VLAN ID.
	VlanID *float64 `json:"vlanID" validate:"required"`
}

// Constants associated with the NetworkReference.AccessConfig property.
// Network communication configuration (for satellite locations only)
//   * `internal-only` - network is only used for internal host communication
//   * `outbound-only` - network will be capable of egress traffic
//   * `bidirectional-static-route` - network will be capable of ingress and egress traffic via static routes
//   * `bidirectional-bgp` - network will be capable of ingress and egress traffic via bgp configuration
//   * `bidirectional-l2out` - network will be capable of ingress and egress traffic via l2out ACI configuration.
const (
	NetworkReferenceAccessConfigBidirectionalBgpConst = "bidirectional-bgp"
	NetworkReferenceAccessConfigBidirectionalL2outConst = "bidirectional-l2out"
	NetworkReferenceAccessConfigBidirectionalStaticRouteConst = "bidirectional-static-route"
	NetworkReferenceAccessConfigInternalOnlyConst = "internal-only"
	NetworkReferenceAccessConfigOutboundOnlyConst = "outbound-only"
)

// Constants associated with the NetworkReference.Type property.
// Type of Network - 'vlan' (private network) 'pub-vlan' (public network) 'dhcp-vlan' (for satellite locations only).
const (
	NetworkReferenceTypeDhcpVlanConst = "dhcp-vlan"
	NetworkReferenceTypePubVlanConst = "pub-vlan"
	NetworkReferenceTypeVlanConst = "vlan"
)

// UnmarshalNetworkReference unmarshals an instance of NetworkReference from the specified map of raw messages.
func UnmarshalNetworkReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(NetworkReference)
	err = core.UnmarshalPrimitive(m, "accessConfig", &obj.AccessConfig)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dhcpManaged", &obj.DhcpManaged)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "jumbo", &obj.Jumbo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mtu", &obj.Mtu)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "networkID", &obj.NetworkID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vlanID", &obj.VlanID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Networks : Networks struct
type Networks struct {
	// Network References.
	Networks []NetworkReference `json:"networks" validate:"required"`
}

// UnmarshalNetworks unmarshals an instance of Networks from the specified map of raw messages.
func UnmarshalNetworks(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Networks)
	err = core.UnmarshalModel(m, "networks", &obj.Networks, UnmarshalNetworkReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Object : Object struct
type Object struct {

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// SetProperty allows the user to set an arbitrary property on an instance of Object
func (o *Object) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of Object
func (o *Object) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of Object
func (o *Object) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of Object
func (o *Object) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of Object
func (o *Object) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalObject unmarshals an instance of Object from the specified map of raw messages.
func UnmarshalObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Object)
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OpenStack : OpenStack struct
type OpenStack struct {
	// Unique identifier for the OpenStack instance.
	ID *string `json:"id" validate:"required"`

	// Internal IP address of the OpenStack instance.
	IPAddress *string `json:"ipAddress" validate:"required"`

	// Shortname of the OpenStack instance.
	Name *string `json:"name" validate:"required"`

	// Next available VLAN ID to be used for a network creation.
	NextVlanid *float64 `json:"nextVLANID" validate:"required"`

	// The region where the open stack lives.
	Region *string `json:"region" validate:"required"`
}

// UnmarshalOpenStack unmarshals an instance of OpenStack from the specified map of raw messages.
func UnmarshalOpenStack(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OpenStack)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ipAddress", &obj.IPAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "nextVLANID", &obj.NextVlanid)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OpenStackInfo : OpenStackInfo struct
type OpenStackInfo struct {
	// Hosts on OpenStack.
	Hosts []HostInfo `json:"hosts" validate:"required"`

	// Requested region.
	Region *string `json:"region" validate:"required"`
}

// UnmarshalOpenStackInfo unmarshals an instance of OpenStackInfo from the specified map of raw messages.
func UnmarshalOpenStackInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OpenStackInfo)
	err = core.UnmarshalModel(m, "hosts", &obj.Hosts, UnmarshalHostInfo)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OpenStacks : OpenStacks struct
type OpenStacks struct {
	// OpenStacks managed by Power IAAS.
	OpenStacks []OpenStack `json:"openStacks" validate:"required"`
}

// UnmarshalOpenStacks unmarshals an instance of OpenStacks from the specified map of raw messages.
func UnmarshalOpenStacks(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OpenStacks)
	err = core.UnmarshalModel(m, "openStacks", &obj.OpenStacks, UnmarshalOpenStack)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Operation : Operation struct
type Operation struct {
	// current action of the operation.
	Action *string `json:"action" validate:"required"`

	// ID of an operation.
	ID *string `json:"id" validate:"required"`

	// target resource of the operation.
	Target *string `json:"target" validate:"required"`
}

// UnmarshalOperation unmarshals an instance of Operation from the specified map of raw messages.
func UnmarshalOperation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Operation)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "target", &obj.Target)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Operations : Operations struct
type Operations struct {
	// Name of the server boot mode a(Boot from disk using copy A), b(Boot from disk using copy B), c(Reserved for IBM lab
	// use only), d(Boot from media/drives).
	BootMode *string `json:"bootMode,omitempty"`

	// Name of the server operating mode.
	OperatingMode *string `json:"operatingMode,omitempty"`

	// Name of the job task to execute.
	Task *string `json:"task,omitempty"`
}

// Constants associated with the Operations.BootMode property.
// Name of the server boot mode a(Boot from disk using copy A), b(Boot from disk using copy B), c(Reserved for IBM lab
// use only), d(Boot from media/drives).
const (
	OperationsBootModeAConst = "a"
	OperationsBootModeBConst = "b"
	OperationsBootModeCConst = "c"
	OperationsBootModeDConst = "d"
)

// Constants associated with the Operations.OperatingMode property.
// Name of the server operating mode.
const (
	OperationsOperatingModeManualConst = "manual"
	OperationsOperatingModeNormalConst = "normal"
)

// Constants associated with the Operations.Task property.
// Name of the job task to execute.
const (
	OperationsTaskConsoleserviceConst = "consoleservice"
	OperationsTaskDstonConst = "dston"
	OperationsTaskDumprestartConst = "dumprestart"
	OperationsTaskIopdumpConst = "iopdump"
	OperationsTaskIopresetConst = "iopreset"
	OperationsTaskRemotedstoffConst = "remotedstoff"
	OperationsTaskRemotedstonConst = "remotedston"
	OperationsTaskRetrydumpConst = "retrydump"
)

// UnmarshalOperations unmarshals an instance of Operations from the specified map of raw messages.
func UnmarshalOperations(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Operations)
	err = core.UnmarshalPrimitive(m, "bootMode", &obj.BootMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "operatingMode", &obj.OperatingMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "task", &obj.Task)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// OwnerInfo : OwnerInfo struct
type OwnerInfo struct {
	// Country code of user.
	CountryCode *string `json:"countryCode" validate:"required"`

	// Currency code of user.
	CurrencyCode *string `json:"currencyCode" validate:"required"`

	// Email address of user.
	Email *string `json:"email" validate:"required"`

	// IAM id of user.
	IamID *string `json:"iamID" validate:"required"`

	// Indicates if user is an IBMer.
	IsIbMer *bool `json:"isIBMer" validate:"required"`

	// Name of user.
	Name *string `json:"name" validate:"required"`

	// (deprecated - replaced by softlayerSubscriptions) Array of Soft Layer IDs.
	SoftlayerIDs []string `json:"softlayerIDs,omitempty"`

	// Array of softlayer subscriptions.
	SoftlayerSubscriptions []SoftlayerSubscription `json:"softlayerSubscriptions" validate:"required"`

	// User id of user.
	UserID *string `json:"userID" validate:"required"`
}

// UnmarshalOwnerInfo unmarshals an instance of OwnerInfo from the specified map of raw messages.
func UnmarshalOwnerInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(OwnerInfo)
	err = core.UnmarshalPrimitive(m, "countryCode", &obj.CountryCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "currencyCode", &obj.CurrencyCode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "email", &obj.Email)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iamID", &obj.IamID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "isIBMer", &obj.IsIbMer)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "softlayerIDs", &obj.SoftlayerIDs)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "softlayerSubscriptions", &obj.SoftlayerSubscriptions, UnmarshalSoftlayerSubscription)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "userID", &obj.UserID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstance : PvmInstance struct
type PvmInstance struct {
	// (deprecated - replaced by networks) The list of addresses and their network information.
	Addresses []PvmInstanceNetwork `json:"addresses,omitempty"`

	ConsoleLanguage *ConsoleLanguage `json:"consoleLanguage,omitempty"`

	// Date/Time of PVM creation.
	CreationDate *strfmt.DateTime `json:"creationDate,omitempty"`

	// The custom deployment type.
	DeploymentType *string `json:"deploymentType,omitempty"`

	// Size of allocated disk (in GB).
	DiskSize *float64 `json:"diskSize" validate:"required"`

	// Fault information (if occurred).
	Fault *PvmInstanceFault `json:"fault,omitempty"`

	// PVM's health status details.
	Health *PvmInstanceHealth `json:"health,omitempty"`

	// The PVM Instance Host ID (Internal Use Only).
	HostID *int64 `json:"hostID,omitempty"`

	// The ImageID used by the server.
	ImageID *string `json:"imageID" validate:"required"`

	// The VTL license repository capacity TB value.
	LicenseRepositoryCapacity *int64 `json:"licenseRepositoryCapacity,omitempty"`

	// Maximum amount of memory that can be allocated (in GB, for resize).
	Maxmem *float64 `json:"maxmem,omitempty"`

	// Maximum number of processors that can be allocated (for resize).
	Maxproc *float64 `json:"maxproc,omitempty"`

	// Amount of memory allocated (in GB).
	Memory *float64 `json:"memory" validate:"required"`

	// whether the instance can be migrated.
	Migratable *bool `json:"migratable,omitempty"`

	// Minimum amount of memory that can be allocated (in GB, for resize).
	Minmem *float64 `json:"minmem,omitempty"`

	// Minimum number of processors that can be allocated (for resize).
	Minproc *float64 `json:"minproc,omitempty"`

	// (deprecated - replaced by networks) List of Network IDs.
	NetworkIDs []string `json:"networkIDs" validate:"required"`

	// The pvm instance networks information.
	Networks []PvmInstanceNetwork `json:"networks,omitempty"`

	// OS system information (usually version and build).
	OperatingSystem *string `json:"operatingSystem,omitempty"`

	// Type of the OS [aix, ibmi, rhel, sles, vtl, rhcos].
	OsType *string `json:"osType" validate:"required"`

	// VM pinning policy to use [none, soft, hard].
	PinPolicy *string `json:"pinPolicy,omitempty"`

	// The placement group of the server.
	PlacementGroup *string `json:"placementGroup,omitempty"`

	// Processor type (dedicated, shared, capped).
	ProcType *string `json:"procType" validate:"required"`

	// Number of processors allocated.
	Processors *float64 `json:"processors" validate:"required"`

	// The progress of an operation.
	Progress *float64 `json:"progress,omitempty"`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvmInstanceID" validate:"required"`

	SapProfile *SapProfileReference `json:"sapProfile,omitempty"`

	// Name of the server.
	ServerName *string `json:"serverName" validate:"required"`

	// The shared processor pool of the server.
	SharedProcessorPool *string `json:"sharedProcessorPool,omitempty"`

	// The shared processor pool id.
	SharedProcessorPoolID *string `json:"sharedProcessorPoolID,omitempty"`

	SoftwareLicenses *SoftwareLicenses `json:"softwareLicenses,omitempty"`

	// The pvm instance SRC lists.
	Srcs [][]Src `json:"srcs,omitempty"`

	// The status of the instance.
	Status *string `json:"status" validate:"required"`

	// The storage connection type.
	StorageConnection *string `json:"storageConnection,omitempty"`

	// Storage Pool where server is deployed.
	StoragePool *string `json:"storagePool,omitempty"`

	// Indicates if all volumes attached to the server must reside in the same storage pool; Defaults to true when
	// initially deploying a PVMInstance.
	StoragePoolAffinity *bool `json:"storagePoolAffinity,omitempty"`

	// Storage type where server is deployed.
	StorageType *string `json:"storageType" validate:"required"`

	// System type used to host the instance.
	SysType *string `json:"sysType,omitempty"`

	// Date/Time of PVM last update.
	UpdatedDate *strfmt.DateTime `json:"updatedDate,omitempty"`

	VirtualCores *VirtualCores `json:"virtualCores,omitempty"`

	// List of volume IDs.
	VolumeIDs []string `json:"volumeIDs" validate:"required"`
}

// Constants associated with the PvmInstance.ProcType property.
// Processor type (dedicated, shared, capped).
const (
	PvmInstanceProcTypeCappedConst = "capped"
	PvmInstanceProcTypeDedicatedConst = "dedicated"
	PvmInstanceProcTypeSharedConst = "shared"
)

// UnmarshalPvmInstance unmarshals an instance of PvmInstance from the specified map of raw messages.
func UnmarshalPvmInstance(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstance)
	err = core.UnmarshalModel(m, "addresses", &obj.Addresses, UnmarshalPvmInstanceNetwork)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "consoleLanguage", &obj.ConsoleLanguage, UnmarshalConsoleLanguage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "creationDate", &obj.CreationDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "deploymentType", &obj.DeploymentType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "diskSize", &obj.DiskSize)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "fault", &obj.Fault, UnmarshalPvmInstanceFault)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health", &obj.Health, UnmarshalPvmInstanceHealth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "hostID", &obj.HostID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "imageID", &obj.ImageID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "licenseRepositoryCapacity", &obj.LicenseRepositoryCapacity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "maxmem", &obj.Maxmem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "maxproc", &obj.Maxproc)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "migratable", &obj.Migratable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "minmem", &obj.Minmem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "minproc", &obj.Minproc)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "networkIDs", &obj.NetworkIDs)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "networks", &obj.Networks, UnmarshalPvmInstanceNetwork)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "operatingSystem", &obj.OperatingSystem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "osType", &obj.OsType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pinPolicy", &obj.PinPolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "placementGroup", &obj.PlacementGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "procType", &obj.ProcType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "processors", &obj.Processors)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "progress", &obj.Progress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pvmInstanceID", &obj.PvmInstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sapProfile", &obj.SapProfile, UnmarshalSapProfileReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serverName", &obj.ServerName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sharedProcessorPool", &obj.SharedProcessorPool)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sharedProcessorPoolID", &obj.SharedProcessorPoolID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "softwareLicenses", &obj.SoftwareLicenses, UnmarshalSoftwareLicenses)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "srcs", &obj.Srcs, UnmarshalSrc)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storageConnection", &obj.StorageConnection)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storagePool", &obj.StoragePool)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storagePoolAffinity", &obj.StoragePoolAffinity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storageType", &obj.StorageType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sysType", &obj.SysType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updatedDate", &obj.UpdatedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "virtualCores", &obj.VirtualCores, UnmarshalVirtualCores)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "volumeIDs", &obj.VolumeIDs)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceAddNetwork : PvmInstanceAddNetwork struct
type PvmInstanceAddNetwork struct {
	// The requested ip address of this network interface.
	IPAddress *string `json:"ipAddress,omitempty"`

	// ID of the network.
	NetworkID *string `json:"networkID" validate:"required"`
}

// NewPvmInstanceAddNetwork : Instantiate PvmInstanceAddNetwork (Generic Model Constructor)
func (*PowervsV1) NewPvmInstanceAddNetwork(networkID string) (_model *PvmInstanceAddNetwork, err error) {
	_model = &PvmInstanceAddNetwork{
		NetworkID: core.StringPtr(networkID),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalPvmInstanceAddNetwork unmarshals an instance of PvmInstanceAddNetwork from the specified map of raw messages.
func UnmarshalPvmInstanceAddNetwork(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceAddNetwork)
	err = core.UnmarshalPrimitive(m, "ipAddress", &obj.IPAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "networkID", &obj.NetworkID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceConfiguration : PvmInstanceConfiguration struct
type PvmInstanceConfiguration struct {
	ConsoleLanguage *ConsoleLanguage `json:"consoleLanguage,omitempty"`

	// The VTL license repository capacity TB value.
	LicenseRepositoryCapacity *int64 `json:"licenseRepositoryCapacity,omitempty"`

	SapProfile *SapProfileReference `json:"sapProfile,omitempty"`

	SoftwareLicenses *SoftwareLicenses `json:"softwareLicenses,omitempty"`

	// The pvm instance system reference code lists.
	SystemReferenceCodes [][]Src `json:"systemReferenceCodes,omitempty"`
}

// UnmarshalPvmInstanceConfiguration unmarshals an instance of PvmInstanceConfiguration from the specified map of raw messages.
func UnmarshalPvmInstanceConfiguration(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceConfiguration)
	err = core.UnmarshalModel(m, "consoleLanguage", &obj.ConsoleLanguage, UnmarshalConsoleLanguage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "licenseRepositoryCapacity", &obj.LicenseRepositoryCapacity)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sapProfile", &obj.SapProfile, UnmarshalSapProfileReference)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "softwareLicenses", &obj.SoftwareLicenses, UnmarshalSoftwareLicenses)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "systemReferenceCodes", &obj.SystemReferenceCodes, UnmarshalSrc)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceConsole : PvmInstanceConsole struct
type PvmInstanceConsole struct {
	// The URL to the noVNC console for the PVM Instance.
	ConsoleURL *string `json:"consoleURL" validate:"required"`
}

// UnmarshalPvmInstanceConsole unmarshals an instance of PvmInstanceConsole from the specified map of raw messages.
func UnmarshalPvmInstanceConsole(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceConsole)
	err = core.UnmarshalPrimitive(m, "consoleURL", &obj.ConsoleURL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceCores : PvmInstanceCores struct
type PvmInstanceCores struct {
	// The active processor information.
	Assigned *float64 `json:"assigned" validate:"required"`

	// The maximum number of processors that can be allocated (for resize).
	Maximum *float64 `json:"maximum,omitempty"`

	// The minimum number of processors that can be allocated (for resize).
	Minimum *float64 `json:"minimum,omitempty"`
}

// UnmarshalPvmInstanceCores unmarshals an instance of PvmInstanceCores from the specified map of raw messages.
func UnmarshalPvmInstanceCores(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceCores)
	err = core.UnmarshalPrimitive(m, "assigned", &obj.Assigned)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "maximum", &obj.Maximum)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "minimum", &obj.Minimum)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceFault : Fault information (if occurred).
type PvmInstanceFault struct {
	// The fault status of the server, if any.
	Code *float64 `json:"code,omitempty"`

	// The date and time the fault occurred.
	Created *strfmt.DateTime `json:"created,omitempty"`

	// The fault details of the server, if any.
	Details *string `json:"details,omitempty"`

	// The fault message of the server, if any.
	Message *string `json:"message,omitempty"`
}

// UnmarshalPvmInstanceFault unmarshals an instance of PvmInstanceFault from the specified map of raw messages.
func UnmarshalPvmInstanceFault(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceFault)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "created", &obj.Created)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "details", &obj.Details)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceHealth : PVM's health status details.
type PvmInstanceHealth struct {
	// Date/Time of PVM last health status change.
	LastUpdate *string `json:"lastUpdate,omitempty"`

	// The health status reason, if any.
	Reason *string `json:"reason,omitempty"`

	// The PVM's health status value.
	Status *string `json:"status,omitempty"`
}

// UnmarshalPvmInstanceHealth unmarshals an instance of PvmInstanceHealth from the specified map of raw messages.
func UnmarshalPvmInstanceHealth(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceHealth)
	err = core.UnmarshalPrimitive(m, "lastUpdate", &obj.LastUpdate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reason", &obj.Reason)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceMemory : PvmInstanceMemory struct
type PvmInstanceMemory struct {
	// The active memory information.
	Assigned *float64 `json:"assigned" validate:"required"`

	// The maximum amount of memory that can be allocated (in GB, for resize).
	Maximum *float64 `json:"maximum,omitempty"`

	// The minimum amount of memory that can be allocated (in GB, for resize).
	Minimum *float64 `json:"minimum,omitempty"`
}

// UnmarshalPvmInstanceMemory unmarshals an instance of PvmInstanceMemory from the specified map of raw messages.
func UnmarshalPvmInstanceMemory(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceMemory)
	err = core.UnmarshalPrimitive(m, "assigned", &obj.Assigned)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "maximum", &obj.Maximum)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "minimum", &obj.Minimum)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceMultiCreate : PvmInstanceMultiCreate struct
type PvmInstanceMultiCreate struct {
	// Affinity policy for pvm-instances being created; affinity for the same host, anti-affinity for different hosts, none
	// for no preference.
	AffinityPolicy *string `json:"affinityPolicy,omitempty"`

	// Number of pvm-instances to create.
	Count *int64 `json:"count,omitempty"`

	// Where to place the numerical number of the multi-created instance.
	Numerical *string `json:"numerical,omitempty"`
}

// Constants associated with the PvmInstanceMultiCreate.AffinityPolicy property.
// Affinity policy for pvm-instances being created; affinity for the same host, anti-affinity for different hosts, none
// for no preference.
const (
	PvmInstanceMultiCreateAffinityPolicyAffinityConst = "affinity"
	PvmInstanceMultiCreateAffinityPolicyAntiAffinityConst = "anti-affinity"
	PvmInstanceMultiCreateAffinityPolicyNoneConst = "none"
)

// Constants associated with the PvmInstanceMultiCreate.Numerical property.
// Where to place the numerical number of the multi-created instance.
const (
	PvmInstanceMultiCreateNumericalPrefixConst = "prefix"
	PvmInstanceMultiCreateNumericalSuffixConst = "suffix"
)

// UnmarshalPvmInstanceMultiCreate unmarshals an instance of PvmInstanceMultiCreate from the specified map of raw messages.
func UnmarshalPvmInstanceMultiCreate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceMultiCreate)
	err = core.UnmarshalPrimitive(m, "affinityPolicy", &obj.AffinityPolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "count", &obj.Count)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "numerical", &obj.Numerical)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceNetwork : A map containing information about a network address.
type PvmInstanceNetwork struct {
	// The external ip address (for pub-vlan networks).
	ExternalIP *string `json:"externalIP,omitempty"`

	// Link to PVM Instance Network.
	Href *string `json:"href,omitempty"`

	// (deprecated - replaced by ipAddress).
	IP *string `json:"ip,omitempty"`

	// The ip address of this network interface.
	IPAddress *string `json:"ipAddress,omitempty"`

	// The mac address of the network interface.
	MacAddress *string `json:"macAddress,omitempty"`

	// ID of the network.
	NetworkID *string `json:"networkID,omitempty"`

	// The name of the network the address is on.
	NetworkName *string `json:"networkName,omitempty"`

	// The address type (fixed or dynamic).
	Type *string `json:"type,omitempty"`

	// The version of the information provided.
	Version *float64 `json:"version,omitempty"`
}

// UnmarshalPvmInstanceNetwork unmarshals an instance of PvmInstanceNetwork from the specified map of raw messages.
func UnmarshalPvmInstanceNetwork(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceNetwork)
	err = core.UnmarshalPrimitive(m, "externalIP", &obj.ExternalIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ip", &obj.IP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ipAddress", &obj.IPAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "macAddress", &obj.MacAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "networkID", &obj.NetworkID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "networkName", &obj.NetworkName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceNetworks : PvmInstanceNetworks struct
type PvmInstanceNetworks struct {
	// PVM Instance Networks.
	Networks []PvmInstanceNetwork `json:"networks" validate:"required"`
}

// UnmarshalPvmInstanceNetworks unmarshals an instance of PvmInstanceNetworks from the specified map of raw messages.
func UnmarshalPvmInstanceNetworks(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceNetworks)
	err = core.UnmarshalModel(m, "networks", &obj.Networks, UnmarshalPvmInstanceNetwork)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceOperatingSystem : PvmInstanceOperatingSystem struct
type PvmInstanceOperatingSystem struct {
	// Type of the OS [aix, ibmi, rhel, sles, vtl, rhcos].
	Type *string `json:"type" validate:"required"`

	// OS system information (usually version and build).
	Version *string `json:"version,omitempty"`
}

// UnmarshalPvmInstanceOperatingSystem unmarshals an instance of PvmInstanceOperatingSystem from the specified map of raw messages.
func UnmarshalPvmInstanceOperatingSystem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceOperatingSystem)
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceReference : PvmInstanceReference struct
type PvmInstanceReference struct {
	// (deprecated - replaced by networks) The list of addresses and their network information.
	Addresses []PvmInstanceNetwork `json:"addresses,omitempty"`

	ConsoleLanguage *ConsoleLanguage `json:"consoleLanguage,omitempty"`

	// Date/Time of PVM creation.
	CreationDate *strfmt.DateTime `json:"creationDate,omitempty"`

	// Size of allocated disk (in GB).
	DiskSize *float64 `json:"diskSize" validate:"required"`

	// Fault information (if occurred).
	Fault *PvmInstanceFault `json:"fault,omitempty"`

	// PVM's health status details.
	Health *PvmInstanceHealth `json:"health,omitempty"`

	// The PVM Instance Host ID (Internal Use Only).
	HostID *int64 `json:"hostID,omitempty"`

	// Link to Cloud Instance resource.
	Href *string `json:"href" validate:"required"`

	// The ImageID used by the server.
	ImageID *string `json:"imageID" validate:"required"`

	// The VTL license repository capacity TB value.
	LicenseRepositoryCapacity *int64 `json:"licenseRepositoryCapacity,omitempty"`

	// Maximum amount of memory that can be allocated (in GB, for resize).
	Maxmem *float64 `json:"maxmem,omitempty"`

	// Maximum number of processors that can be allocated (for resize).
	Maxproc *float64 `json:"maxproc,omitempty"`

	// Amount of memory allocated (in GB).
	Memory *float64 `json:"memory" validate:"required"`

	// Minimum amount of memory that can be allocated (in GB, for resize).
	Minmem *float64 `json:"minmem,omitempty"`

	// Minimum number of processors that can be allocated (for resize).
	Minproc *float64 `json:"minproc,omitempty"`

	// The list of addresses and their network information.
	Networks []PvmInstanceNetwork `json:"networks,omitempty"`

	// OS system information (usually version and build).
	OperatingSystem *string `json:"operatingSystem,omitempty"`

	// Type of the OS [aix, ibmi, rhel, sles, vtl, rhcos].
	OsType *string `json:"osType" validate:"required"`

	// VM pinning policy to use [none, soft, hard].
	PinPolicy *string `json:"pinPolicy,omitempty"`

	// The placement group of the server.
	PlacementGroup *string `json:"placementGroup,omitempty"`

	// Processor type (dedicated, shared, capped).
	ProcType *string `json:"procType" validate:"required"`

	// Number of processors allocated.
	Processors *float64 `json:"processors" validate:"required"`

	// The progress of an operation.
	Progress *float64 `json:"progress,omitempty"`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvmInstanceID" validate:"required"`

	SapProfile *SapProfileReference `json:"sapProfile,omitempty"`

	// Name of the server.
	ServerName *string `json:"serverName" validate:"required"`

	// The shared processor pool of the server.
	SharedProcessorPool *string `json:"sharedProcessorPool,omitempty"`

	// The shared processor pool id.
	SharedProcessorPoolID *string `json:"sharedProcessorPoolID,omitempty"`

	SoftwareLicenses *SoftwareLicenses `json:"softwareLicenses,omitempty"`

	// The pvm instance SRC lists.
	Srcs [][]Src `json:"srcs,omitempty"`

	// The status of the instance.
	Status *string `json:"status" validate:"required"`

	// The storage connection type.
	StorageConnection *string `json:"storageConnection,omitempty"`

	// Storage Pool where server is deployed.
	StoragePool *string `json:"storagePool,omitempty"`

	// Indicates if all volumes attached to the server must reside in the same storage pool.
	StoragePoolAffinity *bool `json:"storagePoolAffinity,omitempty"`

	// Storage type of the deployment storage pool.
	StorageType *string `json:"storageType,omitempty"`

	// System type used to host the instance.
	SysType *string `json:"sysType,omitempty"`

	// Date/Time of PVM last update.
	UpdatedDate *strfmt.DateTime `json:"updatedDate,omitempty"`

	VirtualCores *VirtualCores `json:"virtualCores,omitempty"`
}

// Constants associated with the PvmInstanceReference.ProcType property.
// Processor type (dedicated, shared, capped).
const (
	PvmInstanceReferenceProcTypeCappedConst = "capped"
	PvmInstanceReferenceProcTypeDedicatedConst = "dedicated"
	PvmInstanceReferenceProcTypeSharedConst = "shared"
)

// UnmarshalPvmInstanceReference unmarshals an instance of PvmInstanceReference from the specified map of raw messages.
func UnmarshalPvmInstanceReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceReference)
	err = core.UnmarshalModel(m, "addresses", &obj.Addresses, UnmarshalPvmInstanceNetwork)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "consoleLanguage", &obj.ConsoleLanguage, UnmarshalConsoleLanguage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "creationDate", &obj.CreationDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "diskSize", &obj.DiskSize)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "fault", &obj.Fault, UnmarshalPvmInstanceFault)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health", &obj.Health, UnmarshalPvmInstanceHealth)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "hostID", &obj.HostID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "imageID", &obj.ImageID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "licenseRepositoryCapacity", &obj.LicenseRepositoryCapacity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "maxmem", &obj.Maxmem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "maxproc", &obj.Maxproc)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "minmem", &obj.Minmem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "minproc", &obj.Minproc)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "networks", &obj.Networks, UnmarshalPvmInstanceNetwork)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "operatingSystem", &obj.OperatingSystem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "osType", &obj.OsType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pinPolicy", &obj.PinPolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "placementGroup", &obj.PlacementGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "procType", &obj.ProcType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "processors", &obj.Processors)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "progress", &obj.Progress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pvmInstanceID", &obj.PvmInstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sapProfile", &obj.SapProfile, UnmarshalSapProfileReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serverName", &obj.ServerName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sharedProcessorPool", &obj.SharedProcessorPool)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sharedProcessorPoolID", &obj.SharedProcessorPoolID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "softwareLicenses", &obj.SoftwareLicenses, UnmarshalSoftwareLicenses)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "srcs", &obj.Srcs, UnmarshalSrc)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storageConnection", &obj.StorageConnection)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storagePool", &obj.StoragePool)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storagePoolAffinity", &obj.StoragePoolAffinity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storageType", &obj.StorageType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sysType", &obj.SysType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "updatedDate", &obj.UpdatedDate)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "virtualCores", &obj.VirtualCores, UnmarshalVirtualCores)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceReferenceV2 : PvmInstanceReferenceV2 struct
type PvmInstanceReferenceV2 struct {
	Configuration *PvmInstanceConfiguration `json:"configuration,omitempty"`

	Cores *PvmInstanceCores `json:"cores" validate:"required"`

	// Date/Time of PVM creation.
	CreationDate *strfmt.DateTime `json:"creationDate,omitempty"`

	Deployment *PvmInstanceDeployment `json:"deployment" validate:"required"`

	// PVM's health status details.
	Health *PvmInstanceV2Health `json:"health,omitempty"`

	Host *PvmInstanceHost `json:"host,omitempty"`

	// Link to Cloud Instance resource.
	Href *string `json:"href" validate:"required"`

	// PCloud PVM Instance ID.
	ID *string `json:"id" validate:"required"`

	Memory *PvmInstanceMemory `json:"memory" validate:"required"`

	// Name of the server.
	Name *string `json:"name" validate:"required"`

	// The pvm instance network ports information.
	NetworkPorts []PvmInstanceV2NetworkPort `json:"networkPorts" validate:"required"`

	OperatingSystem *PvmInstanceOperatingSystem `json:"operatingSystem" validate:"required"`

	PlacementGroup *PvmInstancePlacementGroup `json:"placementGroup,omitempty"`

	// The status of the instance.
	Status *string `json:"status" validate:"required"`

	VirtualCores *PvmInstanceVirtualCores `json:"virtualCores,omitempty"`
}

// UnmarshalPvmInstanceReferenceV2 unmarshals an instance of PvmInstanceReferenceV2 from the specified map of raw messages.
func UnmarshalPvmInstanceReferenceV2(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceReferenceV2)
	err = core.UnmarshalModel(m, "configuration", &obj.Configuration, UnmarshalPvmInstanceConfiguration)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "cores", &obj.Cores, UnmarshalPvmInstanceCores)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "creationDate", &obj.CreationDate)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "deployment", &obj.Deployment, UnmarshalPvmInstanceDeployment)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "health", &obj.Health, UnmarshalPvmInstanceV2Health)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "host", &obj.Host, UnmarshalPvmInstanceHost)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "memory", &obj.Memory, UnmarshalPvmInstanceMemory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "networkPorts", &obj.NetworkPorts, UnmarshalPvmInstanceV2NetworkPort)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "operatingSystem", &obj.OperatingSystem, UnmarshalPvmInstanceOperatingSystem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "placementGroup", &obj.PlacementGroup, UnmarshalPvmInstancePlacementGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "virtualCores", &obj.VirtualCores, UnmarshalPvmInstanceVirtualCores)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceUpdateResponse : PvmInstanceUpdateResponse struct
type PvmInstanceUpdateResponse struct {
	// The VTL license repository capacity TB value.
	LicenseRepositoryCapacity *int64 `json:"licenseRepositoryCapacity,omitempty"`

	// Amount of memory allocated (in GB).
	Memory *float64 `json:"memory,omitempty"`

	// Specify PVM pin policy.
	PinPolicy *string `json:"pinPolicy,omitempty"`

	// Processor type (dedicated, shared, capped).
	ProcType *string `json:"procType,omitempty"`

	// Number of processors allocated.
	Processors *float64 `json:"processors,omitempty"`

	// Name of the server to create.
	ServerName *string `json:"serverName,omitempty"`

	// URL to check for status of the operation (for now, just the URL for the GET on the server, which has status
	// information from powervc).
	StatusURL *string `json:"statusUrl,omitempty"`
}

// Constants associated with the PvmInstanceUpdateResponse.PinPolicy property.
// Specify PVM pin policy.
const (
	PvmInstanceUpdateResponsePinPolicyHardConst = "hard"
	PvmInstanceUpdateResponsePinPolicyNoneConst = "none"
	PvmInstanceUpdateResponsePinPolicySoftConst = "soft"
)

// Constants associated with the PvmInstanceUpdateResponse.ProcType property.
// Processor type (dedicated, shared, capped).
const (
	PvmInstanceUpdateResponseProcTypeCappedConst = "capped"
	PvmInstanceUpdateResponseProcTypeDedicatedConst = "dedicated"
	PvmInstanceUpdateResponseProcTypeSharedConst = "shared"
)

// UnmarshalPvmInstanceUpdateResponse unmarshals an instance of PvmInstanceUpdateResponse from the specified map of raw messages.
func UnmarshalPvmInstanceUpdateResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceUpdateResponse)
	err = core.UnmarshalPrimitive(m, "licenseRepositoryCapacity", &obj.LicenseRepositoryCapacity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pinPolicy", &obj.PinPolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "procType", &obj.ProcType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "processors", &obj.Processors)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serverName", &obj.ServerName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "statusUrl", &obj.StatusURL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceV2Health : PVM's health status details.
type PvmInstanceV2Health struct {
	// The PVM's health status value.
	Status *string `json:"status" validate:"required"`
}

// UnmarshalPvmInstanceV2Health unmarshals an instance of PvmInstanceV2Health from the specified map of raw messages.
func UnmarshalPvmInstanceV2Health(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceV2Health)
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceV2NetworkPort : PVM's Port information.
type PvmInstanceV2NetworkPort struct {
	// Unique Port ID.
	ID *string `json:"id,omitempty"`

	// Dynamic Host Configuration Protocol {IPv4, IPv6}.
	IPProtocol *string `json:"ipProtocol,omitempty"`

	// The mac address of the network interface.
	MacAddress *string `json:"macAddress,omitempty"`

	// The private ip address.
	PrivateIP *string `json:"privateIP,omitempty"`

	// The type of ip allocation {dhcp, static}.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the PvmInstanceV2NetworkPort.IPProtocol property.
// Dynamic Host Configuration Protocol {IPv4, IPv6}.
const (
	PvmInstanceV2NetworkPortIPProtocolIpv4Const = "IPv4"
	PvmInstanceV2NetworkPortIPProtocolIpv6Const = "IPv6"
)

// Constants associated with the PvmInstanceV2NetworkPort.Type property.
// The type of ip allocation {dhcp, static}.
const (
	PvmInstanceV2NetworkPortTypeDhcpConst = "dhcp"
	PvmInstanceV2NetworkPortTypeStaticConst = "static"
)

// UnmarshalPvmInstanceV2NetworkPort unmarshals an instance of PvmInstanceV2NetworkPort from the specified map of raw messages.
func UnmarshalPvmInstanceV2NetworkPort(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceV2NetworkPort)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ipProtocol", &obj.IPProtocol)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "macAddress", &obj.MacAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "privateIP", &obj.PrivateIP)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceVirtualCores : PvmInstanceVirtualCores struct
type PvmInstanceVirtualCores struct {
	// The active virtual Cores.
	Assigned *int64 `json:"assigned" validate:"required"`

	// The maximum DLPAR range for virtual Cores (Display only support).
	Maximum *int64 `json:"maximum,omitempty"`

	// The minimum DLPAR range for virtual Cores (Display only support).
	Minimum *int64 `json:"minimum,omitempty"`
}

// UnmarshalPvmInstanceVirtualCores unmarshals an instance of PvmInstanceVirtualCores from the specified map of raw messages.
func UnmarshalPvmInstanceVirtualCores(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceVirtualCores)
	err = core.UnmarshalPrimitive(m, "assigned", &obj.Assigned)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "maximum", &obj.Maximum)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "minimum", &obj.Minimum)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstances : PvmInstances struct
type PvmInstances struct {
	// PVM Instance References.
	PvmInstances []PvmInstanceReference `json:"pvmInstances" validate:"required"`
}

// UnmarshalPvmInstances unmarshals an instance of PvmInstances from the specified map of raw messages.
func UnmarshalPvmInstances(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstances)
	err = core.UnmarshalModel(m, "pvmInstances", &obj.PvmInstances, UnmarshalPvmInstanceReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstancesV2 : PvmInstancesV2 struct
type PvmInstancesV2 struct {
	// PVM Instance References.
	PvmInstances []PvmInstanceReferenceV2 `json:"pvmInstances" validate:"required"`
}

// UnmarshalPvmInstancesV2 unmarshals an instance of PvmInstancesV2 from the specified map of raw messages.
func UnmarshalPvmInstancesV2(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstancesV2)
	err = core.UnmarshalModel(m, "pvmInstances", &obj.PvmInstances, UnmarshalPvmInstanceReferenceV2)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PcloudCloudconnectionsDeleteOptions : The PcloudCloudconnectionsDelete options.
type PcloudCloudconnectionsDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Cloud Connection ID.
	CloudConnectionID *string `json:"cloud_connection_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudconnectionsDeleteOptions : Instantiate PcloudCloudconnectionsDeleteOptions
func (*PowervsV1) NewPcloudCloudconnectionsDeleteOptions(cloudInstanceID string, cloudConnectionID string) *PcloudCloudconnectionsDeleteOptions {
	return &PcloudCloudconnectionsDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		CloudConnectionID: core.StringPtr(cloudConnectionID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudconnectionsDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudconnectionsDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetCloudConnectionID : Allow user to set CloudConnectionID
func (_options *PcloudCloudconnectionsDeleteOptions) SetCloudConnectionID(cloudConnectionID string) *PcloudCloudconnectionsDeleteOptions {
	_options.CloudConnectionID = core.StringPtr(cloudConnectionID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudconnectionsDeleteOptions) SetHeaders(param map[string]string) *PcloudCloudconnectionsDeleteOptions {
	options.Headers = param
	return options
}

// PcloudCloudconnectionsGetOptions : The PcloudCloudconnectionsGet options.
type PcloudCloudconnectionsGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Cloud Connection ID.
	CloudConnectionID *string `json:"cloud_connection_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudconnectionsGetOptions : Instantiate PcloudCloudconnectionsGetOptions
func (*PowervsV1) NewPcloudCloudconnectionsGetOptions(cloudInstanceID string, cloudConnectionID string) *PcloudCloudconnectionsGetOptions {
	return &PcloudCloudconnectionsGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		CloudConnectionID: core.StringPtr(cloudConnectionID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudconnectionsGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudconnectionsGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetCloudConnectionID : Allow user to set CloudConnectionID
func (_options *PcloudCloudconnectionsGetOptions) SetCloudConnectionID(cloudConnectionID string) *PcloudCloudconnectionsGetOptions {
	_options.CloudConnectionID = core.StringPtr(cloudConnectionID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudconnectionsGetOptions) SetHeaders(param map[string]string) *PcloudCloudconnectionsGetOptions {
	options.Headers = param
	return options
}

// PcloudCloudconnectionsGetallOptions : The PcloudCloudconnectionsGetall options.
type PcloudCloudconnectionsGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudconnectionsGetallOptions : Instantiate PcloudCloudconnectionsGetallOptions
func (*PowervsV1) NewPcloudCloudconnectionsGetallOptions(cloudInstanceID string) *PcloudCloudconnectionsGetallOptions {
	return &PcloudCloudconnectionsGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudconnectionsGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudconnectionsGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudconnectionsGetallOptions) SetHeaders(param map[string]string) *PcloudCloudconnectionsGetallOptions {
	options.Headers = param
	return options
}

// PcloudCloudconnectionsNetworksDeleteOptions : The PcloudCloudconnectionsNetworksDelete options.
type PcloudCloudconnectionsNetworksDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Cloud Connection ID.
	CloudConnectionID *string `json:"cloud_connection_id" validate:"required,ne="`

	// Network ID.
	NetworkID *string `json:"network_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudconnectionsNetworksDeleteOptions : Instantiate PcloudCloudconnectionsNetworksDeleteOptions
func (*PowervsV1) NewPcloudCloudconnectionsNetworksDeleteOptions(cloudInstanceID string, cloudConnectionID string, networkID string) *PcloudCloudconnectionsNetworksDeleteOptions {
	return &PcloudCloudconnectionsNetworksDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		CloudConnectionID: core.StringPtr(cloudConnectionID),
		NetworkID: core.StringPtr(networkID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudconnectionsNetworksDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudconnectionsNetworksDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetCloudConnectionID : Allow user to set CloudConnectionID
func (_options *PcloudCloudconnectionsNetworksDeleteOptions) SetCloudConnectionID(cloudConnectionID string) *PcloudCloudconnectionsNetworksDeleteOptions {
	_options.CloudConnectionID = core.StringPtr(cloudConnectionID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *PcloudCloudconnectionsNetworksDeleteOptions) SetNetworkID(networkID string) *PcloudCloudconnectionsNetworksDeleteOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudconnectionsNetworksDeleteOptions) SetHeaders(param map[string]string) *PcloudCloudconnectionsNetworksDeleteOptions {
	options.Headers = param
	return options
}

// PcloudCloudconnectionsNetworksPutOptions : The PcloudCloudconnectionsNetworksPut options.
type PcloudCloudconnectionsNetworksPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Cloud Connection ID.
	CloudConnectionID *string `json:"cloud_connection_id" validate:"required,ne="`

	// Network ID.
	NetworkID *string `json:"network_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudconnectionsNetworksPutOptions : Instantiate PcloudCloudconnectionsNetworksPutOptions
func (*PowervsV1) NewPcloudCloudconnectionsNetworksPutOptions(cloudInstanceID string, cloudConnectionID string, networkID string) *PcloudCloudconnectionsNetworksPutOptions {
	return &PcloudCloudconnectionsNetworksPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		CloudConnectionID: core.StringPtr(cloudConnectionID),
		NetworkID: core.StringPtr(networkID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudconnectionsNetworksPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudconnectionsNetworksPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetCloudConnectionID : Allow user to set CloudConnectionID
func (_options *PcloudCloudconnectionsNetworksPutOptions) SetCloudConnectionID(cloudConnectionID string) *PcloudCloudconnectionsNetworksPutOptions {
	_options.CloudConnectionID = core.StringPtr(cloudConnectionID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *PcloudCloudconnectionsNetworksPutOptions) SetNetworkID(networkID string) *PcloudCloudconnectionsNetworksPutOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudconnectionsNetworksPutOptions) SetHeaders(param map[string]string) *PcloudCloudconnectionsNetworksPutOptions {
	options.Headers = param
	return options
}

// PcloudCloudconnectionsPostOptions : The PcloudCloudconnectionsPost options.
type PcloudCloudconnectionsPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// name of the cloud connection.
	Name *string `json:"name" validate:"required"`

	// speed of the cloud connection (speed in megabits per second).
	Speed *int64 `json:"speed" validate:"required"`

	Classic *CloudConnectionEndpointClassicUpdate `json:"classic,omitempty"`

	// enable global routing for this cloud connection (default=false).
	GlobalRouting *bool `json:"globalRouting,omitempty"`

	// enable metered for this cloud connection (default=false).
	Metered *bool `json:"metered,omitempty"`

	// list of subnets to attach to cloud connection.
	Subnets []string `json:"subnets,omitempty"`

	// enable transit gateway for this cloud connection (default=false).
	TransitEnabled *bool `json:"transitEnabled,omitempty"`

	VPC *CloudConnectionEndpointVPC `json:"vpc,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudconnectionsPostOptions : Instantiate PcloudCloudconnectionsPostOptions
func (*PowervsV1) NewPcloudCloudconnectionsPostOptions(cloudInstanceID string, name string, speed int64) *PcloudCloudconnectionsPostOptions {
	return &PcloudCloudconnectionsPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		Name: core.StringPtr(name),
		Speed: core.Int64Ptr(speed),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudconnectionsPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudconnectionsPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudCloudconnectionsPostOptions) SetName(name string) *PcloudCloudconnectionsPostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetSpeed : Allow user to set Speed
func (_options *PcloudCloudconnectionsPostOptions) SetSpeed(speed int64) *PcloudCloudconnectionsPostOptions {
	_options.Speed = core.Int64Ptr(speed)
	return _options
}

// SetClassic : Allow user to set Classic
func (_options *PcloudCloudconnectionsPostOptions) SetClassic(classic *CloudConnectionEndpointClassicUpdate) *PcloudCloudconnectionsPostOptions {
	_options.Classic = classic
	return _options
}

// SetGlobalRouting : Allow user to set GlobalRouting
func (_options *PcloudCloudconnectionsPostOptions) SetGlobalRouting(globalRouting bool) *PcloudCloudconnectionsPostOptions {
	_options.GlobalRouting = core.BoolPtr(globalRouting)
	return _options
}

// SetMetered : Allow user to set Metered
func (_options *PcloudCloudconnectionsPostOptions) SetMetered(metered bool) *PcloudCloudconnectionsPostOptions {
	_options.Metered = core.BoolPtr(metered)
	return _options
}

// SetSubnets : Allow user to set Subnets
func (_options *PcloudCloudconnectionsPostOptions) SetSubnets(subnets []string) *PcloudCloudconnectionsPostOptions {
	_options.Subnets = subnets
	return _options
}

// SetTransitEnabled : Allow user to set TransitEnabled
func (_options *PcloudCloudconnectionsPostOptions) SetTransitEnabled(transitEnabled bool) *PcloudCloudconnectionsPostOptions {
	_options.TransitEnabled = core.BoolPtr(transitEnabled)
	return _options
}

// SetVPC : Allow user to set VPC
func (_options *PcloudCloudconnectionsPostOptions) SetVPC(vpc *CloudConnectionEndpointVPC) *PcloudCloudconnectionsPostOptions {
	_options.VPC = vpc
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudconnectionsPostOptions) SetHeaders(param map[string]string) *PcloudCloudconnectionsPostOptions {
	options.Headers = param
	return options
}

// PcloudCloudconnectionsPutOptions : The PcloudCloudconnectionsPut options.
type PcloudCloudconnectionsPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Cloud Connection ID.
	CloudConnectionID *string `json:"cloud_connection_id" validate:"required,ne="`

	Classic *CloudConnectionEndpointClassicUpdate `json:"classic,omitempty"`

	// enable global routing for this cloud connection (default=false).
	GlobalRouting *bool `json:"globalRouting,omitempty"`

	// enable metered for this cloud connection (default=false).
	Metered *bool `json:"metered,omitempty"`

	// name of the cloud connection.
	Name *string `json:"name,omitempty"`

	// speed of the cloud connection (speed in megabits per second).
	Speed *int64 `json:"speed,omitempty"`

	VPC *CloudConnectionEndpointVPC `json:"vpc,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudconnectionsPutOptions : Instantiate PcloudCloudconnectionsPutOptions
func (*PowervsV1) NewPcloudCloudconnectionsPutOptions(cloudInstanceID string, cloudConnectionID string) *PcloudCloudconnectionsPutOptions {
	return &PcloudCloudconnectionsPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		CloudConnectionID: core.StringPtr(cloudConnectionID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudconnectionsPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudconnectionsPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetCloudConnectionID : Allow user to set CloudConnectionID
func (_options *PcloudCloudconnectionsPutOptions) SetCloudConnectionID(cloudConnectionID string) *PcloudCloudconnectionsPutOptions {
	_options.CloudConnectionID = core.StringPtr(cloudConnectionID)
	return _options
}

// SetClassic : Allow user to set Classic
func (_options *PcloudCloudconnectionsPutOptions) SetClassic(classic *CloudConnectionEndpointClassicUpdate) *PcloudCloudconnectionsPutOptions {
	_options.Classic = classic
	return _options
}

// SetGlobalRouting : Allow user to set GlobalRouting
func (_options *PcloudCloudconnectionsPutOptions) SetGlobalRouting(globalRouting bool) *PcloudCloudconnectionsPutOptions {
	_options.GlobalRouting = core.BoolPtr(globalRouting)
	return _options
}

// SetMetered : Allow user to set Metered
func (_options *PcloudCloudconnectionsPutOptions) SetMetered(metered bool) *PcloudCloudconnectionsPutOptions {
	_options.Metered = core.BoolPtr(metered)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudCloudconnectionsPutOptions) SetName(name string) *PcloudCloudconnectionsPutOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetSpeed : Allow user to set Speed
func (_options *PcloudCloudconnectionsPutOptions) SetSpeed(speed int64) *PcloudCloudconnectionsPutOptions {
	_options.Speed = core.Int64Ptr(speed)
	return _options
}

// SetVPC : Allow user to set VPC
func (_options *PcloudCloudconnectionsPutOptions) SetVPC(vpc *CloudConnectionEndpointVPC) *PcloudCloudconnectionsPutOptions {
	_options.VPC = vpc
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudconnectionsPutOptions) SetHeaders(param map[string]string) *PcloudCloudconnectionsPutOptions {
	options.Headers = param
	return options
}

// PcloudCloudconnectionsVirtualprivatecloudsGetallOptions : The PcloudCloudconnectionsVirtualprivatecloudsGetall options.
type PcloudCloudconnectionsVirtualprivatecloudsGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudconnectionsVirtualprivatecloudsGetallOptions : Instantiate PcloudCloudconnectionsVirtualprivatecloudsGetallOptions
func (*PowervsV1) NewPcloudCloudconnectionsVirtualprivatecloudsGetallOptions(cloudInstanceID string) *PcloudCloudconnectionsVirtualprivatecloudsGetallOptions {
	return &PcloudCloudconnectionsVirtualprivatecloudsGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudconnectionsVirtualprivatecloudsGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudconnectionsVirtualprivatecloudsGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudconnectionsVirtualprivatecloudsGetallOptions) SetHeaders(param map[string]string) *PcloudCloudconnectionsVirtualprivatecloudsGetallOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesDeleteOptions : The PcloudCloudinstancesDelete options.
type PcloudCloudinstancesDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesDeleteOptions : Instantiate PcloudCloudinstancesDeleteOptions
func (*PowervsV1) NewPcloudCloudinstancesDeleteOptions(cloudInstanceID string) *PcloudCloudinstancesDeleteOptions {
	return &PcloudCloudinstancesDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesDeleteOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesDeleteOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesGetOptions : The PcloudCloudinstancesGet options.
type PcloudCloudinstancesGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesGetOptions : Instantiate PcloudCloudinstancesGetOptions
func (*PowervsV1) NewPcloudCloudinstancesGetOptions(cloudInstanceID string) *PcloudCloudinstancesGetOptions {
	return &PcloudCloudinstancesGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesGetOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesGetOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesImagesDeleteOptions : The PcloudCloudinstancesImagesDelete options.
type PcloudCloudinstancesImagesDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Image ID of a image.
	ImageID *string `json:"image_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesImagesDeleteOptions : Instantiate PcloudCloudinstancesImagesDeleteOptions
func (*PowervsV1) NewPcloudCloudinstancesImagesDeleteOptions(cloudInstanceID string, imageID string) *PcloudCloudinstancesImagesDeleteOptions {
	return &PcloudCloudinstancesImagesDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		ImageID: core.StringPtr(imageID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesImagesDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesImagesDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetImageID : Allow user to set ImageID
func (_options *PcloudCloudinstancesImagesDeleteOptions) SetImageID(imageID string) *PcloudCloudinstancesImagesDeleteOptions {
	_options.ImageID = core.StringPtr(imageID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesImagesDeleteOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesImagesDeleteOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesImagesExportPostOptions : The PcloudCloudinstancesImagesExportPost options.
type PcloudCloudinstancesImagesExportPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Image ID of a image.
	ImageID *string `json:"image_id" validate:"required,ne="`

	// Cloud Object Storage Access key.
	AccessKey *string `json:"accessKey" validate:"required"`

	// Cloud Object Storage Bucket name.
	BucketName *string `json:"bucketName" validate:"required"`

	// Cloud Object Storage Region; required for IBM COS.
	Region *string `json:"region,omitempty"`

	// Cloud Object Storage Secret key.
	SecretKey *string `json:"secretKey,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesImagesExportPostOptions : Instantiate PcloudCloudinstancesImagesExportPostOptions
func (*PowervsV1) NewPcloudCloudinstancesImagesExportPostOptions(cloudInstanceID string, imageID string, accessKey string, bucketName string) *PcloudCloudinstancesImagesExportPostOptions {
	return &PcloudCloudinstancesImagesExportPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		ImageID: core.StringPtr(imageID),
		AccessKey: core.StringPtr(accessKey),
		BucketName: core.StringPtr(bucketName),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesImagesExportPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesImagesExportPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetImageID : Allow user to set ImageID
func (_options *PcloudCloudinstancesImagesExportPostOptions) SetImageID(imageID string) *PcloudCloudinstancesImagesExportPostOptions {
	_options.ImageID = core.StringPtr(imageID)
	return _options
}

// SetAccessKey : Allow user to set AccessKey
func (_options *PcloudCloudinstancesImagesExportPostOptions) SetAccessKey(accessKey string) *PcloudCloudinstancesImagesExportPostOptions {
	_options.AccessKey = core.StringPtr(accessKey)
	return _options
}

// SetBucketName : Allow user to set BucketName
func (_options *PcloudCloudinstancesImagesExportPostOptions) SetBucketName(bucketName string) *PcloudCloudinstancesImagesExportPostOptions {
	_options.BucketName = core.StringPtr(bucketName)
	return _options
}

// SetRegion : Allow user to set Region
func (_options *PcloudCloudinstancesImagesExportPostOptions) SetRegion(region string) *PcloudCloudinstancesImagesExportPostOptions {
	_options.Region = core.StringPtr(region)
	return _options
}

// SetSecretKey : Allow user to set SecretKey
func (_options *PcloudCloudinstancesImagesExportPostOptions) SetSecretKey(secretKey string) *PcloudCloudinstancesImagesExportPostOptions {
	_options.SecretKey = core.StringPtr(secretKey)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesImagesExportPostOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesImagesExportPostOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesImagesGetOptions : The PcloudCloudinstancesImagesGet options.
type PcloudCloudinstancesImagesGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Image ID of a image.
	ImageID *string `json:"image_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesImagesGetOptions : Instantiate PcloudCloudinstancesImagesGetOptions
func (*PowervsV1) NewPcloudCloudinstancesImagesGetOptions(cloudInstanceID string, imageID string) *PcloudCloudinstancesImagesGetOptions {
	return &PcloudCloudinstancesImagesGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		ImageID: core.StringPtr(imageID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesImagesGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesImagesGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetImageID : Allow user to set ImageID
func (_options *PcloudCloudinstancesImagesGetOptions) SetImageID(imageID string) *PcloudCloudinstancesImagesGetOptions {
	_options.ImageID = core.StringPtr(imageID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesImagesGetOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesImagesGetOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesImagesGetallOptions : The PcloudCloudinstancesImagesGetall options.
type PcloudCloudinstancesImagesGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesImagesGetallOptions : Instantiate PcloudCloudinstancesImagesGetallOptions
func (*PowervsV1) NewPcloudCloudinstancesImagesGetallOptions(cloudInstanceID string) *PcloudCloudinstancesImagesGetallOptions {
	return &PcloudCloudinstancesImagesGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesImagesGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesImagesGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesImagesGetallOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesImagesGetallOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesImagesPostOptions : The PcloudCloudinstancesImagesPost options.
type PcloudCloudinstancesImagesPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Source of the image
	// >*Note*: url option is deprecated, this option is supported till Oct 2022.
	Source *string `json:"source" validate:"required"`

	// Cloud Storage access key; required for import image.
	AccessKey *string `json:"accessKey,omitempty"`

	// Cloud Storage bucket name; bucket-name[/optional/folder]; required for import image.
	BucketName *string `json:"bucketName,omitempty"`

	// Type of Disk; if diskType is not provided the disk type will default to 'tier3'. Used only when importing an image
	// from cloud storage.
	DiskType *string `json:"diskType,omitempty"`

	// Cloud Storage image filename; required for import image.
	ImageFilename *string `json:"imageFilename,omitempty"`

	// Image ID of existing source image; required for copy image.
	ImageID *string `json:"imageID,omitempty"`

	// Name to give created image; required for import image.
	ImageName *string `json:"imageName,omitempty"`

	// (deprecated - replaced by region, imageFilename and bucketName) Path to image starting with service endpoint and
	// ending with image filename.
	ImagePath *string `json:"imagePath,omitempty"`

	// Image OS Type, required if importing a raw image; raw images can only be imported using the command line interface.
	OsType *string `json:"osType,omitempty"`

	// Cloud Storage Region; only required to access IBM Cloud Storage.
	Region *string `json:"region,omitempty"`

	// Cloud Storage secret key; required for import image.
	SecretKey *string `json:"secretKey,omitempty"`

	StorageAffinity *StorageAffinity `json:"storageAffinity,omitempty"`

	// Storage pool where the image will be loaded; if provided then storageAffinity will be ignored; Used only when
	// importing an image from cloud storage.
	StoragePool *string `json:"storagePool,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudCloudinstancesImagesPostOptions.Source property.
// Source of the image
// >*Note*: url option is deprecated, this option is supported till Oct 2022.
const (
	PcloudCloudinstancesImagesPostOptionsSourceRootProjectConst = "root-project"
	PcloudCloudinstancesImagesPostOptionsSourceURLConst = "url"
)

// Constants associated with the PcloudCloudinstancesImagesPostOptions.OsType property.
// Image OS Type, required if importing a raw image; raw images can only be imported using the command line interface.
const (
	PcloudCloudinstancesImagesPostOptionsOsTypeAixConst = "aix"
	PcloudCloudinstancesImagesPostOptionsOsTypeIbmiConst = "ibmi"
	PcloudCloudinstancesImagesPostOptionsOsTypeRhelConst = "rhel"
	PcloudCloudinstancesImagesPostOptionsOsTypeSlesConst = "sles"
)

// NewPcloudCloudinstancesImagesPostOptions : Instantiate PcloudCloudinstancesImagesPostOptions
func (*PowervsV1) NewPcloudCloudinstancesImagesPostOptions(cloudInstanceID string, source string) *PcloudCloudinstancesImagesPostOptions {
	return &PcloudCloudinstancesImagesPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		Source: core.StringPtr(source),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesImagesPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesImagesPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetSource : Allow user to set Source
func (_options *PcloudCloudinstancesImagesPostOptions) SetSource(source string) *PcloudCloudinstancesImagesPostOptions {
	_options.Source = core.StringPtr(source)
	return _options
}

// SetAccessKey : Allow user to set AccessKey
func (_options *PcloudCloudinstancesImagesPostOptions) SetAccessKey(accessKey string) *PcloudCloudinstancesImagesPostOptions {
	_options.AccessKey = core.StringPtr(accessKey)
	return _options
}

// SetBucketName : Allow user to set BucketName
func (_options *PcloudCloudinstancesImagesPostOptions) SetBucketName(bucketName string) *PcloudCloudinstancesImagesPostOptions {
	_options.BucketName = core.StringPtr(bucketName)
	return _options
}

// SetDiskType : Allow user to set DiskType
func (_options *PcloudCloudinstancesImagesPostOptions) SetDiskType(diskType string) *PcloudCloudinstancesImagesPostOptions {
	_options.DiskType = core.StringPtr(diskType)
	return _options
}

// SetImageFilename : Allow user to set ImageFilename
func (_options *PcloudCloudinstancesImagesPostOptions) SetImageFilename(imageFilename string) *PcloudCloudinstancesImagesPostOptions {
	_options.ImageFilename = core.StringPtr(imageFilename)
	return _options
}

// SetImageID : Allow user to set ImageID
func (_options *PcloudCloudinstancesImagesPostOptions) SetImageID(imageID string) *PcloudCloudinstancesImagesPostOptions {
	_options.ImageID = core.StringPtr(imageID)
	return _options
}

// SetImageName : Allow user to set ImageName
func (_options *PcloudCloudinstancesImagesPostOptions) SetImageName(imageName string) *PcloudCloudinstancesImagesPostOptions {
	_options.ImageName = core.StringPtr(imageName)
	return _options
}

// SetImagePath : Allow user to set ImagePath
func (_options *PcloudCloudinstancesImagesPostOptions) SetImagePath(imagePath string) *PcloudCloudinstancesImagesPostOptions {
	_options.ImagePath = core.StringPtr(imagePath)
	return _options
}

// SetOsType : Allow user to set OsType
func (_options *PcloudCloudinstancesImagesPostOptions) SetOsType(osType string) *PcloudCloudinstancesImagesPostOptions {
	_options.OsType = core.StringPtr(osType)
	return _options
}

// SetRegion : Allow user to set Region
func (_options *PcloudCloudinstancesImagesPostOptions) SetRegion(region string) *PcloudCloudinstancesImagesPostOptions {
	_options.Region = core.StringPtr(region)
	return _options
}

// SetSecretKey : Allow user to set SecretKey
func (_options *PcloudCloudinstancesImagesPostOptions) SetSecretKey(secretKey string) *PcloudCloudinstancesImagesPostOptions {
	_options.SecretKey = core.StringPtr(secretKey)
	return _options
}

// SetStorageAffinity : Allow user to set StorageAffinity
func (_options *PcloudCloudinstancesImagesPostOptions) SetStorageAffinity(storageAffinity *StorageAffinity) *PcloudCloudinstancesImagesPostOptions {
	_options.StorageAffinity = storageAffinity
	return _options
}

// SetStoragePool : Allow user to set StoragePool
func (_options *PcloudCloudinstancesImagesPostOptions) SetStoragePool(storagePool string) *PcloudCloudinstancesImagesPostOptions {
	_options.StoragePool = core.StringPtr(storagePool)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesImagesPostOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesImagesPostOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesJobsDeleteOptions : The PcloudCloudinstancesJobsDelete options.
type PcloudCloudinstancesJobsDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud Job ID.
	JobID *string `json:"job_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesJobsDeleteOptions : Instantiate PcloudCloudinstancesJobsDeleteOptions
func (*PowervsV1) NewPcloudCloudinstancesJobsDeleteOptions(cloudInstanceID string, jobID string) *PcloudCloudinstancesJobsDeleteOptions {
	return &PcloudCloudinstancesJobsDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		JobID: core.StringPtr(jobID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesJobsDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesJobsDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetJobID : Allow user to set JobID
func (_options *PcloudCloudinstancesJobsDeleteOptions) SetJobID(jobID string) *PcloudCloudinstancesJobsDeleteOptions {
	_options.JobID = core.StringPtr(jobID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesJobsDeleteOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesJobsDeleteOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesJobsGetOptions : The PcloudCloudinstancesJobsGet options.
type PcloudCloudinstancesJobsGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud Job ID.
	JobID *string `json:"job_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesJobsGetOptions : Instantiate PcloudCloudinstancesJobsGetOptions
func (*PowervsV1) NewPcloudCloudinstancesJobsGetOptions(cloudInstanceID string, jobID string) *PcloudCloudinstancesJobsGetOptions {
	return &PcloudCloudinstancesJobsGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		JobID: core.StringPtr(jobID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesJobsGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesJobsGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetJobID : Allow user to set JobID
func (_options *PcloudCloudinstancesJobsGetOptions) SetJobID(jobID string) *PcloudCloudinstancesJobsGetOptions {
	_options.JobID = core.StringPtr(jobID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesJobsGetOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesJobsGetOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesJobsGetallOptions : The PcloudCloudinstancesJobsGetall options.
type PcloudCloudinstancesJobsGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Operation ID to filter jobs (optional).
	OperationID *string `json:"operation.id,omitempty"`

	// Operation target to filter jobs (optional).
	OperationTarget *string `json:"operation.target,omitempty"`

	// Operation action to filter jobs (optional) vmCapture - includes operation action value (vmCapture) imageExport -
	// includes operation action value (imageExport) imageImport - includes operation action value (imageImport) storage -
	// includes operation action values (vmCapture,imageExport,imageImport).
	OperationAction *string `json:"operation.action,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudCloudinstancesJobsGetallOptions.OperationTarget property.
// Operation target to filter jobs (optional).
const (
	PcloudCloudinstancesJobsGetallOptionsOperationTargetCloudconnectionConst = "cloudConnection"
	PcloudCloudinstancesJobsGetallOptionsOperationTargetImageConst = "image"
	PcloudCloudinstancesJobsGetallOptionsOperationTargetPvminstanceConst = "pvmInstance"
	PcloudCloudinstancesJobsGetallOptionsOperationTargetVpnconnectionConst = "vpnConnection"
)

// Constants associated with the PcloudCloudinstancesJobsGetallOptions.OperationAction property.
// Operation action to filter jobs (optional) vmCapture - includes operation action value (vmCapture) imageExport -
// includes operation action value (imageExport) imageImport - includes operation action value (imageImport) storage -
// includes operation action values (vmCapture,imageExport,imageImport).
const (
	PcloudCloudinstancesJobsGetallOptionsOperationActionImageexportConst = "imageExport"
	PcloudCloudinstancesJobsGetallOptionsOperationActionImageimportConst = "imageImport"
	PcloudCloudinstancesJobsGetallOptionsOperationActionStorageConst = "storage"
	PcloudCloudinstancesJobsGetallOptionsOperationActionVmcaptureConst = "vmCapture"
)

// NewPcloudCloudinstancesJobsGetallOptions : Instantiate PcloudCloudinstancesJobsGetallOptions
func (*PowervsV1) NewPcloudCloudinstancesJobsGetallOptions(cloudInstanceID string) *PcloudCloudinstancesJobsGetallOptions {
	return &PcloudCloudinstancesJobsGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesJobsGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesJobsGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetOperationID : Allow user to set OperationID
func (_options *PcloudCloudinstancesJobsGetallOptions) SetOperationID(operationID string) *PcloudCloudinstancesJobsGetallOptions {
	_options.OperationID = core.StringPtr(operationID)
	return _options
}

// SetOperationTarget : Allow user to set OperationTarget
func (_options *PcloudCloudinstancesJobsGetallOptions) SetOperationTarget(operationTarget string) *PcloudCloudinstancesJobsGetallOptions {
	_options.OperationTarget = core.StringPtr(operationTarget)
	return _options
}

// SetOperationAction : Allow user to set OperationAction
func (_options *PcloudCloudinstancesJobsGetallOptions) SetOperationAction(operationAction string) *PcloudCloudinstancesJobsGetallOptions {
	_options.OperationAction = core.StringPtr(operationAction)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesJobsGetallOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesJobsGetallOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesPutOptions : The PcloudCloudinstancesPut options.
type PcloudCloudinstancesPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Number of power instances allowed.
	Instances *float64 `json:"instances,omitempty"`

	// Amount of memory allowed.
	Memory *float64 `json:"memory,omitempty"`

	// Number of processor units allowed.
	ProcUnits *float64 `json:"procUnits,omitempty"`

	// Number of processors allowed.
	Processors *float64 `json:"processors,omitempty"`

	// Amount of storage allowed (TB).
	Storage *float64 `json:"storage,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesPutOptions : Instantiate PcloudCloudinstancesPutOptions
func (*PowervsV1) NewPcloudCloudinstancesPutOptions(cloudInstanceID string) *PcloudCloudinstancesPutOptions {
	return &PcloudCloudinstancesPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetInstances : Allow user to set Instances
func (_options *PcloudCloudinstancesPutOptions) SetInstances(instances float64) *PcloudCloudinstancesPutOptions {
	_options.Instances = core.Float64Ptr(instances)
	return _options
}

// SetMemory : Allow user to set Memory
func (_options *PcloudCloudinstancesPutOptions) SetMemory(memory float64) *PcloudCloudinstancesPutOptions {
	_options.Memory = core.Float64Ptr(memory)
	return _options
}

// SetProcUnits : Allow user to set ProcUnits
func (_options *PcloudCloudinstancesPutOptions) SetProcUnits(procUnits float64) *PcloudCloudinstancesPutOptions {
	_options.ProcUnits = core.Float64Ptr(procUnits)
	return _options
}

// SetProcessors : Allow user to set Processors
func (_options *PcloudCloudinstancesPutOptions) SetProcessors(processors float64) *PcloudCloudinstancesPutOptions {
	_options.Processors = core.Float64Ptr(processors)
	return _options
}

// SetStorage : Allow user to set Storage
func (_options *PcloudCloudinstancesPutOptions) SetStorage(storage float64) *PcloudCloudinstancesPutOptions {
	_options.Storage = core.Float64Ptr(storage)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesPutOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesPutOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesSnapshotsDeleteOptions : The PcloudCloudinstancesSnapshotsDelete options.
type PcloudCloudinstancesSnapshotsDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PVM Instance snapshot id.
	SnapshotID *string `json:"snapshot_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesSnapshotsDeleteOptions : Instantiate PcloudCloudinstancesSnapshotsDeleteOptions
func (*PowervsV1) NewPcloudCloudinstancesSnapshotsDeleteOptions(cloudInstanceID string, snapshotID string) *PcloudCloudinstancesSnapshotsDeleteOptions {
	return &PcloudCloudinstancesSnapshotsDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		SnapshotID: core.StringPtr(snapshotID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesSnapshotsDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesSnapshotsDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetSnapshotID : Allow user to set SnapshotID
func (_options *PcloudCloudinstancesSnapshotsDeleteOptions) SetSnapshotID(snapshotID string) *PcloudCloudinstancesSnapshotsDeleteOptions {
	_options.SnapshotID = core.StringPtr(snapshotID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesSnapshotsDeleteOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesSnapshotsDeleteOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesSnapshotsGetOptions : The PcloudCloudinstancesSnapshotsGet options.
type PcloudCloudinstancesSnapshotsGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PVM Instance snapshot id.
	SnapshotID *string `json:"snapshot_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesSnapshotsGetOptions : Instantiate PcloudCloudinstancesSnapshotsGetOptions
func (*PowervsV1) NewPcloudCloudinstancesSnapshotsGetOptions(cloudInstanceID string, snapshotID string) *PcloudCloudinstancesSnapshotsGetOptions {
	return &PcloudCloudinstancesSnapshotsGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		SnapshotID: core.StringPtr(snapshotID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesSnapshotsGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesSnapshotsGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetSnapshotID : Allow user to set SnapshotID
func (_options *PcloudCloudinstancesSnapshotsGetOptions) SetSnapshotID(snapshotID string) *PcloudCloudinstancesSnapshotsGetOptions {
	_options.SnapshotID = core.StringPtr(snapshotID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesSnapshotsGetOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesSnapshotsGetOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesSnapshotsGetallOptions : The PcloudCloudinstancesSnapshotsGetall options.
type PcloudCloudinstancesSnapshotsGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesSnapshotsGetallOptions : Instantiate PcloudCloudinstancesSnapshotsGetallOptions
func (*PowervsV1) NewPcloudCloudinstancesSnapshotsGetallOptions(cloudInstanceID string) *PcloudCloudinstancesSnapshotsGetallOptions {
	return &PcloudCloudinstancesSnapshotsGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesSnapshotsGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesSnapshotsGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesSnapshotsGetallOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesSnapshotsGetallOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesSnapshotsPutOptions : The PcloudCloudinstancesSnapshotsPut options.
type PcloudCloudinstancesSnapshotsPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PVM Instance snapshot id.
	SnapshotID *string `json:"snapshot_id" validate:"required,ne="`

	// Description of the PVM instance snapshot.
	Description *string `json:"description,omitempty"`

	// Name of the PVM instance snapshot.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesSnapshotsPutOptions : Instantiate PcloudCloudinstancesSnapshotsPutOptions
func (*PowervsV1) NewPcloudCloudinstancesSnapshotsPutOptions(cloudInstanceID string, snapshotID string) *PcloudCloudinstancesSnapshotsPutOptions {
	return &PcloudCloudinstancesSnapshotsPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		SnapshotID: core.StringPtr(snapshotID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesSnapshotsPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesSnapshotsPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetSnapshotID : Allow user to set SnapshotID
func (_options *PcloudCloudinstancesSnapshotsPutOptions) SetSnapshotID(snapshotID string) *PcloudCloudinstancesSnapshotsPutOptions {
	_options.SnapshotID = core.StringPtr(snapshotID)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *PcloudCloudinstancesSnapshotsPutOptions) SetDescription(description string) *PcloudCloudinstancesSnapshotsPutOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudCloudinstancesSnapshotsPutOptions) SetName(name string) *PcloudCloudinstancesSnapshotsPutOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesSnapshotsPutOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesSnapshotsPutOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesStockimagesGetOptions : The PcloudCloudinstancesStockimagesGet options.
type PcloudCloudinstancesStockimagesGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Image ID of a image.
	ImageID *string `json:"image_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesStockimagesGetOptions : Instantiate PcloudCloudinstancesStockimagesGetOptions
func (*PowervsV1) NewPcloudCloudinstancesStockimagesGetOptions(cloudInstanceID string, imageID string) *PcloudCloudinstancesStockimagesGetOptions {
	return &PcloudCloudinstancesStockimagesGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		ImageID: core.StringPtr(imageID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesStockimagesGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesStockimagesGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetImageID : Allow user to set ImageID
func (_options *PcloudCloudinstancesStockimagesGetOptions) SetImageID(imageID string) *PcloudCloudinstancesStockimagesGetOptions {
	_options.ImageID = core.StringPtr(imageID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesStockimagesGetOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesStockimagesGetOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesStockimagesGetallOptions : The PcloudCloudinstancesStockimagesGetall options.
type PcloudCloudinstancesStockimagesGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Include SAP images with get available stock images.
	Sap *bool `json:"sap,omitempty"`

	// Include VTL images with get available stock images.
	Vtl *bool `json:"vtl,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesStockimagesGetallOptions : Instantiate PcloudCloudinstancesStockimagesGetallOptions
func (*PowervsV1) NewPcloudCloudinstancesStockimagesGetallOptions(cloudInstanceID string) *PcloudCloudinstancesStockimagesGetallOptions {
	return &PcloudCloudinstancesStockimagesGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesStockimagesGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesStockimagesGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetSap : Allow user to set Sap
func (_options *PcloudCloudinstancesStockimagesGetallOptions) SetSap(sap bool) *PcloudCloudinstancesStockimagesGetallOptions {
	_options.Sap = core.BoolPtr(sap)
	return _options
}

// SetVtl : Allow user to set Vtl
func (_options *PcloudCloudinstancesStockimagesGetallOptions) SetVtl(vtl bool) *PcloudCloudinstancesStockimagesGetallOptions {
	_options.Vtl = core.BoolPtr(vtl)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesStockimagesGetallOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesStockimagesGetallOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesStoragetiersGetallOptions : The PcloudCloudinstancesStoragetiersGetall options.
type PcloudCloudinstancesStoragetiersGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesStoragetiersGetallOptions : Instantiate PcloudCloudinstancesStoragetiersGetallOptions
func (*PowervsV1) NewPcloudCloudinstancesStoragetiersGetallOptions(cloudInstanceID string) *PcloudCloudinstancesStoragetiersGetallOptions {
	return &PcloudCloudinstancesStoragetiersGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesStoragetiersGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesStoragetiersGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesStoragetiersGetallOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesStoragetiersGetallOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesVolumesActionPostOptions : The PcloudCloudinstancesVolumesActionPost options.
type PcloudCloudinstancesVolumesActionPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Volume ID.
	VolumeID *string `json:"volume_id" validate:"required,ne="`

	// Indicates if the volume should be replication enabled or not.
	ReplicationEnabled *bool `json:"replicationEnabled,omitempty"`

	// Target storage tier; used to change a volume's storage tier.
	TargetStorageTier *string `json:"targetStorageTier,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesVolumesActionPostOptions : Instantiate PcloudCloudinstancesVolumesActionPostOptions
func (*PowervsV1) NewPcloudCloudinstancesVolumesActionPostOptions(cloudInstanceID string, volumeID string) *PcloudCloudinstancesVolumesActionPostOptions {
	return &PcloudCloudinstancesVolumesActionPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumeID: core.StringPtr(volumeID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesVolumesActionPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesVolumesActionPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumeID : Allow user to set VolumeID
func (_options *PcloudCloudinstancesVolumesActionPostOptions) SetVolumeID(volumeID string) *PcloudCloudinstancesVolumesActionPostOptions {
	_options.VolumeID = core.StringPtr(volumeID)
	return _options
}

// SetReplicationEnabled : Allow user to set ReplicationEnabled
func (_options *PcloudCloudinstancesVolumesActionPostOptions) SetReplicationEnabled(replicationEnabled bool) *PcloudCloudinstancesVolumesActionPostOptions {
	_options.ReplicationEnabled = core.BoolPtr(replicationEnabled)
	return _options
}

// SetTargetStorageTier : Allow user to set TargetStorageTier
func (_options *PcloudCloudinstancesVolumesActionPostOptions) SetTargetStorageTier(targetStorageTier string) *PcloudCloudinstancesVolumesActionPostOptions {
	_options.TargetStorageTier = core.StringPtr(targetStorageTier)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesVolumesActionPostOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesVolumesActionPostOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesVolumesDeleteOptions : The PcloudCloudinstancesVolumesDelete options.
type PcloudCloudinstancesVolumesDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Volume ID.
	VolumeID *string `json:"volume_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesVolumesDeleteOptions : Instantiate PcloudCloudinstancesVolumesDeleteOptions
func (*PowervsV1) NewPcloudCloudinstancesVolumesDeleteOptions(cloudInstanceID string, volumeID string) *PcloudCloudinstancesVolumesDeleteOptions {
	return &PcloudCloudinstancesVolumesDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumeID: core.StringPtr(volumeID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesVolumesDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesVolumesDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumeID : Allow user to set VolumeID
func (_options *PcloudCloudinstancesVolumesDeleteOptions) SetVolumeID(volumeID string) *PcloudCloudinstancesVolumesDeleteOptions {
	_options.VolumeID = core.StringPtr(volumeID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesVolumesDeleteOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesVolumesDeleteOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesVolumesFlashCopyMappingsGetOptions : The PcloudCloudinstancesVolumesFlashCopyMappingsGet options.
type PcloudCloudinstancesVolumesFlashCopyMappingsGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Volume ID.
	VolumeID *string `json:"volume_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesVolumesFlashCopyMappingsGetOptions : Instantiate PcloudCloudinstancesVolumesFlashCopyMappingsGetOptions
func (*PowervsV1) NewPcloudCloudinstancesVolumesFlashCopyMappingsGetOptions(cloudInstanceID string, volumeID string) *PcloudCloudinstancesVolumesFlashCopyMappingsGetOptions {
	return &PcloudCloudinstancesVolumesFlashCopyMappingsGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumeID: core.StringPtr(volumeID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesVolumesFlashCopyMappingsGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesVolumesFlashCopyMappingsGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumeID : Allow user to set VolumeID
func (_options *PcloudCloudinstancesVolumesFlashCopyMappingsGetOptions) SetVolumeID(volumeID string) *PcloudCloudinstancesVolumesFlashCopyMappingsGetOptions {
	_options.VolumeID = core.StringPtr(volumeID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesVolumesFlashCopyMappingsGetOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesVolumesFlashCopyMappingsGetOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesVolumesGetOptions : The PcloudCloudinstancesVolumesGet options.
type PcloudCloudinstancesVolumesGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Volume ID.
	VolumeID *string `json:"volume_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesVolumesGetOptions : Instantiate PcloudCloudinstancesVolumesGetOptions
func (*PowervsV1) NewPcloudCloudinstancesVolumesGetOptions(cloudInstanceID string, volumeID string) *PcloudCloudinstancesVolumesGetOptions {
	return &PcloudCloudinstancesVolumesGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumeID: core.StringPtr(volumeID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesVolumesGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesVolumesGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumeID : Allow user to set VolumeID
func (_options *PcloudCloudinstancesVolumesGetOptions) SetVolumeID(volumeID string) *PcloudCloudinstancesVolumesGetOptions {
	_options.VolumeID = core.StringPtr(volumeID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesVolumesGetOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesVolumesGetOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesVolumesGetallOptions : The PcloudCloudinstancesVolumesGetall options.
type PcloudCloudinstancesVolumesGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// true or false, limits a volumes list to replication or non replication enabled volumes.
	ReplicationEnabled *bool `json:"replicationEnabled,omitempty"`

	// A pvmInstance (id or name), limits a volumes list response to only volumes that have affinity to the pvmInstance.
	Affinity *string `json:"affinity,omitempty"`

	// true or false, limits a volume list to auxiliary or non auxiliary volumes.
	Auxiliary *bool `json:"auxiliary,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesVolumesGetallOptions : Instantiate PcloudCloudinstancesVolumesGetallOptions
func (*PowervsV1) NewPcloudCloudinstancesVolumesGetallOptions(cloudInstanceID string) *PcloudCloudinstancesVolumesGetallOptions {
	return &PcloudCloudinstancesVolumesGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesVolumesGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesVolumesGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetReplicationEnabled : Allow user to set ReplicationEnabled
func (_options *PcloudCloudinstancesVolumesGetallOptions) SetReplicationEnabled(replicationEnabled bool) *PcloudCloudinstancesVolumesGetallOptions {
	_options.ReplicationEnabled = core.BoolPtr(replicationEnabled)
	return _options
}

// SetAffinity : Allow user to set Affinity
func (_options *PcloudCloudinstancesVolumesGetallOptions) SetAffinity(affinity string) *PcloudCloudinstancesVolumesGetallOptions {
	_options.Affinity = core.StringPtr(affinity)
	return _options
}

// SetAuxiliary : Allow user to set Auxiliary
func (_options *PcloudCloudinstancesVolumesGetallOptions) SetAuxiliary(auxiliary bool) *PcloudCloudinstancesVolumesGetallOptions {
	_options.Auxiliary = core.BoolPtr(auxiliary)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesVolumesGetallOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesVolumesGetallOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesVolumesPostOptions : The PcloudCloudinstancesVolumesPost options.
type PcloudCloudinstancesVolumesPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Volume Name.
	Name *string `json:"name" validate:"required"`

	// Volume Size (GB).
	Size *float64 `json:"size" validate:"required"`

	// PVM Instance (ID or Name) to base volume affinity policy against; required if requesting affinity and affinityVolume
	// is not provided.
	AffinityPvmInstance *string `json:"affinityPVMInstance,omitempty"`

	// Affinity policy for data volume being created; ignored if volumePool provided; for policy 'affinity' requires one of
	// affinityPVMInstance or affinityVolume to be specified; for policy 'anti-affinity' requires one of
	// antiAffinityPVMInstances or antiAffinityVolumes to be specified.
	AffinityPolicy *string `json:"affinityPolicy,omitempty"`

	// Volume (ID or Name) to base volume affinity policy against; required if requesting affinity and affinityPVMInstance
	// is not provided.
	AffinityVolume *string `json:"affinityVolume,omitempty"`

	// List of pvmInstances to base volume anti-affinity policy against; required if requesting anti-affinity and
	// antiAffinityVolumes is not provided.
	AntiAffinityPvmInstances []string `json:"antiAffinityPVMInstances,omitempty"`

	// List of volumes to base volume anti-affinity policy against; required if requesting anti-affinity and
	// antiAffinityPVMInstances is not provided.
	AntiAffinityVolumes []string `json:"antiAffinityVolumes,omitempty"`

	// Type of Disk; if diskType is not provided the disk type will default to 'tier3'.
	DiskType *string `json:"diskType,omitempty"`

	// Indicates if the volume should be replication enabled or not.
	ReplicationEnabled *bool `json:"replicationEnabled,omitempty"`

	// Indicates if the volume is shareable between VMs.
	Shareable *bool `json:"shareable,omitempty"`

	// Volume pool where the volume will be created; if provided then affinityPolicy value will be ignored.
	VolumePool *string `json:"volumePool,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudCloudinstancesVolumesPostOptions.AffinityPolicy property.
// Affinity policy for data volume being created; ignored if volumePool provided; for policy 'affinity' requires one of
// affinityPVMInstance or affinityVolume to be specified; for policy 'anti-affinity' requires one of
// antiAffinityPVMInstances or antiAffinityVolumes to be specified.
const (
	PcloudCloudinstancesVolumesPostOptionsAffinityPolicyAffinityConst = "affinity"
	PcloudCloudinstancesVolumesPostOptionsAffinityPolicyAntiAffinityConst = "anti-affinity"
)

// NewPcloudCloudinstancesVolumesPostOptions : Instantiate PcloudCloudinstancesVolumesPostOptions
func (*PowervsV1) NewPcloudCloudinstancesVolumesPostOptions(cloudInstanceID string, name string, size float64) *PcloudCloudinstancesVolumesPostOptions {
	return &PcloudCloudinstancesVolumesPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		Name: core.StringPtr(name),
		Size: core.Float64Ptr(size),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesVolumesPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesVolumesPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudCloudinstancesVolumesPostOptions) SetName(name string) *PcloudCloudinstancesVolumesPostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetSize : Allow user to set Size
func (_options *PcloudCloudinstancesVolumesPostOptions) SetSize(size float64) *PcloudCloudinstancesVolumesPostOptions {
	_options.Size = core.Float64Ptr(size)
	return _options
}

// SetAffinityPvmInstance : Allow user to set AffinityPvmInstance
func (_options *PcloudCloudinstancesVolumesPostOptions) SetAffinityPvmInstance(affinityPvmInstance string) *PcloudCloudinstancesVolumesPostOptions {
	_options.AffinityPvmInstance = core.StringPtr(affinityPvmInstance)
	return _options
}

// SetAffinityPolicy : Allow user to set AffinityPolicy
func (_options *PcloudCloudinstancesVolumesPostOptions) SetAffinityPolicy(affinityPolicy string) *PcloudCloudinstancesVolumesPostOptions {
	_options.AffinityPolicy = core.StringPtr(affinityPolicy)
	return _options
}

// SetAffinityVolume : Allow user to set AffinityVolume
func (_options *PcloudCloudinstancesVolumesPostOptions) SetAffinityVolume(affinityVolume string) *PcloudCloudinstancesVolumesPostOptions {
	_options.AffinityVolume = core.StringPtr(affinityVolume)
	return _options
}

// SetAntiAffinityPvmInstances : Allow user to set AntiAffinityPvmInstances
func (_options *PcloudCloudinstancesVolumesPostOptions) SetAntiAffinityPvmInstances(antiAffinityPvmInstances []string) *PcloudCloudinstancesVolumesPostOptions {
	_options.AntiAffinityPvmInstances = antiAffinityPvmInstances
	return _options
}

// SetAntiAffinityVolumes : Allow user to set AntiAffinityVolumes
func (_options *PcloudCloudinstancesVolumesPostOptions) SetAntiAffinityVolumes(antiAffinityVolumes []string) *PcloudCloudinstancesVolumesPostOptions {
	_options.AntiAffinityVolumes = antiAffinityVolumes
	return _options
}

// SetDiskType : Allow user to set DiskType
func (_options *PcloudCloudinstancesVolumesPostOptions) SetDiskType(diskType string) *PcloudCloudinstancesVolumesPostOptions {
	_options.DiskType = core.StringPtr(diskType)
	return _options
}

// SetReplicationEnabled : Allow user to set ReplicationEnabled
func (_options *PcloudCloudinstancesVolumesPostOptions) SetReplicationEnabled(replicationEnabled bool) *PcloudCloudinstancesVolumesPostOptions {
	_options.ReplicationEnabled = core.BoolPtr(replicationEnabled)
	return _options
}

// SetShareable : Allow user to set Shareable
func (_options *PcloudCloudinstancesVolumesPostOptions) SetShareable(shareable bool) *PcloudCloudinstancesVolumesPostOptions {
	_options.Shareable = core.BoolPtr(shareable)
	return _options
}

// SetVolumePool : Allow user to set VolumePool
func (_options *PcloudCloudinstancesVolumesPostOptions) SetVolumePool(volumePool string) *PcloudCloudinstancesVolumesPostOptions {
	_options.VolumePool = core.StringPtr(volumePool)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesVolumesPostOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesVolumesPostOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesVolumesPutOptions : The PcloudCloudinstancesVolumesPut options.
type PcloudCloudinstancesVolumesPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Volume ID.
	VolumeID *string `json:"volume_id" validate:"required,ne="`

	// Indicates if the volume is boot capable.
	Bootable *bool `json:"bootable,omitempty"`

	// Name.
	Name *string `json:"name,omitempty"`

	// Indicates if the volume is shareable between VMs.
	Shareable *bool `json:"shareable,omitempty"`

	// New Volume size.
	Size *float64 `json:"size,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesVolumesPutOptions : Instantiate PcloudCloudinstancesVolumesPutOptions
func (*PowervsV1) NewPcloudCloudinstancesVolumesPutOptions(cloudInstanceID string, volumeID string) *PcloudCloudinstancesVolumesPutOptions {
	return &PcloudCloudinstancesVolumesPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumeID: core.StringPtr(volumeID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesVolumesPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesVolumesPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumeID : Allow user to set VolumeID
func (_options *PcloudCloudinstancesVolumesPutOptions) SetVolumeID(volumeID string) *PcloudCloudinstancesVolumesPutOptions {
	_options.VolumeID = core.StringPtr(volumeID)
	return _options
}

// SetBootable : Allow user to set Bootable
func (_options *PcloudCloudinstancesVolumesPutOptions) SetBootable(bootable bool) *PcloudCloudinstancesVolumesPutOptions {
	_options.Bootable = core.BoolPtr(bootable)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudCloudinstancesVolumesPutOptions) SetName(name string) *PcloudCloudinstancesVolumesPutOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetShareable : Allow user to set Shareable
func (_options *PcloudCloudinstancesVolumesPutOptions) SetShareable(shareable bool) *PcloudCloudinstancesVolumesPutOptions {
	_options.Shareable = core.BoolPtr(shareable)
	return _options
}

// SetSize : Allow user to set Size
func (_options *PcloudCloudinstancesVolumesPutOptions) SetSize(size float64) *PcloudCloudinstancesVolumesPutOptions {
	_options.Size = core.Float64Ptr(size)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesVolumesPutOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesVolumesPutOptions {
	options.Headers = param
	return options
}

// PcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions : The PcloudCloudinstancesVolumesRemoteCopyRelationshipGet options.
type PcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Volume ID.
	VolumeID *string `json:"volume_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions : Instantiate PcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions
func (*PowervsV1) NewPcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions(cloudInstanceID string, volumeID string) *PcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions {
	return &PcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumeID: core.StringPtr(volumeID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumeID : Allow user to set VolumeID
func (_options *PcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions) SetVolumeID(volumeID string) *PcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions {
	_options.VolumeID = core.StringPtr(volumeID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions) SetHeaders(param map[string]string) *PcloudCloudinstancesVolumesRemoteCopyRelationshipGetOptions {
	options.Headers = param
	return options
}

// PcloudDhcpDeleteOptions : The PcloudDhcpDelete options.
type PcloudDhcpDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// The ID of the DHCP Server.
	DhcpID *string `json:"dhcp_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudDhcpDeleteOptions : Instantiate PcloudDhcpDeleteOptions
func (*PowervsV1) NewPcloudDhcpDeleteOptions(cloudInstanceID string, dhcpID string) *PcloudDhcpDeleteOptions {
	return &PcloudDhcpDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		DhcpID: core.StringPtr(dhcpID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudDhcpDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudDhcpDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetDhcpID : Allow user to set DhcpID
func (_options *PcloudDhcpDeleteOptions) SetDhcpID(dhcpID string) *PcloudDhcpDeleteOptions {
	_options.DhcpID = core.StringPtr(dhcpID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudDhcpDeleteOptions) SetHeaders(param map[string]string) *PcloudDhcpDeleteOptions {
	options.Headers = param
	return options
}

// PcloudDhcpGetOptions : The PcloudDhcpGet options.
type PcloudDhcpGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// The ID of the DHCP Server.
	DhcpID *string `json:"dhcp_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudDhcpGetOptions : Instantiate PcloudDhcpGetOptions
func (*PowervsV1) NewPcloudDhcpGetOptions(cloudInstanceID string, dhcpID string) *PcloudDhcpGetOptions {
	return &PcloudDhcpGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		DhcpID: core.StringPtr(dhcpID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudDhcpGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudDhcpGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetDhcpID : Allow user to set DhcpID
func (_options *PcloudDhcpGetOptions) SetDhcpID(dhcpID string) *PcloudDhcpGetOptions {
	_options.DhcpID = core.StringPtr(dhcpID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudDhcpGetOptions) SetHeaders(param map[string]string) *PcloudDhcpGetOptions {
	options.Headers = param
	return options
}

// PcloudDhcpGetallOptions : The PcloudDhcpGetall options.
type PcloudDhcpGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudDhcpGetallOptions : Instantiate PcloudDhcpGetallOptions
func (*PowervsV1) NewPcloudDhcpGetallOptions(cloudInstanceID string) *PcloudDhcpGetallOptions {
	return &PcloudDhcpGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudDhcpGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudDhcpGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudDhcpGetallOptions) SetHeaders(param map[string]string) *PcloudDhcpGetallOptions {
	options.Headers = param
	return options
}

// PcloudDhcpPostOptions : The PcloudDhcpPost options.
type PcloudDhcpPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Optional cidr for DHCP private network.
	CIDR *string `json:"cidr,omitempty"`

	// Optional cloud connection uuid to connect with DHCP private network.
	CloudConnectionID *string `json:"cloudConnectionID,omitempty"`

	// Optional DNS Server for DHCP service.
	DnsServer *string `json:"dnsServer,omitempty"`

	// Optional name of DHCP Service. Only alphanumeric characters and dashes are allowed (will be prefixed by DHCP
	// identifier).
	Name *string `json:"name,omitempty"`

	// Indicates if SNAT will be enabled for DHCP service.
	SnatEnabled *bool `json:"snatEnabled,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudDhcpPostOptions : Instantiate PcloudDhcpPostOptions
func (*PowervsV1) NewPcloudDhcpPostOptions(cloudInstanceID string) *PcloudDhcpPostOptions {
	return &PcloudDhcpPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudDhcpPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudDhcpPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetCIDR : Allow user to set CIDR
func (_options *PcloudDhcpPostOptions) SetCIDR(cidr string) *PcloudDhcpPostOptions {
	_options.CIDR = core.StringPtr(cidr)
	return _options
}

// SetCloudConnectionID : Allow user to set CloudConnectionID
func (_options *PcloudDhcpPostOptions) SetCloudConnectionID(cloudConnectionID string) *PcloudDhcpPostOptions {
	_options.CloudConnectionID = core.StringPtr(cloudConnectionID)
	return _options
}

// SetDnsServer : Allow user to set DnsServer
func (_options *PcloudDhcpPostOptions) SetDnsServer(dnsServer string) *PcloudDhcpPostOptions {
	_options.DnsServer = core.StringPtr(dnsServer)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudDhcpPostOptions) SetName(name string) *PcloudDhcpPostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetSnatEnabled : Allow user to set SnatEnabled
func (_options *PcloudDhcpPostOptions) SetSnatEnabled(snatEnabled bool) *PcloudDhcpPostOptions {
	_options.SnatEnabled = core.BoolPtr(snatEnabled)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudDhcpPostOptions) SetHeaders(param map[string]string) *PcloudDhcpPostOptions {
	options.Headers = param
	return options
}

// PcloudEventsGetOptions : The PcloudEventsGet options.
type PcloudEventsGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Event ID.
	EventID *string `json:"event_id" validate:"required,ne="`

	// The language requested for the return document.
	AcceptLanguage *string `json:"Accept-Language,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudEventsGetOptions : Instantiate PcloudEventsGetOptions
func (*PowervsV1) NewPcloudEventsGetOptions(cloudInstanceID string, eventID string) *PcloudEventsGetOptions {
	return &PcloudEventsGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		EventID: core.StringPtr(eventID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudEventsGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudEventsGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetEventID : Allow user to set EventID
func (_options *PcloudEventsGetOptions) SetEventID(eventID string) *PcloudEventsGetOptions {
	_options.EventID = core.StringPtr(eventID)
	return _options
}

// SetAcceptLanguage : Allow user to set AcceptLanguage
func (_options *PcloudEventsGetOptions) SetAcceptLanguage(acceptLanguage string) *PcloudEventsGetOptions {
	_options.AcceptLanguage = core.StringPtr(acceptLanguage)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudEventsGetOptions) SetHeaders(param map[string]string) *PcloudEventsGetOptions {
	options.Headers = param
	return options
}

// PcloudEventsGetqueryOptions : The PcloudEventsGetquery options.
type PcloudEventsGetqueryOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// (deprecated - use from_time) A time in either ISO 8601 or unix epoch format.
	Time *string `json:"time,omitempty"`

	// A from query time in either ISO 8601 or unix epoch format.
	FromTime *string `json:"from_time,omitempty"`

	// A to query time in either ISO 8601 or unix epoch format.
	ToTime *string `json:"to_time,omitempty"`

	// The language requested for the return document.
	AcceptLanguage *string `json:"Accept-Language,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudEventsGetqueryOptions : Instantiate PcloudEventsGetqueryOptions
func (*PowervsV1) NewPcloudEventsGetqueryOptions(cloudInstanceID string) *PcloudEventsGetqueryOptions {
	return &PcloudEventsGetqueryOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudEventsGetqueryOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudEventsGetqueryOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetTime : Allow user to set Time
func (_options *PcloudEventsGetqueryOptions) SetTime(time string) *PcloudEventsGetqueryOptions {
	_options.Time = core.StringPtr(time)
	return _options
}

// SetFromTime : Allow user to set FromTime
func (_options *PcloudEventsGetqueryOptions) SetFromTime(fromTime string) *PcloudEventsGetqueryOptions {
	_options.FromTime = core.StringPtr(fromTime)
	return _options
}

// SetToTime : Allow user to set ToTime
func (_options *PcloudEventsGetqueryOptions) SetToTime(toTime string) *PcloudEventsGetqueryOptions {
	_options.ToTime = core.StringPtr(toTime)
	return _options
}

// SetAcceptLanguage : Allow user to set AcceptLanguage
func (_options *PcloudEventsGetqueryOptions) SetAcceptLanguage(acceptLanguage string) *PcloudEventsGetqueryOptions {
	_options.AcceptLanguage = core.StringPtr(acceptLanguage)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudEventsGetqueryOptions) SetHeaders(param map[string]string) *PcloudEventsGetqueryOptions {
	options.Headers = param
	return options
}

// PcloudIkepoliciesDeleteOptions : The PcloudIkepoliciesDelete options.
type PcloudIkepoliciesDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// ID of a IKE Policy.
	IkePolicyID *string `json:"ike_policy_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudIkepoliciesDeleteOptions : Instantiate PcloudIkepoliciesDeleteOptions
func (*PowervsV1) NewPcloudIkepoliciesDeleteOptions(cloudInstanceID string, ikePolicyID string) *PcloudIkepoliciesDeleteOptions {
	return &PcloudIkepoliciesDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		IkePolicyID: core.StringPtr(ikePolicyID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudIkepoliciesDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudIkepoliciesDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetIkePolicyID : Allow user to set IkePolicyID
func (_options *PcloudIkepoliciesDeleteOptions) SetIkePolicyID(ikePolicyID string) *PcloudIkepoliciesDeleteOptions {
	_options.IkePolicyID = core.StringPtr(ikePolicyID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudIkepoliciesDeleteOptions) SetHeaders(param map[string]string) *PcloudIkepoliciesDeleteOptions {
	options.Headers = param
	return options
}

// PcloudIkepoliciesGetOptions : The PcloudIkepoliciesGet options.
type PcloudIkepoliciesGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// ID of a IKE Policy.
	IkePolicyID *string `json:"ike_policy_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudIkepoliciesGetOptions : Instantiate PcloudIkepoliciesGetOptions
func (*PowervsV1) NewPcloudIkepoliciesGetOptions(cloudInstanceID string, ikePolicyID string) *PcloudIkepoliciesGetOptions {
	return &PcloudIkepoliciesGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		IkePolicyID: core.StringPtr(ikePolicyID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudIkepoliciesGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudIkepoliciesGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetIkePolicyID : Allow user to set IkePolicyID
func (_options *PcloudIkepoliciesGetOptions) SetIkePolicyID(ikePolicyID string) *PcloudIkepoliciesGetOptions {
	_options.IkePolicyID = core.StringPtr(ikePolicyID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudIkepoliciesGetOptions) SetHeaders(param map[string]string) *PcloudIkepoliciesGetOptions {
	options.Headers = param
	return options
}

// PcloudIkepoliciesGetallOptions : The PcloudIkepoliciesGetall options.
type PcloudIkepoliciesGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudIkepoliciesGetallOptions : Instantiate PcloudIkepoliciesGetallOptions
func (*PowervsV1) NewPcloudIkepoliciesGetallOptions(cloudInstanceID string) *PcloudIkepoliciesGetallOptions {
	return &PcloudIkepoliciesGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudIkepoliciesGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudIkepoliciesGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudIkepoliciesGetallOptions) SetHeaders(param map[string]string) *PcloudIkepoliciesGetallOptions {
	options.Headers = param
	return options
}

// PcloudIkepoliciesPostOptions : The PcloudIkepoliciesPost options.
type PcloudIkepoliciesPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// DH group of the IKE Policy.
	DhGroup *int64 `json:"dhGroup" validate:"required"`

	// encryption of the IKE Policy.
	Encryption *string `json:"encryption" validate:"required"`

	// Policy key lifetime.
	KeyLifetime *int64 `json:"keyLifetime" validate:"required"`

	// name of the IKE Policy.
	Name *string `json:"name" validate:"required"`

	// Preshared key used in this IKE Policy (length of preshared key must be even).
	PresharedKey *string `json:"presharedKey" validate:"required"`

	// version of the IKE Policy.
	Version *int64 `json:"version" validate:"required"`

	// authentication of the IKE policy.
	Authentication *string `json:"authentication,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudIkepoliciesPostOptions.Encryption property.
// encryption of the IKE Policy.
const (
	PcloudIkepoliciesPostOptionsEncryptionAes128CbcConst = "aes-128-cbc"
	PcloudIkepoliciesPostOptionsEncryptionAes128GcmConst = "aes-128-gcm"
	PcloudIkepoliciesPostOptionsEncryptionAes192CbcConst = "aes-192-cbc"
	PcloudIkepoliciesPostOptionsEncryptionAes256CbcConst = "aes-256-cbc"
	PcloudIkepoliciesPostOptionsEncryptionAes256GcmConst = "aes-256-gcm"
)

// Constants associated with the PcloudIkepoliciesPostOptions.Authentication property.
// authentication of the IKE policy.
const (
	PcloudIkepoliciesPostOptionsAuthenticationNoneConst = "none"
	PcloudIkepoliciesPostOptionsAuthenticationSha1Const = "sha1"
	PcloudIkepoliciesPostOptionsAuthenticationSha256Const = "sha-256"
	PcloudIkepoliciesPostOptionsAuthenticationSha384Const = "sha-384"
)

// NewPcloudIkepoliciesPostOptions : Instantiate PcloudIkepoliciesPostOptions
func (*PowervsV1) NewPcloudIkepoliciesPostOptions(cloudInstanceID string, dhGroup int64, encryption string, keyLifetime int64, name string, presharedKey string, version int64) *PcloudIkepoliciesPostOptions {
	return &PcloudIkepoliciesPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		DhGroup: core.Int64Ptr(dhGroup),
		Encryption: core.StringPtr(encryption),
		KeyLifetime: core.Int64Ptr(keyLifetime),
		Name: core.StringPtr(name),
		PresharedKey: core.StringPtr(presharedKey),
		Version: core.Int64Ptr(version),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudIkepoliciesPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudIkepoliciesPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetDhGroup : Allow user to set DhGroup
func (_options *PcloudIkepoliciesPostOptions) SetDhGroup(dhGroup int64) *PcloudIkepoliciesPostOptions {
	_options.DhGroup = core.Int64Ptr(dhGroup)
	return _options
}

// SetEncryption : Allow user to set Encryption
func (_options *PcloudIkepoliciesPostOptions) SetEncryption(encryption string) *PcloudIkepoliciesPostOptions {
	_options.Encryption = core.StringPtr(encryption)
	return _options
}

// SetKeyLifetime : Allow user to set KeyLifetime
func (_options *PcloudIkepoliciesPostOptions) SetKeyLifetime(keyLifetime int64) *PcloudIkepoliciesPostOptions {
	_options.KeyLifetime = core.Int64Ptr(keyLifetime)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudIkepoliciesPostOptions) SetName(name string) *PcloudIkepoliciesPostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetPresharedKey : Allow user to set PresharedKey
func (_options *PcloudIkepoliciesPostOptions) SetPresharedKey(presharedKey string) *PcloudIkepoliciesPostOptions {
	_options.PresharedKey = core.StringPtr(presharedKey)
	return _options
}

// SetVersion : Allow user to set Version
func (_options *PcloudIkepoliciesPostOptions) SetVersion(version int64) *PcloudIkepoliciesPostOptions {
	_options.Version = core.Int64Ptr(version)
	return _options
}

// SetAuthentication : Allow user to set Authentication
func (_options *PcloudIkepoliciesPostOptions) SetAuthentication(authentication string) *PcloudIkepoliciesPostOptions {
	_options.Authentication = core.StringPtr(authentication)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudIkepoliciesPostOptions) SetHeaders(param map[string]string) *PcloudIkepoliciesPostOptions {
	options.Headers = param
	return options
}

// PcloudIkepoliciesPutOptions : The PcloudIkepoliciesPut options.
type PcloudIkepoliciesPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// ID of a IKE Policy.
	IkePolicyID *string `json:"ike_policy_id" validate:"required,ne="`

	// Parameters for updating IKE Policy.
	Body *IkePolicyUpdate `json:"body" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudIkepoliciesPutOptions : Instantiate PcloudIkepoliciesPutOptions
func (*PowervsV1) NewPcloudIkepoliciesPutOptions(cloudInstanceID string, ikePolicyID string, body *IkePolicyUpdate) *PcloudIkepoliciesPutOptions {
	return &PcloudIkepoliciesPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		IkePolicyID: core.StringPtr(ikePolicyID),
		Body: body,
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudIkepoliciesPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudIkepoliciesPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetIkePolicyID : Allow user to set IkePolicyID
func (_options *PcloudIkepoliciesPutOptions) SetIkePolicyID(ikePolicyID string) *PcloudIkepoliciesPutOptions {
	_options.IkePolicyID = core.StringPtr(ikePolicyID)
	return _options
}

// SetBody : Allow user to set Body
func (_options *PcloudIkepoliciesPutOptions) SetBody(body *IkePolicyUpdate) *PcloudIkepoliciesPutOptions {
	_options.Body = body
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudIkepoliciesPutOptions) SetHeaders(param map[string]string) *PcloudIkepoliciesPutOptions {
	options.Headers = param
	return options
}

// PcloudImagesGetOptions : The PcloudImagesGet options.
type PcloudImagesGetOptions struct {
	// Image ID of a image.
	ImageID *string `json:"image_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudImagesGetOptions : Instantiate PcloudImagesGetOptions
func (*PowervsV1) NewPcloudImagesGetOptions(imageID string) *PcloudImagesGetOptions {
	return &PcloudImagesGetOptions{
		ImageID: core.StringPtr(imageID),
	}
}

// SetImageID : Allow user to set ImageID
func (_options *PcloudImagesGetOptions) SetImageID(imageID string) *PcloudImagesGetOptions {
	_options.ImageID = core.StringPtr(imageID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudImagesGetOptions) SetHeaders(param map[string]string) *PcloudImagesGetOptions {
	options.Headers = param
	return options
}

// PcloudImagesGetallOptions : The PcloudImagesGetall options.
type PcloudImagesGetallOptions struct {
	// Include SAP images with get available stock images.
	Sap *bool `json:"sap,omitempty"`

	// Include VTL images with get available stock images.
	Vtl *bool `json:"vtl,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudImagesGetallOptions : Instantiate PcloudImagesGetallOptions
func (*PowervsV1) NewPcloudImagesGetallOptions() *PcloudImagesGetallOptions {
	return &PcloudImagesGetallOptions{}
}

// SetSap : Allow user to set Sap
func (_options *PcloudImagesGetallOptions) SetSap(sap bool) *PcloudImagesGetallOptions {
	_options.Sap = core.BoolPtr(sap)
	return _options
}

// SetVtl : Allow user to set Vtl
func (_options *PcloudImagesGetallOptions) SetVtl(vtl bool) *PcloudImagesGetallOptions {
	_options.Vtl = core.BoolPtr(vtl)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudImagesGetallOptions) SetHeaders(param map[string]string) *PcloudImagesGetallOptions {
	options.Headers = param
	return options
}

// PcloudIpsecpoliciesDeleteOptions : The PcloudIpsecpoliciesDelete options.
type PcloudIpsecpoliciesDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// ID of a IPSec Policy.
	IpsecPolicyID *string `json:"ipsec_policy_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudIpsecpoliciesDeleteOptions : Instantiate PcloudIpsecpoliciesDeleteOptions
func (*PowervsV1) NewPcloudIpsecpoliciesDeleteOptions(cloudInstanceID string, ipsecPolicyID string) *PcloudIpsecpoliciesDeleteOptions {
	return &PcloudIpsecpoliciesDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		IpsecPolicyID: core.StringPtr(ipsecPolicyID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudIpsecpoliciesDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudIpsecpoliciesDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetIpsecPolicyID : Allow user to set IpsecPolicyID
func (_options *PcloudIpsecpoliciesDeleteOptions) SetIpsecPolicyID(ipsecPolicyID string) *PcloudIpsecpoliciesDeleteOptions {
	_options.IpsecPolicyID = core.StringPtr(ipsecPolicyID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudIpsecpoliciesDeleteOptions) SetHeaders(param map[string]string) *PcloudIpsecpoliciesDeleteOptions {
	options.Headers = param
	return options
}

// PcloudIpsecpoliciesGetOptions : The PcloudIpsecpoliciesGet options.
type PcloudIpsecpoliciesGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// ID of a IPSec Policy.
	IpsecPolicyID *string `json:"ipsec_policy_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudIpsecpoliciesGetOptions : Instantiate PcloudIpsecpoliciesGetOptions
func (*PowervsV1) NewPcloudIpsecpoliciesGetOptions(cloudInstanceID string, ipsecPolicyID string) *PcloudIpsecpoliciesGetOptions {
	return &PcloudIpsecpoliciesGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		IpsecPolicyID: core.StringPtr(ipsecPolicyID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudIpsecpoliciesGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudIpsecpoliciesGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetIpsecPolicyID : Allow user to set IpsecPolicyID
func (_options *PcloudIpsecpoliciesGetOptions) SetIpsecPolicyID(ipsecPolicyID string) *PcloudIpsecpoliciesGetOptions {
	_options.IpsecPolicyID = core.StringPtr(ipsecPolicyID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudIpsecpoliciesGetOptions) SetHeaders(param map[string]string) *PcloudIpsecpoliciesGetOptions {
	options.Headers = param
	return options
}

// PcloudIpsecpoliciesGetallOptions : The PcloudIpsecpoliciesGetall options.
type PcloudIpsecpoliciesGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudIpsecpoliciesGetallOptions : Instantiate PcloudIpsecpoliciesGetallOptions
func (*PowervsV1) NewPcloudIpsecpoliciesGetallOptions(cloudInstanceID string) *PcloudIpsecpoliciesGetallOptions {
	return &PcloudIpsecpoliciesGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudIpsecpoliciesGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudIpsecpoliciesGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudIpsecpoliciesGetallOptions) SetHeaders(param map[string]string) *PcloudIpsecpoliciesGetallOptions {
	options.Headers = param
	return options
}

// PcloudIpsecpoliciesPostOptions : The PcloudIpsecpoliciesPost options.
type PcloudIpsecpoliciesPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Diffie-Hellman group.
	DhGroup *int64 `json:"dhGroup" validate:"required"`

	// connection encryption policy.
	Encryption *string `json:"encryption" validate:"required"`

	// Policy key lifetime.
	KeyLifetime *int64 `json:"keyLifetime" validate:"required"`

	// IPSec Policy name.
	Name *string `json:"name" validate:"required"`

	// Perfect Forward Secrecy.
	Pfs *bool `json:"pfs" validate:"required"`

	// authentication for IPSec policy.
	Authentication *string `json:"authentication,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudIpsecpoliciesPostOptions.Encryption property.
// connection encryption policy.
const (
	PcloudIpsecpoliciesPostOptionsEncryptionAes128CbcConst = "aes-128-cbc"
	PcloudIpsecpoliciesPostOptionsEncryptionAes128GcmConst = "aes-128-gcm"
	PcloudIpsecpoliciesPostOptionsEncryptionAes192CbcConst = "aes-192-cbc"
	PcloudIpsecpoliciesPostOptionsEncryptionAes192GcmConst = "aes-192-gcm"
	PcloudIpsecpoliciesPostOptionsEncryptionAes256CbcConst = "aes-256-cbc"
	PcloudIpsecpoliciesPostOptionsEncryptionAes256GcmConst = "aes-256-gcm"
)

// Constants associated with the PcloudIpsecpoliciesPostOptions.Authentication property.
// authentication for IPSec policy.
const (
	PcloudIpsecpoliciesPostOptionsAuthenticationHmacSha196Const = "hmac-sha1-96"
	PcloudIpsecpoliciesPostOptionsAuthenticationHmacSha256128Const = "hmac-sha-256-128"
	PcloudIpsecpoliciesPostOptionsAuthenticationNoneConst = "none"
)

// NewPcloudIpsecpoliciesPostOptions : Instantiate PcloudIpsecpoliciesPostOptions
func (*PowervsV1) NewPcloudIpsecpoliciesPostOptions(cloudInstanceID string, dhGroup int64, encryption string, keyLifetime int64, name string, pfs bool) *PcloudIpsecpoliciesPostOptions {
	return &PcloudIpsecpoliciesPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		DhGroup: core.Int64Ptr(dhGroup),
		Encryption: core.StringPtr(encryption),
		KeyLifetime: core.Int64Ptr(keyLifetime),
		Name: core.StringPtr(name),
		Pfs: core.BoolPtr(pfs),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudIpsecpoliciesPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudIpsecpoliciesPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetDhGroup : Allow user to set DhGroup
func (_options *PcloudIpsecpoliciesPostOptions) SetDhGroup(dhGroup int64) *PcloudIpsecpoliciesPostOptions {
	_options.DhGroup = core.Int64Ptr(dhGroup)
	return _options
}

// SetEncryption : Allow user to set Encryption
func (_options *PcloudIpsecpoliciesPostOptions) SetEncryption(encryption string) *PcloudIpsecpoliciesPostOptions {
	_options.Encryption = core.StringPtr(encryption)
	return _options
}

// SetKeyLifetime : Allow user to set KeyLifetime
func (_options *PcloudIpsecpoliciesPostOptions) SetKeyLifetime(keyLifetime int64) *PcloudIpsecpoliciesPostOptions {
	_options.KeyLifetime = core.Int64Ptr(keyLifetime)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudIpsecpoliciesPostOptions) SetName(name string) *PcloudIpsecpoliciesPostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetPfs : Allow user to set Pfs
func (_options *PcloudIpsecpoliciesPostOptions) SetPfs(pfs bool) *PcloudIpsecpoliciesPostOptions {
	_options.Pfs = core.BoolPtr(pfs)
	return _options
}

// SetAuthentication : Allow user to set Authentication
func (_options *PcloudIpsecpoliciesPostOptions) SetAuthentication(authentication string) *PcloudIpsecpoliciesPostOptions {
	_options.Authentication = core.StringPtr(authentication)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudIpsecpoliciesPostOptions) SetHeaders(param map[string]string) *PcloudIpsecpoliciesPostOptions {
	options.Headers = param
	return options
}

// PcloudIpsecpoliciesPutOptions : The PcloudIpsecpoliciesPut options.
type PcloudIpsecpoliciesPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// ID of a IPSec Policy.
	IpsecPolicyID *string `json:"ipsec_policy_id" validate:"required,ne="`

	// Parameters for the update of an IPSec Policy.
	Body *IPSecPolicyUpdate `json:"body" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudIpsecpoliciesPutOptions : Instantiate PcloudIpsecpoliciesPutOptions
func (*PowervsV1) NewPcloudIpsecpoliciesPutOptions(cloudInstanceID string, ipsecPolicyID string, body *IPSecPolicyUpdate) *PcloudIpsecpoliciesPutOptions {
	return &PcloudIpsecpoliciesPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		IpsecPolicyID: core.StringPtr(ipsecPolicyID),
		Body: body,
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudIpsecpoliciesPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudIpsecpoliciesPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetIpsecPolicyID : Allow user to set IpsecPolicyID
func (_options *PcloudIpsecpoliciesPutOptions) SetIpsecPolicyID(ipsecPolicyID string) *PcloudIpsecpoliciesPutOptions {
	_options.IpsecPolicyID = core.StringPtr(ipsecPolicyID)
	return _options
}

// SetBody : Allow user to set Body
func (_options *PcloudIpsecpoliciesPutOptions) SetBody(body *IPSecPolicyUpdate) *PcloudIpsecpoliciesPutOptions {
	_options.Body = body
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudIpsecpoliciesPutOptions) SetHeaders(param map[string]string) *PcloudIpsecpoliciesPutOptions {
	options.Headers = param
	return options
}

// PcloudLocationsDisasterrecoveryGetOptions : The PcloudLocationsDisasterrecoveryGet options.
type PcloudLocationsDisasterrecoveryGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudLocationsDisasterrecoveryGetOptions : Instantiate PcloudLocationsDisasterrecoveryGetOptions
func (*PowervsV1) NewPcloudLocationsDisasterrecoveryGetOptions(cloudInstanceID string) *PcloudLocationsDisasterrecoveryGetOptions {
	return &PcloudLocationsDisasterrecoveryGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudLocationsDisasterrecoveryGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudLocationsDisasterrecoveryGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudLocationsDisasterrecoveryGetOptions) SetHeaders(param map[string]string) *PcloudLocationsDisasterrecoveryGetOptions {
	options.Headers = param
	return options
}

// PcloudLocationsDisasterrecoveryGetallOptions : The PcloudLocationsDisasterrecoveryGetall options.
type PcloudLocationsDisasterrecoveryGetallOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudLocationsDisasterrecoveryGetallOptions : Instantiate PcloudLocationsDisasterrecoveryGetallOptions
func (*PowervsV1) NewPcloudLocationsDisasterrecoveryGetallOptions() *PcloudLocationsDisasterrecoveryGetallOptions {
	return &PcloudLocationsDisasterrecoveryGetallOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *PcloudLocationsDisasterrecoveryGetallOptions) SetHeaders(param map[string]string) *PcloudLocationsDisasterrecoveryGetallOptions {
	options.Headers = param
	return options
}

// PcloudNetworksDeleteOptions : The PcloudNetworksDelete options.
type PcloudNetworksDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Network ID.
	NetworkID *string `json:"network_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudNetworksDeleteOptions : Instantiate PcloudNetworksDeleteOptions
func (*PowervsV1) NewPcloudNetworksDeleteOptions(cloudInstanceID string, networkID string) *PcloudNetworksDeleteOptions {
	return &PcloudNetworksDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		NetworkID: core.StringPtr(networkID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudNetworksDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudNetworksDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *PcloudNetworksDeleteOptions) SetNetworkID(networkID string) *PcloudNetworksDeleteOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudNetworksDeleteOptions) SetHeaders(param map[string]string) *PcloudNetworksDeleteOptions {
	options.Headers = param
	return options
}

// PcloudNetworksGetOptions : The PcloudNetworksGet options.
type PcloudNetworksGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Network ID.
	NetworkID *string `json:"network_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudNetworksGetOptions : Instantiate PcloudNetworksGetOptions
func (*PowervsV1) NewPcloudNetworksGetOptions(cloudInstanceID string, networkID string) *PcloudNetworksGetOptions {
	return &PcloudNetworksGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		NetworkID: core.StringPtr(networkID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudNetworksGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudNetworksGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *PcloudNetworksGetOptions) SetNetworkID(networkID string) *PcloudNetworksGetOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudNetworksGetOptions) SetHeaders(param map[string]string) *PcloudNetworksGetOptions {
	options.Headers = param
	return options
}

// PcloudNetworksGetallOptions : The PcloudNetworksGetall options.
type PcloudNetworksGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// A filter expression that filters resources listed in the response.
	Filter *string `json:"filter,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudNetworksGetallOptions : Instantiate PcloudNetworksGetallOptions
func (*PowervsV1) NewPcloudNetworksGetallOptions(cloudInstanceID string) *PcloudNetworksGetallOptions {
	return &PcloudNetworksGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudNetworksGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudNetworksGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetFilter : Allow user to set Filter
func (_options *PcloudNetworksGetallOptions) SetFilter(filter string) *PcloudNetworksGetallOptions {
	_options.Filter = core.StringPtr(filter)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudNetworksGetallOptions) SetHeaders(param map[string]string) *PcloudNetworksGetallOptions {
	options.Headers = param
	return options
}

// PcloudNetworksPortsDeleteOptions : The PcloudNetworksPortsDelete options.
type PcloudNetworksPortsDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Network ID.
	NetworkID *string `json:"network_id" validate:"required,ne="`

	// Port ID.
	PortID *string `json:"port_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudNetworksPortsDeleteOptions : Instantiate PcloudNetworksPortsDeleteOptions
func (*PowervsV1) NewPcloudNetworksPortsDeleteOptions(cloudInstanceID string, networkID string, portID string) *PcloudNetworksPortsDeleteOptions {
	return &PcloudNetworksPortsDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		NetworkID: core.StringPtr(networkID),
		PortID: core.StringPtr(portID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudNetworksPortsDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudNetworksPortsDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *PcloudNetworksPortsDeleteOptions) SetNetworkID(networkID string) *PcloudNetworksPortsDeleteOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetPortID : Allow user to set PortID
func (_options *PcloudNetworksPortsDeleteOptions) SetPortID(portID string) *PcloudNetworksPortsDeleteOptions {
	_options.PortID = core.StringPtr(portID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudNetworksPortsDeleteOptions) SetHeaders(param map[string]string) *PcloudNetworksPortsDeleteOptions {
	options.Headers = param
	return options
}

// PcloudNetworksPortsGetOptions : The PcloudNetworksPortsGet options.
type PcloudNetworksPortsGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Network ID.
	NetworkID *string `json:"network_id" validate:"required,ne="`

	// Port ID.
	PortID *string `json:"port_id" validate:"required,ne="`

	// The type of the response: application/json or applicaton/json.
	Accept *string `json:"Accept,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudNetworksPortsGetOptions : Instantiate PcloudNetworksPortsGetOptions
func (*PowervsV1) NewPcloudNetworksPortsGetOptions(cloudInstanceID string, networkID string, portID string) *PcloudNetworksPortsGetOptions {
	return &PcloudNetworksPortsGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		NetworkID: core.StringPtr(networkID),
		PortID: core.StringPtr(portID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudNetworksPortsGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudNetworksPortsGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *PcloudNetworksPortsGetOptions) SetNetworkID(networkID string) *PcloudNetworksPortsGetOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetPortID : Allow user to set PortID
func (_options *PcloudNetworksPortsGetOptions) SetPortID(portID string) *PcloudNetworksPortsGetOptions {
	_options.PortID = core.StringPtr(portID)
	return _options
}

// SetAccept : Allow user to set Accept
func (_options *PcloudNetworksPortsGetOptions) SetAccept(accept string) *PcloudNetworksPortsGetOptions {
	_options.Accept = core.StringPtr(accept)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudNetworksPortsGetOptions) SetHeaders(param map[string]string) *PcloudNetworksPortsGetOptions {
	options.Headers = param
	return options
}

// PcloudNetworksPortsGetallOptions : The PcloudNetworksPortsGetall options.
type PcloudNetworksPortsGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Network ID.
	NetworkID *string `json:"network_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudNetworksPortsGetallOptions : Instantiate PcloudNetworksPortsGetallOptions
func (*PowervsV1) NewPcloudNetworksPortsGetallOptions(cloudInstanceID string, networkID string) *PcloudNetworksPortsGetallOptions {
	return &PcloudNetworksPortsGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		NetworkID: core.StringPtr(networkID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudNetworksPortsGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudNetworksPortsGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *PcloudNetworksPortsGetallOptions) SetNetworkID(networkID string) *PcloudNetworksPortsGetallOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudNetworksPortsGetallOptions) SetHeaders(param map[string]string) *PcloudNetworksPortsGetallOptions {
	options.Headers = param
	return options
}

// PcloudNetworksPortsPostOptions : The PcloudNetworksPortsPost options.
type PcloudNetworksPortsPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Network ID.
	NetworkID *string `json:"network_id" validate:"required,ne="`

	// Description of the port (not unique or indexable).
	Description *string `json:"description,omitempty"`

	// The requested ip address of this port.
	IPAddress *string `json:"ipAddress,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudNetworksPortsPostOptions : Instantiate PcloudNetworksPortsPostOptions
func (*PowervsV1) NewPcloudNetworksPortsPostOptions(cloudInstanceID string, networkID string) *PcloudNetworksPortsPostOptions {
	return &PcloudNetworksPortsPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		NetworkID: core.StringPtr(networkID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudNetworksPortsPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudNetworksPortsPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *PcloudNetworksPortsPostOptions) SetNetworkID(networkID string) *PcloudNetworksPortsPostOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *PcloudNetworksPortsPostOptions) SetDescription(description string) *PcloudNetworksPortsPostOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetIPAddress : Allow user to set IPAddress
func (_options *PcloudNetworksPortsPostOptions) SetIPAddress(ipAddress string) *PcloudNetworksPortsPostOptions {
	_options.IPAddress = core.StringPtr(ipAddress)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudNetworksPortsPostOptions) SetHeaders(param map[string]string) *PcloudNetworksPortsPostOptions {
	options.Headers = param
	return options
}

// PcloudNetworksPortsPutOptions : The PcloudNetworksPortsPut options.
type PcloudNetworksPortsPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Network ID.
	NetworkID *string `json:"network_id" validate:"required,ne="`

	// Port ID.
	PortID *string `json:"port_id" validate:"required,ne="`

	// Description of the port (not unique or indexable).
	Description *string `json:"description,omitempty"`

	// If supplied populated it attaches to the PVMInstanceID, if empty detaches from PVMInstanceID.
	PvmInstanceID *string `json:"pvmInstanceID,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudNetworksPortsPutOptions : Instantiate PcloudNetworksPortsPutOptions
func (*PowervsV1) NewPcloudNetworksPortsPutOptions(cloudInstanceID string, networkID string, portID string) *PcloudNetworksPortsPutOptions {
	return &PcloudNetworksPortsPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		NetworkID: core.StringPtr(networkID),
		PortID: core.StringPtr(portID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudNetworksPortsPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudNetworksPortsPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *PcloudNetworksPortsPutOptions) SetNetworkID(networkID string) *PcloudNetworksPortsPutOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetPortID : Allow user to set PortID
func (_options *PcloudNetworksPortsPutOptions) SetPortID(portID string) *PcloudNetworksPortsPutOptions {
	_options.PortID = core.StringPtr(portID)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *PcloudNetworksPortsPutOptions) SetDescription(description string) *PcloudNetworksPortsPutOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudNetworksPortsPutOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudNetworksPortsPutOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudNetworksPortsPutOptions) SetHeaders(param map[string]string) *PcloudNetworksPortsPutOptions {
	options.Headers = param
	return options
}

// PcloudNetworksPostOptions : The PcloudNetworksPost options.
type PcloudNetworksPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Type of Network - 'vlan' (private network) 'pub-vlan' (public network) 'dhcp-vlan' (for satellite locations only).
	Type *string `json:"type" validate:"required"`

	// Network communication configuration (for satellite locations only)
	//   * `internal-only` - network is only used for internal host communication
	//   * `outbound-only` - network will be capable of egress traffic
	//   * `bidirectional-static-route` - network will be capable of ingress and egress traffic via static routes
	//   * `bidirectional-bgp` - network will be capable of ingress and egress traffic via bgp configuration
	//   * `bidirectional-l2out` - network will be capable of ingress and egress traffic via l2out ACI configuration.
	AccessConfig *string `json:"accessConfig,omitempty"`

	// Network in CIDR notation (192.168.0.0/24).
	CIDR *string `json:"cidr,omitempty"`

	// DNS Servers. If not specified, default is 127.0.0.1 for 'vlan' (private network) and 9.9.9.9 for 'pub-vlan' (public
	// network).
	DnsServers []string `json:"dnsServers,omitempty"`

	// Gateway IP Address.
	Gateway *string `json:"gateway,omitempty"`

	// IP Address Ranges.
	IPAddressRanges []IPAddressRange `json:"ipAddressRanges,omitempty"`

	// (deprecated - replaced by mtu) Enable MTU Jumbo Network (for multi-zone locations only).
	Jumbo *bool `json:"jumbo,omitempty"`

	// Maximum transmission unit.
	Mtu *int64 `json:"mtu,omitempty"`

	// Network Name.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudNetworksPostOptions.Type property.
// Type of Network - 'vlan' (private network) 'pub-vlan' (public network) 'dhcp-vlan' (for satellite locations only).
const (
	PcloudNetworksPostOptionsTypeDhcpVlanConst = "dhcp-vlan"
	PcloudNetworksPostOptionsTypePubVlanConst = "pub-vlan"
	PcloudNetworksPostOptionsTypeVlanConst = "vlan"
)

// Constants associated with the PcloudNetworksPostOptions.AccessConfig property.
// Network communication configuration (for satellite locations only)
//   * `internal-only` - network is only used for internal host communication
//   * `outbound-only` - network will be capable of egress traffic
//   * `bidirectional-static-route` - network will be capable of ingress and egress traffic via static routes
//   * `bidirectional-bgp` - network will be capable of ingress and egress traffic via bgp configuration
//   * `bidirectional-l2out` - network will be capable of ingress and egress traffic via l2out ACI configuration.
const (
	PcloudNetworksPostOptionsAccessConfigBidirectionalBgpConst = "bidirectional-bgp"
	PcloudNetworksPostOptionsAccessConfigBidirectionalL2outConst = "bidirectional-l2out"
	PcloudNetworksPostOptionsAccessConfigBidirectionalStaticRouteConst = "bidirectional-static-route"
	PcloudNetworksPostOptionsAccessConfigInternalOnlyConst = "internal-only"
	PcloudNetworksPostOptionsAccessConfigOutboundOnlyConst = "outbound-only"
)

// NewPcloudNetworksPostOptions : Instantiate PcloudNetworksPostOptions
func (*PowervsV1) NewPcloudNetworksPostOptions(cloudInstanceID string, typeVar string) *PcloudNetworksPostOptions {
	return &PcloudNetworksPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		Type: core.StringPtr(typeVar),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudNetworksPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudNetworksPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetType : Allow user to set Type
func (_options *PcloudNetworksPostOptions) SetType(typeVar string) *PcloudNetworksPostOptions {
	_options.Type = core.StringPtr(typeVar)
	return _options
}

// SetAccessConfig : Allow user to set AccessConfig
func (_options *PcloudNetworksPostOptions) SetAccessConfig(accessConfig string) *PcloudNetworksPostOptions {
	_options.AccessConfig = core.StringPtr(accessConfig)
	return _options
}

// SetCIDR : Allow user to set CIDR
func (_options *PcloudNetworksPostOptions) SetCIDR(cidr string) *PcloudNetworksPostOptions {
	_options.CIDR = core.StringPtr(cidr)
	return _options
}

// SetDnsServers : Allow user to set DnsServers
func (_options *PcloudNetworksPostOptions) SetDnsServers(dnsServers []string) *PcloudNetworksPostOptions {
	_options.DnsServers = dnsServers
	return _options
}

// SetGateway : Allow user to set Gateway
func (_options *PcloudNetworksPostOptions) SetGateway(gateway string) *PcloudNetworksPostOptions {
	_options.Gateway = core.StringPtr(gateway)
	return _options
}

// SetIPAddressRanges : Allow user to set IPAddressRanges
func (_options *PcloudNetworksPostOptions) SetIPAddressRanges(ipAddressRanges []IPAddressRange) *PcloudNetworksPostOptions {
	_options.IPAddressRanges = ipAddressRanges
	return _options
}

// SetJumbo : Allow user to set Jumbo
func (_options *PcloudNetworksPostOptions) SetJumbo(jumbo bool) *PcloudNetworksPostOptions {
	_options.Jumbo = core.BoolPtr(jumbo)
	return _options
}

// SetMtu : Allow user to set Mtu
func (_options *PcloudNetworksPostOptions) SetMtu(mtu int64) *PcloudNetworksPostOptions {
	_options.Mtu = core.Int64Ptr(mtu)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudNetworksPostOptions) SetName(name string) *PcloudNetworksPostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudNetworksPostOptions) SetHeaders(param map[string]string) *PcloudNetworksPostOptions {
	options.Headers = param
	return options
}

// PcloudNetworksPutOptions : The PcloudNetworksPut options.
type PcloudNetworksPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Network ID.
	NetworkID *string `json:"network_id" validate:"required,ne="`

	// Replaces the current DNS Servers.
	DnsServers []string `json:"dnsServers,omitempty"`

	// Replaces the current Gateway IP Address.
	Gateway *string `json:"gateway,omitempty"`

	// Replaces the current IP Address Ranges.
	IPAddressRanges []IPAddressRange `json:"ipAddressRanges,omitempty"`

	// Replaces the current Network Name.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudNetworksPutOptions : Instantiate PcloudNetworksPutOptions
func (*PowervsV1) NewPcloudNetworksPutOptions(cloudInstanceID string, networkID string) *PcloudNetworksPutOptions {
	return &PcloudNetworksPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		NetworkID: core.StringPtr(networkID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudNetworksPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudNetworksPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *PcloudNetworksPutOptions) SetNetworkID(networkID string) *PcloudNetworksPutOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetDnsServers : Allow user to set DnsServers
func (_options *PcloudNetworksPutOptions) SetDnsServers(dnsServers []string) *PcloudNetworksPutOptions {
	_options.DnsServers = dnsServers
	return _options
}

// SetGateway : Allow user to set Gateway
func (_options *PcloudNetworksPutOptions) SetGateway(gateway string) *PcloudNetworksPutOptions {
	_options.Gateway = core.StringPtr(gateway)
	return _options
}

// SetIPAddressRanges : Allow user to set IPAddressRanges
func (_options *PcloudNetworksPutOptions) SetIPAddressRanges(ipAddressRanges []IPAddressRange) *PcloudNetworksPutOptions {
	_options.IPAddressRanges = ipAddressRanges
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudNetworksPutOptions) SetName(name string) *PcloudNetworksPutOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudNetworksPutOptions) SetHeaders(param map[string]string) *PcloudNetworksPutOptions {
	options.Headers = param
	return options
}

// PcloudPlacementgroupsDeleteOptions : The PcloudPlacementgroupsDelete options.
type PcloudPlacementgroupsDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Placement Group ID.
	PlacementGroupID *string `json:"placement_group_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPlacementgroupsDeleteOptions : Instantiate PcloudPlacementgroupsDeleteOptions
func (*PowervsV1) NewPcloudPlacementgroupsDeleteOptions(cloudInstanceID string, placementGroupID string) *PcloudPlacementgroupsDeleteOptions {
	return &PcloudPlacementgroupsDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PlacementGroupID: core.StringPtr(placementGroupID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPlacementgroupsDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPlacementgroupsDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPlacementGroupID : Allow user to set PlacementGroupID
func (_options *PcloudPlacementgroupsDeleteOptions) SetPlacementGroupID(placementGroupID string) *PcloudPlacementgroupsDeleteOptions {
	_options.PlacementGroupID = core.StringPtr(placementGroupID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPlacementgroupsDeleteOptions) SetHeaders(param map[string]string) *PcloudPlacementgroupsDeleteOptions {
	options.Headers = param
	return options
}

// PcloudPlacementgroupsGetOptions : The PcloudPlacementgroupsGet options.
type PcloudPlacementgroupsGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Placement Group ID.
	PlacementGroupID *string `json:"placement_group_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPlacementgroupsGetOptions : Instantiate PcloudPlacementgroupsGetOptions
func (*PowervsV1) NewPcloudPlacementgroupsGetOptions(cloudInstanceID string, placementGroupID string) *PcloudPlacementgroupsGetOptions {
	return &PcloudPlacementgroupsGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PlacementGroupID: core.StringPtr(placementGroupID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPlacementgroupsGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPlacementgroupsGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPlacementGroupID : Allow user to set PlacementGroupID
func (_options *PcloudPlacementgroupsGetOptions) SetPlacementGroupID(placementGroupID string) *PcloudPlacementgroupsGetOptions {
	_options.PlacementGroupID = core.StringPtr(placementGroupID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPlacementgroupsGetOptions) SetHeaders(param map[string]string) *PcloudPlacementgroupsGetOptions {
	options.Headers = param
	return options
}

// PcloudPlacementgroupsGetallOptions : The PcloudPlacementgroupsGetall options.
type PcloudPlacementgroupsGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPlacementgroupsGetallOptions : Instantiate PcloudPlacementgroupsGetallOptions
func (*PowervsV1) NewPcloudPlacementgroupsGetallOptions(cloudInstanceID string) *PcloudPlacementgroupsGetallOptions {
	return &PcloudPlacementgroupsGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPlacementgroupsGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPlacementgroupsGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPlacementgroupsGetallOptions) SetHeaders(param map[string]string) *PcloudPlacementgroupsGetallOptions {
	options.Headers = param
	return options
}

// PcloudPlacementgroupsMembersDeleteOptions : The PcloudPlacementgroupsMembersDelete options.
type PcloudPlacementgroupsMembersDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Placement Group ID.
	PlacementGroupID *string `json:"placement_group_id" validate:"required,ne="`

	// The ID of the Server.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPlacementgroupsMembersDeleteOptions : Instantiate PcloudPlacementgroupsMembersDeleteOptions
func (*PowervsV1) NewPcloudPlacementgroupsMembersDeleteOptions(cloudInstanceID string, placementGroupID string, id string) *PcloudPlacementgroupsMembersDeleteOptions {
	return &PcloudPlacementgroupsMembersDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PlacementGroupID: core.StringPtr(placementGroupID),
		ID: core.StringPtr(id),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPlacementgroupsMembersDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPlacementgroupsMembersDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPlacementGroupID : Allow user to set PlacementGroupID
func (_options *PcloudPlacementgroupsMembersDeleteOptions) SetPlacementGroupID(placementGroupID string) *PcloudPlacementgroupsMembersDeleteOptions {
	_options.PlacementGroupID = core.StringPtr(placementGroupID)
	return _options
}

// SetID : Allow user to set ID
func (_options *PcloudPlacementgroupsMembersDeleteOptions) SetID(id string) *PcloudPlacementgroupsMembersDeleteOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPlacementgroupsMembersDeleteOptions) SetHeaders(param map[string]string) *PcloudPlacementgroupsMembersDeleteOptions {
	options.Headers = param
	return options
}

// PcloudPlacementgroupsMembersPostOptions : The PcloudPlacementgroupsMembersPost options.
type PcloudPlacementgroupsMembersPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Placement Group ID.
	PlacementGroupID *string `json:"placement_group_id" validate:"required,ne="`

	// The ID of the Server.
	ID *string `json:"id" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPlacementgroupsMembersPostOptions : Instantiate PcloudPlacementgroupsMembersPostOptions
func (*PowervsV1) NewPcloudPlacementgroupsMembersPostOptions(cloudInstanceID string, placementGroupID string, id string) *PcloudPlacementgroupsMembersPostOptions {
	return &PcloudPlacementgroupsMembersPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PlacementGroupID: core.StringPtr(placementGroupID),
		ID: core.StringPtr(id),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPlacementgroupsMembersPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPlacementgroupsMembersPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPlacementGroupID : Allow user to set PlacementGroupID
func (_options *PcloudPlacementgroupsMembersPostOptions) SetPlacementGroupID(placementGroupID string) *PcloudPlacementgroupsMembersPostOptions {
	_options.PlacementGroupID = core.StringPtr(placementGroupID)
	return _options
}

// SetID : Allow user to set ID
func (_options *PcloudPlacementgroupsMembersPostOptions) SetID(id string) *PcloudPlacementgroupsMembersPostOptions {
	_options.ID = core.StringPtr(id)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPlacementgroupsMembersPostOptions) SetHeaders(param map[string]string) *PcloudPlacementgroupsMembersPostOptions {
	options.Headers = param
	return options
}

// PcloudPlacementgroupsPostOptions : The PcloudPlacementgroupsPost options.
type PcloudPlacementgroupsPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// The name of the Placement Group.
	Name *string `json:"name" validate:"required"`

	// The Placement Group Policy.
	Policy *string `json:"policy" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudPlacementgroupsPostOptions.Policy property.
// The Placement Group Policy.
const (
	PcloudPlacementgroupsPostOptionsPolicyAffinityConst = "affinity"
	PcloudPlacementgroupsPostOptionsPolicyAntiAffinityConst = "anti-affinity"
)

// NewPcloudPlacementgroupsPostOptions : Instantiate PcloudPlacementgroupsPostOptions
func (*PowervsV1) NewPcloudPlacementgroupsPostOptions(cloudInstanceID string, name string, policy string) *PcloudPlacementgroupsPostOptions {
	return &PcloudPlacementgroupsPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		Name: core.StringPtr(name),
		Policy: core.StringPtr(policy),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPlacementgroupsPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPlacementgroupsPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudPlacementgroupsPostOptions) SetName(name string) *PcloudPlacementgroupsPostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetPolicy : Allow user to set Policy
func (_options *PcloudPlacementgroupsPostOptions) SetPolicy(policy string) *PcloudPlacementgroupsPostOptions {
	_options.Policy = core.StringPtr(policy)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPlacementgroupsPostOptions) SetHeaders(param map[string]string) *PcloudPlacementgroupsPostOptions {
	options.Headers = param
	return options
}

// PcloudPodcapacityGetOptions : The PcloudPodcapacityGet options.
type PcloudPodcapacityGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPodcapacityGetOptions : Instantiate PcloudPodcapacityGetOptions
func (*PowervsV1) NewPcloudPodcapacityGetOptions(cloudInstanceID string) *PcloudPodcapacityGetOptions {
	return &PcloudPodcapacityGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPodcapacityGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPodcapacityGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPodcapacityGetOptions) SetHeaders(param map[string]string) *PcloudPodcapacityGetOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesActionPostOptions : The PcloudPvminstancesActionPost options.
type PcloudPvminstancesActionPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Name of the action to take; can be start, stop, hard-reboot, soft-reboot, immediate-shutdown, reset-state.
	Action *string `json:"action" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudPvminstancesActionPostOptions.Action property.
// Name of the action to take; can be start, stop, hard-reboot, soft-reboot, immediate-shutdown, reset-state.
const (
	PcloudPvminstancesActionPostOptionsActionHardRebootConst = "hard-reboot"
	PcloudPvminstancesActionPostOptionsActionImmediateShutdownConst = "immediate-shutdown"
	PcloudPvminstancesActionPostOptionsActionResetStateConst = "reset-state"
	PcloudPvminstancesActionPostOptionsActionSoftRebootConst = "soft-reboot"
	PcloudPvminstancesActionPostOptionsActionStartConst = "start"
	PcloudPvminstancesActionPostOptionsActionStopConst = "stop"
)

// NewPcloudPvminstancesActionPostOptions : Instantiate PcloudPvminstancesActionPostOptions
func (*PowervsV1) NewPcloudPvminstancesActionPostOptions(cloudInstanceID string, pvmInstanceID string, action string) *PcloudPvminstancesActionPostOptions {
	return &PcloudPvminstancesActionPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		Action: core.StringPtr(action),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesActionPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesActionPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesActionPostOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesActionPostOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetAction : Allow user to set Action
func (_options *PcloudPvminstancesActionPostOptions) SetAction(action string) *PcloudPvminstancesActionPostOptions {
	_options.Action = core.StringPtr(action)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesActionPostOptions) SetHeaders(param map[string]string) *PcloudPvminstancesActionPostOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesCapturePostOptions : The PcloudPvminstancesCapturePost options.
type PcloudPvminstancesCapturePostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Destination for the deployable image.
	CaptureDestination *string `json:"captureDestination" validate:"required"`

	// Name of the deployable image created for the captured PVMInstance.
	CaptureName *string `json:"captureName" validate:"required"`

	// List of Data volume IDs to include in the captured PVMInstance.
	CaptureVolumeIDs []string `json:"captureVolumeIDs,omitempty"`

	// Cloud Storage Access key.
	CloudStorageAccessKey *string `json:"cloudStorageAccessKey,omitempty"`

	// Cloud Storage Image Path (bucket-name [/folder/../..]).
	CloudStorageImagePath *string `json:"cloudStorageImagePath,omitempty"`

	// Cloud Storage Region.
	CloudStorageRegion *string `json:"cloudStorageRegion,omitempty"`

	// Cloud Storage Secret key.
	CloudStorageSecretKey *string `json:"cloudStorageSecretKey,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudPvminstancesCapturePostOptions.CaptureDestination property.
// Destination for the deployable image.
const (
	PcloudPvminstancesCapturePostOptionsCaptureDestinationBothConst = "both"
	PcloudPvminstancesCapturePostOptionsCaptureDestinationCloudStorageConst = "cloud-storage"
	PcloudPvminstancesCapturePostOptionsCaptureDestinationImageCatalogConst = "image-catalog"
)

// NewPcloudPvminstancesCapturePostOptions : Instantiate PcloudPvminstancesCapturePostOptions
func (*PowervsV1) NewPcloudPvminstancesCapturePostOptions(cloudInstanceID string, pvmInstanceID string, captureDestination string, captureName string) *PcloudPvminstancesCapturePostOptions {
	return &PcloudPvminstancesCapturePostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		CaptureDestination: core.StringPtr(captureDestination),
		CaptureName: core.StringPtr(captureName),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesCapturePostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesCapturePostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesCapturePostOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesCapturePostOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetCaptureDestination : Allow user to set CaptureDestination
func (_options *PcloudPvminstancesCapturePostOptions) SetCaptureDestination(captureDestination string) *PcloudPvminstancesCapturePostOptions {
	_options.CaptureDestination = core.StringPtr(captureDestination)
	return _options
}

// SetCaptureName : Allow user to set CaptureName
func (_options *PcloudPvminstancesCapturePostOptions) SetCaptureName(captureName string) *PcloudPvminstancesCapturePostOptions {
	_options.CaptureName = core.StringPtr(captureName)
	return _options
}

// SetCaptureVolumeIDs : Allow user to set CaptureVolumeIDs
func (_options *PcloudPvminstancesCapturePostOptions) SetCaptureVolumeIDs(captureVolumeIDs []string) *PcloudPvminstancesCapturePostOptions {
	_options.CaptureVolumeIDs = captureVolumeIDs
	return _options
}

// SetCloudStorageAccessKey : Allow user to set CloudStorageAccessKey
func (_options *PcloudPvminstancesCapturePostOptions) SetCloudStorageAccessKey(cloudStorageAccessKey string) *PcloudPvminstancesCapturePostOptions {
	_options.CloudStorageAccessKey = core.StringPtr(cloudStorageAccessKey)
	return _options
}

// SetCloudStorageImagePath : Allow user to set CloudStorageImagePath
func (_options *PcloudPvminstancesCapturePostOptions) SetCloudStorageImagePath(cloudStorageImagePath string) *PcloudPvminstancesCapturePostOptions {
	_options.CloudStorageImagePath = core.StringPtr(cloudStorageImagePath)
	return _options
}

// SetCloudStorageRegion : Allow user to set CloudStorageRegion
func (_options *PcloudPvminstancesCapturePostOptions) SetCloudStorageRegion(cloudStorageRegion string) *PcloudPvminstancesCapturePostOptions {
	_options.CloudStorageRegion = core.StringPtr(cloudStorageRegion)
	return _options
}

// SetCloudStorageSecretKey : Allow user to set CloudStorageSecretKey
func (_options *PcloudPvminstancesCapturePostOptions) SetCloudStorageSecretKey(cloudStorageSecretKey string) *PcloudPvminstancesCapturePostOptions {
	_options.CloudStorageSecretKey = core.StringPtr(cloudStorageSecretKey)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesCapturePostOptions) SetHeaders(param map[string]string) *PcloudPvminstancesCapturePostOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesClonePostOptions : The PcloudPvminstancesClonePost options.
type PcloudPvminstancesClonePostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Name of the server to create.
	Name *string `json:"name" validate:"required"`

	// The pvm instance networks information.
	Networks []PvmInstanceAddNetwork `json:"networks" validate:"required"`

	// The name of the SSH key pair provided to the server for authenticating users (looked up in the tenant's list of
	// keys).
	KeyPairName *string `json:"keyPairName,omitempty"`

	// Amount of memory allocated (in GB).
	Memory *float64 `json:"memory,omitempty"`

	// Processor type (dedicated, shared, capped).
	ProcType *string `json:"procType,omitempty"`

	// Number of processors allocated.
	Processors *float64 `json:"processors,omitempty"`

	SoftwareLicenses *SoftwareLicenses `json:"softwareLicenses,omitempty"`

	// List of volume IDs.
	VolumeIDs []string `json:"volumeIDs,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudPvminstancesClonePostOptions.ProcType property.
// Processor type (dedicated, shared, capped).
const (
	PcloudPvminstancesClonePostOptionsProcTypeCappedConst = "capped"
	PcloudPvminstancesClonePostOptionsProcTypeDedicatedConst = "dedicated"
	PcloudPvminstancesClonePostOptionsProcTypeSharedConst = "shared"
)

// NewPcloudPvminstancesClonePostOptions : Instantiate PcloudPvminstancesClonePostOptions
func (*PowervsV1) NewPcloudPvminstancesClonePostOptions(cloudInstanceID string, pvmInstanceID string, name string, networks []PvmInstanceAddNetwork) *PcloudPvminstancesClonePostOptions {
	return &PcloudPvminstancesClonePostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		Name: core.StringPtr(name),
		Networks: networks,
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesClonePostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesClonePostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesClonePostOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesClonePostOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudPvminstancesClonePostOptions) SetName(name string) *PcloudPvminstancesClonePostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetNetworks : Allow user to set Networks
func (_options *PcloudPvminstancesClonePostOptions) SetNetworks(networks []PvmInstanceAddNetwork) *PcloudPvminstancesClonePostOptions {
	_options.Networks = networks
	return _options
}

// SetKeyPairName : Allow user to set KeyPairName
func (_options *PcloudPvminstancesClonePostOptions) SetKeyPairName(keyPairName string) *PcloudPvminstancesClonePostOptions {
	_options.KeyPairName = core.StringPtr(keyPairName)
	return _options
}

// SetMemory : Allow user to set Memory
func (_options *PcloudPvminstancesClonePostOptions) SetMemory(memory float64) *PcloudPvminstancesClonePostOptions {
	_options.Memory = core.Float64Ptr(memory)
	return _options
}

// SetProcType : Allow user to set ProcType
func (_options *PcloudPvminstancesClonePostOptions) SetProcType(procType string) *PcloudPvminstancesClonePostOptions {
	_options.ProcType = core.StringPtr(procType)
	return _options
}

// SetProcessors : Allow user to set Processors
func (_options *PcloudPvminstancesClonePostOptions) SetProcessors(processors float64) *PcloudPvminstancesClonePostOptions {
	_options.Processors = core.Float64Ptr(processors)
	return _options
}

// SetSoftwareLicenses : Allow user to set SoftwareLicenses
func (_options *PcloudPvminstancesClonePostOptions) SetSoftwareLicenses(softwareLicenses *SoftwareLicenses) *PcloudPvminstancesClonePostOptions {
	_options.SoftwareLicenses = softwareLicenses
	return _options
}

// SetVolumeIDs : Allow user to set VolumeIDs
func (_options *PcloudPvminstancesClonePostOptions) SetVolumeIDs(volumeIDs []string) *PcloudPvminstancesClonePostOptions {
	_options.VolumeIDs = volumeIDs
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesClonePostOptions) SetHeaders(param map[string]string) *PcloudPvminstancesClonePostOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesConsoleGetOptions : The PcloudPvminstancesConsoleGet options.
type PcloudPvminstancesConsoleGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesConsoleGetOptions : Instantiate PcloudPvminstancesConsoleGetOptions
func (*PowervsV1) NewPcloudPvminstancesConsoleGetOptions(cloudInstanceID string, pvmInstanceID string) *PcloudPvminstancesConsoleGetOptions {
	return &PcloudPvminstancesConsoleGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesConsoleGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesConsoleGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesConsoleGetOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesConsoleGetOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesConsoleGetOptions) SetHeaders(param map[string]string) *PcloudPvminstancesConsoleGetOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesConsolePostOptions : The PcloudPvminstancesConsolePost options.
type PcloudPvminstancesConsolePostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesConsolePostOptions : Instantiate PcloudPvminstancesConsolePostOptions
func (*PowervsV1) NewPcloudPvminstancesConsolePostOptions(cloudInstanceID string, pvmInstanceID string) *PcloudPvminstancesConsolePostOptions {
	return &PcloudPvminstancesConsolePostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesConsolePostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesConsolePostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesConsolePostOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesConsolePostOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesConsolePostOptions) SetHeaders(param map[string]string) *PcloudPvminstancesConsolePostOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesConsolePutOptions : The PcloudPvminstancesConsolePut options.
type PcloudPvminstancesConsolePutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// language code.
	Code *string `json:"code" validate:"required"`

	// language description.
	Language *string `json:"language,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesConsolePutOptions : Instantiate PcloudPvminstancesConsolePutOptions
func (*PowervsV1) NewPcloudPvminstancesConsolePutOptions(cloudInstanceID string, pvmInstanceID string, code string) *PcloudPvminstancesConsolePutOptions {
	return &PcloudPvminstancesConsolePutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		Code: core.StringPtr(code),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesConsolePutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesConsolePutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesConsolePutOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesConsolePutOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetCode : Allow user to set Code
func (_options *PcloudPvminstancesConsolePutOptions) SetCode(code string) *PcloudPvminstancesConsolePutOptions {
	_options.Code = core.StringPtr(code)
	return _options
}

// SetLanguage : Allow user to set Language
func (_options *PcloudPvminstancesConsolePutOptions) SetLanguage(language string) *PcloudPvminstancesConsolePutOptions {
	_options.Language = core.StringPtr(language)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesConsolePutOptions) SetHeaders(param map[string]string) *PcloudPvminstancesConsolePutOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesDeleteOptions : The PcloudPvminstancesDelete options.
type PcloudPvminstancesDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Indicates if all data volumes attached to the PVMInstance should be deleted when deleting the PVMInstance. Shared
	// data volumes will be deleted if there are no other PVMInstances attached.
	DeleteDataVolumes *bool `json:"delete_data_volumes,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesDeleteOptions : Instantiate PcloudPvminstancesDeleteOptions
func (*PowervsV1) NewPcloudPvminstancesDeleteOptions(cloudInstanceID string, pvmInstanceID string) *PcloudPvminstancesDeleteOptions {
	return &PcloudPvminstancesDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesDeleteOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesDeleteOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetDeleteDataVolumes : Allow user to set DeleteDataVolumes
func (_options *PcloudPvminstancesDeleteOptions) SetDeleteDataVolumes(deleteDataVolumes bool) *PcloudPvminstancesDeleteOptions {
	_options.DeleteDataVolumes = core.BoolPtr(deleteDataVolumes)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesDeleteOptions) SetHeaders(param map[string]string) *PcloudPvminstancesDeleteOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesGetOptions : The PcloudPvminstancesGet options.
type PcloudPvminstancesGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesGetOptions : Instantiate PcloudPvminstancesGetOptions
func (*PowervsV1) NewPcloudPvminstancesGetOptions(cloudInstanceID string, pvmInstanceID string) *PcloudPvminstancesGetOptions {
	return &PcloudPvminstancesGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesGetOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesGetOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesGetOptions) SetHeaders(param map[string]string) *PcloudPvminstancesGetOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesGetallOptions : The PcloudPvminstancesGetall options.
type PcloudPvminstancesGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesGetallOptions : Instantiate PcloudPvminstancesGetallOptions
func (*PowervsV1) NewPcloudPvminstancesGetallOptions(cloudInstanceID string) *PcloudPvminstancesGetallOptions {
	return &PcloudPvminstancesGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesGetallOptions) SetHeaders(param map[string]string) *PcloudPvminstancesGetallOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesNetworksDeleteOptions : The PcloudPvminstancesNetworksDelete options.
type PcloudPvminstancesNetworksDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Network ID.
	NetworkID *string `json:"network_id" validate:"required,ne="`

	// The mac address of the network interface to be removed.
	MacAddress *string `json:"macAddress,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesNetworksDeleteOptions : Instantiate PcloudPvminstancesNetworksDeleteOptions
func (*PowervsV1) NewPcloudPvminstancesNetworksDeleteOptions(cloudInstanceID string, pvmInstanceID string, networkID string) *PcloudPvminstancesNetworksDeleteOptions {
	return &PcloudPvminstancesNetworksDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		NetworkID: core.StringPtr(networkID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesNetworksDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesNetworksDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesNetworksDeleteOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesNetworksDeleteOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *PcloudPvminstancesNetworksDeleteOptions) SetNetworkID(networkID string) *PcloudPvminstancesNetworksDeleteOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetMacAddress : Allow user to set MacAddress
func (_options *PcloudPvminstancesNetworksDeleteOptions) SetMacAddress(macAddress string) *PcloudPvminstancesNetworksDeleteOptions {
	_options.MacAddress = core.StringPtr(macAddress)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesNetworksDeleteOptions) SetHeaders(param map[string]string) *PcloudPvminstancesNetworksDeleteOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesNetworksGetOptions : The PcloudPvminstancesNetworksGet options.
type PcloudPvminstancesNetworksGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Network ID.
	NetworkID *string `json:"network_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesNetworksGetOptions : Instantiate PcloudPvminstancesNetworksGetOptions
func (*PowervsV1) NewPcloudPvminstancesNetworksGetOptions(cloudInstanceID string, pvmInstanceID string, networkID string) *PcloudPvminstancesNetworksGetOptions {
	return &PcloudPvminstancesNetworksGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		NetworkID: core.StringPtr(networkID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesNetworksGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesNetworksGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesNetworksGetOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesNetworksGetOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *PcloudPvminstancesNetworksGetOptions) SetNetworkID(networkID string) *PcloudPvminstancesNetworksGetOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesNetworksGetOptions) SetHeaders(param map[string]string) *PcloudPvminstancesNetworksGetOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesNetworksGetallOptions : The PcloudPvminstancesNetworksGetall options.
type PcloudPvminstancesNetworksGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesNetworksGetallOptions : Instantiate PcloudPvminstancesNetworksGetallOptions
func (*PowervsV1) NewPcloudPvminstancesNetworksGetallOptions(cloudInstanceID string, pvmInstanceID string) *PcloudPvminstancesNetworksGetallOptions {
	return &PcloudPvminstancesNetworksGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesNetworksGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesNetworksGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesNetworksGetallOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesNetworksGetallOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesNetworksGetallOptions) SetHeaders(param map[string]string) *PcloudPvminstancesNetworksGetallOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesNetworksPostOptions : The PcloudPvminstancesNetworksPost options.
type PcloudPvminstancesNetworksPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// ID of the network.
	NetworkID *string `json:"networkID" validate:"required"`

	// The requested ip address of this network interface.
	IPAddress *string `json:"ipAddress,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesNetworksPostOptions : Instantiate PcloudPvminstancesNetworksPostOptions
func (*PowervsV1) NewPcloudPvminstancesNetworksPostOptions(cloudInstanceID string, pvmInstanceID string, networkID string) *PcloudPvminstancesNetworksPostOptions {
	return &PcloudPvminstancesNetworksPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		NetworkID: core.StringPtr(networkID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesNetworksPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesNetworksPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesNetworksPostOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesNetworksPostOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *PcloudPvminstancesNetworksPostOptions) SetNetworkID(networkID string) *PcloudPvminstancesNetworksPostOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetIPAddress : Allow user to set IPAddress
func (_options *PcloudPvminstancesNetworksPostOptions) SetIPAddress(ipAddress string) *PcloudPvminstancesNetworksPostOptions {
	_options.IPAddress = core.StringPtr(ipAddress)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesNetworksPostOptions) SetHeaders(param map[string]string) *PcloudPvminstancesNetworksPostOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesOperationsPostOptions : The PcloudPvminstancesOperationsPost options.
type PcloudPvminstancesOperationsPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	Operation *Operations `json:"operation" validate:"required"`

	// Name of the operation to execute; can be job or boot.
	OperationType *string `json:"operationType" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudPvminstancesOperationsPostOptions.OperationType property.
// Name of the operation to execute; can be job or boot.
const (
	PcloudPvminstancesOperationsPostOptionsOperationTypeBootConst = "boot"
	PcloudPvminstancesOperationsPostOptionsOperationTypeJobConst = "job"
)

// NewPcloudPvminstancesOperationsPostOptions : Instantiate PcloudPvminstancesOperationsPostOptions
func (*PowervsV1) NewPcloudPvminstancesOperationsPostOptions(cloudInstanceID string, pvmInstanceID string, operation *Operations, operationType string) *PcloudPvminstancesOperationsPostOptions {
	return &PcloudPvminstancesOperationsPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		Operation: operation,
		OperationType: core.StringPtr(operationType),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesOperationsPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesOperationsPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesOperationsPostOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesOperationsPostOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetOperation : Allow user to set Operation
func (_options *PcloudPvminstancesOperationsPostOptions) SetOperation(operation *Operations) *PcloudPvminstancesOperationsPostOptions {
	_options.Operation = operation
	return _options
}

// SetOperationType : Allow user to set OperationType
func (_options *PcloudPvminstancesOperationsPostOptions) SetOperationType(operationType string) *PcloudPvminstancesOperationsPostOptions {
	_options.OperationType = core.StringPtr(operationType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesOperationsPostOptions) SetHeaders(param map[string]string) *PcloudPvminstancesOperationsPostOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesPostOptions : The PcloudPvminstancesPost options.
type PcloudPvminstancesPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Image ID of the image to use for the server.
	ImageID *string `json:"imageID" validate:"required"`

	// Amount of memory allocated (in GB).
	Memory *float64 `json:"memory" validate:"required"`

	// Processor type (dedicated, shared, capped).
	ProcType *string `json:"procType" validate:"required"`

	// Number of processors allocated.
	Processors *float64 `json:"processors" validate:"required"`

	// Name of the server to create.
	ServerName *string `json:"serverName" validate:"required"`

	// The custom deployment type.
	DeploymentType *string `json:"deploymentType,omitempty"`

	// The name of the SSH key pair provided to the server for authenticating users (looked up in the tenant's list of
	// keys).
	KeyPairName *string `json:"keyPairName,omitempty"`

	// The VTL license repository capacity TB value.
	LicenseRepositoryCapacity *int64 `json:"licenseRepositoryCapacity,omitempty"`

	// (deprecated - replaced by pinPolicy) Indicates if the server is allowed to migrate between hosts.
	Migratable *bool `json:"migratable,omitempty"`

	// (deprecated - replaced by networks) List of Network IDs.
	NetworkIDs []string `json:"networkIDs,omitempty"`

	// The pvm instance networks information.
	Networks []PvmInstanceAddNetwork `json:"networks,omitempty"`

	// Specify PVM pin policy.
	PinPolicy *string `json:"pinPolicy,omitempty"`

	// The placement group for the server.
	PlacementGroup *string `json:"placementGroup,omitempty"`

	// Affinity policy for replicants being created; affinity for the same host, anti-affinity for different hosts, none
	// for no preference.
	ReplicantAffinityPolicy *string `json:"replicantAffinityPolicy,omitempty"`

	// How to name the created vms.
	ReplicantNamingScheme *string `json:"replicantNamingScheme,omitempty"`

	// Number of duplicate instances to create in this request.
	Replicants *float64 `json:"replicants,omitempty"`

	// The shared processor pool for server deployment.
	SharedProcessorPool *string `json:"sharedProcessorPool,omitempty"`

	SoftwareLicenses *SoftwareLicenses `json:"softwareLicenses,omitempty"`

	StorageAffinity *StorageAffinity `json:"storageAffinity,omitempty"`

	// The storage connection type.
	StorageConnection *string `json:"storageConnection,omitempty"`

	// The storage connection type.
	StorageConnectionV2 *string `json:"storageConnectionV2,omitempty"`

	// Storage Pool for server deployment; if provided then storageAffinity will be ignored; Only valid when you deploy one
	// of the IBM supplied stock images. Storage pool for a custom image (an imported image or an image that is created
	// from a PVMInstance capture) defaults to the storage pool the image was created in.
	StoragePool *string `json:"storagePool,omitempty"`

	// Storage type for server deployment; if storageType is not provided the storage type will default to 'tier3'.
	StorageType *string `json:"storageType,omitempty"`

	// System type used to host the instance.
	SysType *string `json:"sysType,omitempty"`

	// Cloud init user defined data.
	UserData *string `json:"userData,omitempty"`

	VirtualCores *VirtualCores `json:"virtualCores,omitempty"`

	// List of volume IDs.
	VolumeIDs []string `json:"volumeIDs,omitempty"`

	// Option to skip host validation on PVMInstance Create API.
	SkipHostValidation *bool `json:"skipHostValidation,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudPvminstancesPostOptions.ProcType property.
// Processor type (dedicated, shared, capped).
const (
	PcloudPvminstancesPostOptionsProcTypeCappedConst = "capped"
	PcloudPvminstancesPostOptionsProcTypeDedicatedConst = "dedicated"
	PcloudPvminstancesPostOptionsProcTypeSharedConst = "shared"
)

// Constants associated with the PcloudPvminstancesPostOptions.PinPolicy property.
// Specify PVM pin policy.
const (
	PcloudPvminstancesPostOptionsPinPolicyHardConst = "hard"
	PcloudPvminstancesPostOptionsPinPolicyNoneConst = "none"
	PcloudPvminstancesPostOptionsPinPolicySoftConst = "soft"
)

// Constants associated with the PcloudPvminstancesPostOptions.ReplicantAffinityPolicy property.
// Affinity policy for replicants being created; affinity for the same host, anti-affinity for different hosts, none for
// no preference.
const (
	PcloudPvminstancesPostOptionsReplicantAffinityPolicyAffinityConst = "affinity"
	PcloudPvminstancesPostOptionsReplicantAffinityPolicyAntiAffinityConst = "anti-affinity"
	PcloudPvminstancesPostOptionsReplicantAffinityPolicyNoneConst = "none"
)

// Constants associated with the PcloudPvminstancesPostOptions.ReplicantNamingScheme property.
// How to name the created vms.
const (
	PcloudPvminstancesPostOptionsReplicantNamingSchemePrefixConst = "prefix"
	PcloudPvminstancesPostOptionsReplicantNamingSchemeSuffixConst = "suffix"
)

// Constants associated with the PcloudPvminstancesPostOptions.StorageConnection property.
// The storage connection type.
const (
	PcloudPvminstancesPostOptionsStorageConnectionVscsiConst = "vSCSI"
)

// Constants associated with the PcloudPvminstancesPostOptions.StorageConnectionV2 property.
// The storage connection type.
const (
	PcloudPvminstancesPostOptionsStorageConnectionV2MaxvolumeattachementConst = "maxVolumeAttachement"
	PcloudPvminstancesPostOptionsStorageConnectionV2VscsiConst = "vSCSI"
)

// NewPcloudPvminstancesPostOptions : Instantiate PcloudPvminstancesPostOptions
func (*PowervsV1) NewPcloudPvminstancesPostOptions(cloudInstanceID string, imageID string, memory float64, procType string, processors float64, serverName string) *PcloudPvminstancesPostOptions {
	return &PcloudPvminstancesPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		ImageID: core.StringPtr(imageID),
		Memory: core.Float64Ptr(memory),
		ProcType: core.StringPtr(procType),
		Processors: core.Float64Ptr(processors),
		ServerName: core.StringPtr(serverName),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetImageID : Allow user to set ImageID
func (_options *PcloudPvminstancesPostOptions) SetImageID(imageID string) *PcloudPvminstancesPostOptions {
	_options.ImageID = core.StringPtr(imageID)
	return _options
}

// SetMemory : Allow user to set Memory
func (_options *PcloudPvminstancesPostOptions) SetMemory(memory float64) *PcloudPvminstancesPostOptions {
	_options.Memory = core.Float64Ptr(memory)
	return _options
}

// SetProcType : Allow user to set ProcType
func (_options *PcloudPvminstancesPostOptions) SetProcType(procType string) *PcloudPvminstancesPostOptions {
	_options.ProcType = core.StringPtr(procType)
	return _options
}

// SetProcessors : Allow user to set Processors
func (_options *PcloudPvminstancesPostOptions) SetProcessors(processors float64) *PcloudPvminstancesPostOptions {
	_options.Processors = core.Float64Ptr(processors)
	return _options
}

// SetServerName : Allow user to set ServerName
func (_options *PcloudPvminstancesPostOptions) SetServerName(serverName string) *PcloudPvminstancesPostOptions {
	_options.ServerName = core.StringPtr(serverName)
	return _options
}

// SetDeploymentType : Allow user to set DeploymentType
func (_options *PcloudPvminstancesPostOptions) SetDeploymentType(deploymentType string) *PcloudPvminstancesPostOptions {
	_options.DeploymentType = core.StringPtr(deploymentType)
	return _options
}

// SetKeyPairName : Allow user to set KeyPairName
func (_options *PcloudPvminstancesPostOptions) SetKeyPairName(keyPairName string) *PcloudPvminstancesPostOptions {
	_options.KeyPairName = core.StringPtr(keyPairName)
	return _options
}

// SetLicenseRepositoryCapacity : Allow user to set LicenseRepositoryCapacity
func (_options *PcloudPvminstancesPostOptions) SetLicenseRepositoryCapacity(licenseRepositoryCapacity int64) *PcloudPvminstancesPostOptions {
	_options.LicenseRepositoryCapacity = core.Int64Ptr(licenseRepositoryCapacity)
	return _options
}

// SetMigratable : Allow user to set Migratable
func (_options *PcloudPvminstancesPostOptions) SetMigratable(migratable bool) *PcloudPvminstancesPostOptions {
	_options.Migratable = core.BoolPtr(migratable)
	return _options
}

// SetNetworkIDs : Allow user to set NetworkIDs
func (_options *PcloudPvminstancesPostOptions) SetNetworkIDs(networkIDs []string) *PcloudPvminstancesPostOptions {
	_options.NetworkIDs = networkIDs
	return _options
}

// SetNetworks : Allow user to set Networks
func (_options *PcloudPvminstancesPostOptions) SetNetworks(networks []PvmInstanceAddNetwork) *PcloudPvminstancesPostOptions {
	_options.Networks = networks
	return _options
}

// SetPinPolicy : Allow user to set PinPolicy
func (_options *PcloudPvminstancesPostOptions) SetPinPolicy(pinPolicy string) *PcloudPvminstancesPostOptions {
	_options.PinPolicy = core.StringPtr(pinPolicy)
	return _options
}

// SetPlacementGroup : Allow user to set PlacementGroup
func (_options *PcloudPvminstancesPostOptions) SetPlacementGroup(placementGroup string) *PcloudPvminstancesPostOptions {
	_options.PlacementGroup = core.StringPtr(placementGroup)
	return _options
}

// SetReplicantAffinityPolicy : Allow user to set ReplicantAffinityPolicy
func (_options *PcloudPvminstancesPostOptions) SetReplicantAffinityPolicy(replicantAffinityPolicy string) *PcloudPvminstancesPostOptions {
	_options.ReplicantAffinityPolicy = core.StringPtr(replicantAffinityPolicy)
	return _options
}

// SetReplicantNamingScheme : Allow user to set ReplicantNamingScheme
func (_options *PcloudPvminstancesPostOptions) SetReplicantNamingScheme(replicantNamingScheme string) *PcloudPvminstancesPostOptions {
	_options.ReplicantNamingScheme = core.StringPtr(replicantNamingScheme)
	return _options
}

// SetReplicants : Allow user to set Replicants
func (_options *PcloudPvminstancesPostOptions) SetReplicants(replicants float64) *PcloudPvminstancesPostOptions {
	_options.Replicants = core.Float64Ptr(replicants)
	return _options
}

// SetSharedProcessorPool : Allow user to set SharedProcessorPool
func (_options *PcloudPvminstancesPostOptions) SetSharedProcessorPool(sharedProcessorPool string) *PcloudPvminstancesPostOptions {
	_options.SharedProcessorPool = core.StringPtr(sharedProcessorPool)
	return _options
}

// SetSoftwareLicenses : Allow user to set SoftwareLicenses
func (_options *PcloudPvminstancesPostOptions) SetSoftwareLicenses(softwareLicenses *SoftwareLicenses) *PcloudPvminstancesPostOptions {
	_options.SoftwareLicenses = softwareLicenses
	return _options
}

// SetStorageAffinity : Allow user to set StorageAffinity
func (_options *PcloudPvminstancesPostOptions) SetStorageAffinity(storageAffinity *StorageAffinity) *PcloudPvminstancesPostOptions {
	_options.StorageAffinity = storageAffinity
	return _options
}

// SetStorageConnection : Allow user to set StorageConnection
func (_options *PcloudPvminstancesPostOptions) SetStorageConnection(storageConnection string) *PcloudPvminstancesPostOptions {
	_options.StorageConnection = core.StringPtr(storageConnection)
	return _options
}

// SetStorageConnectionV2 : Allow user to set StorageConnectionV2
func (_options *PcloudPvminstancesPostOptions) SetStorageConnectionV2(storageConnectionV2 string) *PcloudPvminstancesPostOptions {
	_options.StorageConnectionV2 = core.StringPtr(storageConnectionV2)
	return _options
}

// SetStoragePool : Allow user to set StoragePool
func (_options *PcloudPvminstancesPostOptions) SetStoragePool(storagePool string) *PcloudPvminstancesPostOptions {
	_options.StoragePool = core.StringPtr(storagePool)
	return _options
}

// SetStorageType : Allow user to set StorageType
func (_options *PcloudPvminstancesPostOptions) SetStorageType(storageType string) *PcloudPvminstancesPostOptions {
	_options.StorageType = core.StringPtr(storageType)
	return _options
}

// SetSysType : Allow user to set SysType
func (_options *PcloudPvminstancesPostOptions) SetSysType(sysType string) *PcloudPvminstancesPostOptions {
	_options.SysType = core.StringPtr(sysType)
	return _options
}

// SetUserData : Allow user to set UserData
func (_options *PcloudPvminstancesPostOptions) SetUserData(userData string) *PcloudPvminstancesPostOptions {
	_options.UserData = core.StringPtr(userData)
	return _options
}

// SetVirtualCores : Allow user to set VirtualCores
func (_options *PcloudPvminstancesPostOptions) SetVirtualCores(virtualCores *VirtualCores) *PcloudPvminstancesPostOptions {
	_options.VirtualCores = virtualCores
	return _options
}

// SetVolumeIDs : Allow user to set VolumeIDs
func (_options *PcloudPvminstancesPostOptions) SetVolumeIDs(volumeIDs []string) *PcloudPvminstancesPostOptions {
	_options.VolumeIDs = volumeIDs
	return _options
}

// SetSkipHostValidation : Allow user to set SkipHostValidation
func (_options *PcloudPvminstancesPostOptions) SetSkipHostValidation(skipHostValidation bool) *PcloudPvminstancesPostOptions {
	_options.SkipHostValidation = core.BoolPtr(skipHostValidation)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesPostOptions) SetHeaders(param map[string]string) *PcloudPvminstancesPostOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesPutOptions : The PcloudPvminstancesPut options.
type PcloudPvminstancesPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	CloudInitialization *CloudInitialization `json:"cloudInitialization,omitempty"`

	// The VTL license repository capacity TB value.
	LicenseRepositoryCapacity *int64 `json:"licenseRepositoryCapacity,omitempty"`

	// Amount of memory allocated (in GB).
	Memory *float64 `json:"memory,omitempty"`

	// (deprecated - replaced by pinPolicy) Indicates if the server is allowed to migrate between hosts.
	Migratable *bool `json:"migratable,omitempty"`

	// Specify PVM pin policy.
	PinPolicy *string `json:"pinPolicy,omitempty"`

	// Processor type (dedicated, shared, capped).
	ProcType *string `json:"procType,omitempty"`

	// Number of processors allocated.
	Processors *float64 `json:"processors,omitempty"`

	// If an SAP pvm-instance, the SAP profile ID to switch to (only while shutdown).
	SapProfileID *string `json:"sapProfileID,omitempty"`

	// Name of the server to create.
	ServerName *string `json:"serverName,omitempty"`

	SoftwareLicenses *SoftwareLicenses `json:"softwareLicenses,omitempty"`

	// Indicates if all volumes attached to the server must reside in the same storage pool; If set to false then volumes
	// from any storage type and pool can be attached to the PVMInstance; Impacts PVMInstance snapshot, capture, and clone,
	// for capture and clone - only data volumes that are of the same storage type and in the same storage pool of the
	// PVMInstance's boot volume can be included; for snapshot - all data volumes to be included in the snapshot must
	// reside in the same storage type and pool. Once set to false, cannot be set back to true unless all volumes attached
	// reside in the same storage type and pool.
	StoragePoolAffinity *bool `json:"storagePoolAffinity,omitempty"`

	VirtualCores *VirtualCores `json:"virtualCores,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudPvminstancesPutOptions.PinPolicy property.
// Specify PVM pin policy.
const (
	PcloudPvminstancesPutOptionsPinPolicyHardConst = "hard"
	PcloudPvminstancesPutOptionsPinPolicyNoneConst = "none"
	PcloudPvminstancesPutOptionsPinPolicySoftConst = "soft"
)

// Constants associated with the PcloudPvminstancesPutOptions.ProcType property.
// Processor type (dedicated, shared, capped).
const (
	PcloudPvminstancesPutOptionsProcTypeCappedConst = "capped"
	PcloudPvminstancesPutOptionsProcTypeDedicatedConst = "dedicated"
	PcloudPvminstancesPutOptionsProcTypeSharedConst = "shared"
)

// NewPcloudPvminstancesPutOptions : Instantiate PcloudPvminstancesPutOptions
func (*PowervsV1) NewPcloudPvminstancesPutOptions(cloudInstanceID string, pvmInstanceID string) *PcloudPvminstancesPutOptions {
	return &PcloudPvminstancesPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesPutOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesPutOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetCloudInitialization : Allow user to set CloudInitialization
func (_options *PcloudPvminstancesPutOptions) SetCloudInitialization(cloudInitialization *CloudInitialization) *PcloudPvminstancesPutOptions {
	_options.CloudInitialization = cloudInitialization
	return _options
}

// SetLicenseRepositoryCapacity : Allow user to set LicenseRepositoryCapacity
func (_options *PcloudPvminstancesPutOptions) SetLicenseRepositoryCapacity(licenseRepositoryCapacity int64) *PcloudPvminstancesPutOptions {
	_options.LicenseRepositoryCapacity = core.Int64Ptr(licenseRepositoryCapacity)
	return _options
}

// SetMemory : Allow user to set Memory
func (_options *PcloudPvminstancesPutOptions) SetMemory(memory float64) *PcloudPvminstancesPutOptions {
	_options.Memory = core.Float64Ptr(memory)
	return _options
}

// SetMigratable : Allow user to set Migratable
func (_options *PcloudPvminstancesPutOptions) SetMigratable(migratable bool) *PcloudPvminstancesPutOptions {
	_options.Migratable = core.BoolPtr(migratable)
	return _options
}

// SetPinPolicy : Allow user to set PinPolicy
func (_options *PcloudPvminstancesPutOptions) SetPinPolicy(pinPolicy string) *PcloudPvminstancesPutOptions {
	_options.PinPolicy = core.StringPtr(pinPolicy)
	return _options
}

// SetProcType : Allow user to set ProcType
func (_options *PcloudPvminstancesPutOptions) SetProcType(procType string) *PcloudPvminstancesPutOptions {
	_options.ProcType = core.StringPtr(procType)
	return _options
}

// SetProcessors : Allow user to set Processors
func (_options *PcloudPvminstancesPutOptions) SetProcessors(processors float64) *PcloudPvminstancesPutOptions {
	_options.Processors = core.Float64Ptr(processors)
	return _options
}

// SetSapProfileID : Allow user to set SapProfileID
func (_options *PcloudPvminstancesPutOptions) SetSapProfileID(sapProfileID string) *PcloudPvminstancesPutOptions {
	_options.SapProfileID = core.StringPtr(sapProfileID)
	return _options
}

// SetServerName : Allow user to set ServerName
func (_options *PcloudPvminstancesPutOptions) SetServerName(serverName string) *PcloudPvminstancesPutOptions {
	_options.ServerName = core.StringPtr(serverName)
	return _options
}

// SetSoftwareLicenses : Allow user to set SoftwareLicenses
func (_options *PcloudPvminstancesPutOptions) SetSoftwareLicenses(softwareLicenses *SoftwareLicenses) *PcloudPvminstancesPutOptions {
	_options.SoftwareLicenses = softwareLicenses
	return _options
}

// SetStoragePoolAffinity : Allow user to set StoragePoolAffinity
func (_options *PcloudPvminstancesPutOptions) SetStoragePoolAffinity(storagePoolAffinity bool) *PcloudPvminstancesPutOptions {
	_options.StoragePoolAffinity = core.BoolPtr(storagePoolAffinity)
	return _options
}

// SetVirtualCores : Allow user to set VirtualCores
func (_options *PcloudPvminstancesPutOptions) SetVirtualCores(virtualCores *VirtualCores) *PcloudPvminstancesPutOptions {
	_options.VirtualCores = virtualCores
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesPutOptions) SetHeaders(param map[string]string) *PcloudPvminstancesPutOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesSnapshotsGetallOptions : The PcloudPvminstancesSnapshotsGetall options.
type PcloudPvminstancesSnapshotsGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesSnapshotsGetallOptions : Instantiate PcloudPvminstancesSnapshotsGetallOptions
func (*PowervsV1) NewPcloudPvminstancesSnapshotsGetallOptions(cloudInstanceID string, pvmInstanceID string) *PcloudPvminstancesSnapshotsGetallOptions {
	return &PcloudPvminstancesSnapshotsGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesSnapshotsGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesSnapshotsGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesSnapshotsGetallOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesSnapshotsGetallOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesSnapshotsGetallOptions) SetHeaders(param map[string]string) *PcloudPvminstancesSnapshotsGetallOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesSnapshotsPostOptions : The PcloudPvminstancesSnapshotsPost options.
type PcloudPvminstancesSnapshotsPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Name of the PVM instance snapshot to create.
	Name *string `json:"name" validate:"required"`

	// Description of the PVM instance snapshot.
	Description *string `json:"description,omitempty"`

	// List of volumes to include in the PVM instance snapshot.
	VolumeIDs []string `json:"volumeIDs,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesSnapshotsPostOptions : Instantiate PcloudPvminstancesSnapshotsPostOptions
func (*PowervsV1) NewPcloudPvminstancesSnapshotsPostOptions(cloudInstanceID string, pvmInstanceID string, name string) *PcloudPvminstancesSnapshotsPostOptions {
	return &PcloudPvminstancesSnapshotsPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		Name: core.StringPtr(name),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesSnapshotsPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesSnapshotsPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesSnapshotsPostOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesSnapshotsPostOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudPvminstancesSnapshotsPostOptions) SetName(name string) *PcloudPvminstancesSnapshotsPostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetDescription : Allow user to set Description
func (_options *PcloudPvminstancesSnapshotsPostOptions) SetDescription(description string) *PcloudPvminstancesSnapshotsPostOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetVolumeIDs : Allow user to set VolumeIDs
func (_options *PcloudPvminstancesSnapshotsPostOptions) SetVolumeIDs(volumeIDs []string) *PcloudPvminstancesSnapshotsPostOptions {
	_options.VolumeIDs = volumeIDs
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesSnapshotsPostOptions) SetHeaders(param map[string]string) *PcloudPvminstancesSnapshotsPostOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesSnapshotsRestorePostOptions : The PcloudPvminstancesSnapshotsRestorePost options.
type PcloudPvminstancesSnapshotsRestorePostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// PVM Instance snapshot id.
	SnapshotID *string `json:"snapshot_id" validate:"required,ne="`

	// By default the VM must be shutoff during a snapshot restore, force set to true will relax the VM shutoff
	// pre-condition.
	Force *bool `json:"force,omitempty"`

	// Action to take on a failed snapshot restore.
	RestoreFailAction *string `json:"restore_fail_action,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudPvminstancesSnapshotsRestorePostOptions.RestoreFailAction property.
// Action to take on a failed snapshot restore.
const (
	PcloudPvminstancesSnapshotsRestorePostOptionsRestoreFailActionRetryConst = "retry"
	PcloudPvminstancesSnapshotsRestorePostOptionsRestoreFailActionRollbackConst = "rollback"
)

// NewPcloudPvminstancesSnapshotsRestorePostOptions : Instantiate PcloudPvminstancesSnapshotsRestorePostOptions
func (*PowervsV1) NewPcloudPvminstancesSnapshotsRestorePostOptions(cloudInstanceID string, pvmInstanceID string, snapshotID string) *PcloudPvminstancesSnapshotsRestorePostOptions {
	return &PcloudPvminstancesSnapshotsRestorePostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		SnapshotID: core.StringPtr(snapshotID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesSnapshotsRestorePostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesSnapshotsRestorePostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesSnapshotsRestorePostOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesSnapshotsRestorePostOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetSnapshotID : Allow user to set SnapshotID
func (_options *PcloudPvminstancesSnapshotsRestorePostOptions) SetSnapshotID(snapshotID string) *PcloudPvminstancesSnapshotsRestorePostOptions {
	_options.SnapshotID = core.StringPtr(snapshotID)
	return _options
}

// SetForce : Allow user to set Force
func (_options *PcloudPvminstancesSnapshotsRestorePostOptions) SetForce(force bool) *PcloudPvminstancesSnapshotsRestorePostOptions {
	_options.Force = core.BoolPtr(force)
	return _options
}

// SetRestoreFailAction : Allow user to set RestoreFailAction
func (_options *PcloudPvminstancesSnapshotsRestorePostOptions) SetRestoreFailAction(restoreFailAction string) *PcloudPvminstancesSnapshotsRestorePostOptions {
	_options.RestoreFailAction = core.StringPtr(restoreFailAction)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesSnapshotsRestorePostOptions) SetHeaders(param map[string]string) *PcloudPvminstancesSnapshotsRestorePostOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesVolumesDeleteOptions : The PcloudPvminstancesVolumesDelete options.
type PcloudPvminstancesVolumesDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Volume ID.
	VolumeID *string `json:"volume_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesVolumesDeleteOptions : Instantiate PcloudPvminstancesVolumesDeleteOptions
func (*PowervsV1) NewPcloudPvminstancesVolumesDeleteOptions(cloudInstanceID string, pvmInstanceID string, volumeID string) *PcloudPvminstancesVolumesDeleteOptions {
	return &PcloudPvminstancesVolumesDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		VolumeID: core.StringPtr(volumeID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesVolumesDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesVolumesDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesVolumesDeleteOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesVolumesDeleteOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetVolumeID : Allow user to set VolumeID
func (_options *PcloudPvminstancesVolumesDeleteOptions) SetVolumeID(volumeID string) *PcloudPvminstancesVolumesDeleteOptions {
	_options.VolumeID = core.StringPtr(volumeID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesVolumesDeleteOptions) SetHeaders(param map[string]string) *PcloudPvminstancesVolumesDeleteOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesVolumesGetOptions : The PcloudPvminstancesVolumesGet options.
type PcloudPvminstancesVolumesGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Volume ID.
	VolumeID *string `json:"volume_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesVolumesGetOptions : Instantiate PcloudPvminstancesVolumesGetOptions
func (*PowervsV1) NewPcloudPvminstancesVolumesGetOptions(cloudInstanceID string, pvmInstanceID string, volumeID string) *PcloudPvminstancesVolumesGetOptions {
	return &PcloudPvminstancesVolumesGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		VolumeID: core.StringPtr(volumeID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesVolumesGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesVolumesGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesVolumesGetOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesVolumesGetOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetVolumeID : Allow user to set VolumeID
func (_options *PcloudPvminstancesVolumesGetOptions) SetVolumeID(volumeID string) *PcloudPvminstancesVolumesGetOptions {
	_options.VolumeID = core.StringPtr(volumeID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesVolumesGetOptions) SetHeaders(param map[string]string) *PcloudPvminstancesVolumesGetOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesVolumesGetallOptions : The PcloudPvminstancesVolumesGetall options.
type PcloudPvminstancesVolumesGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesVolumesGetallOptions : Instantiate PcloudPvminstancesVolumesGetallOptions
func (*PowervsV1) NewPcloudPvminstancesVolumesGetallOptions(cloudInstanceID string, pvmInstanceID string) *PcloudPvminstancesVolumesGetallOptions {
	return &PcloudPvminstancesVolumesGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesVolumesGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesVolumesGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesVolumesGetallOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesVolumesGetallOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesVolumesGetallOptions) SetHeaders(param map[string]string) *PcloudPvminstancesVolumesGetallOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesVolumesPostOptions : The PcloudPvminstancesVolumesPost options.
type PcloudPvminstancesVolumesPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Volume ID.
	VolumeID *string `json:"volume_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesVolumesPostOptions : Instantiate PcloudPvminstancesVolumesPostOptions
func (*PowervsV1) NewPcloudPvminstancesVolumesPostOptions(cloudInstanceID string, pvmInstanceID string, volumeID string) *PcloudPvminstancesVolumesPostOptions {
	return &PcloudPvminstancesVolumesPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		VolumeID: core.StringPtr(volumeID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesVolumesPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesVolumesPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesVolumesPostOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesVolumesPostOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetVolumeID : Allow user to set VolumeID
func (_options *PcloudPvminstancesVolumesPostOptions) SetVolumeID(volumeID string) *PcloudPvminstancesVolumesPostOptions {
	_options.VolumeID = core.StringPtr(volumeID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesVolumesPostOptions) SetHeaders(param map[string]string) *PcloudPvminstancesVolumesPostOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesVolumesPutOptions : The PcloudPvminstancesVolumesPut options.
type PcloudPvminstancesVolumesPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Volume ID.
	VolumeID *string `json:"volume_id" validate:"required,ne="`

	// Indicates if the volume should be deleted when the PVMInstance is terminated.
	DeleteOnTermination *bool `json:"deleteOnTermination" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesVolumesPutOptions : Instantiate PcloudPvminstancesVolumesPutOptions
func (*PowervsV1) NewPcloudPvminstancesVolumesPutOptions(cloudInstanceID string, pvmInstanceID string, volumeID string, deleteOnTermination bool) *PcloudPvminstancesVolumesPutOptions {
	return &PcloudPvminstancesVolumesPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		VolumeID: core.StringPtr(volumeID),
		DeleteOnTermination: core.BoolPtr(deleteOnTermination),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesVolumesPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesVolumesPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesVolumesPutOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesVolumesPutOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetVolumeID : Allow user to set VolumeID
func (_options *PcloudPvminstancesVolumesPutOptions) SetVolumeID(volumeID string) *PcloudPvminstancesVolumesPutOptions {
	_options.VolumeID = core.StringPtr(volumeID)
	return _options
}

// SetDeleteOnTermination : Allow user to set DeleteOnTermination
func (_options *PcloudPvminstancesVolumesPutOptions) SetDeleteOnTermination(deleteOnTermination bool) *PcloudPvminstancesVolumesPutOptions {
	_options.DeleteOnTermination = core.BoolPtr(deleteOnTermination)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesVolumesPutOptions) SetHeaders(param map[string]string) *PcloudPvminstancesVolumesPutOptions {
	options.Headers = param
	return options
}

// PcloudPvminstancesVolumesSetbootPutOptions : The PcloudPvminstancesVolumesSetbootPut options.
type PcloudPvminstancesVolumesSetbootPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Volume ID.
	VolumeID *string `json:"volume_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudPvminstancesVolumesSetbootPutOptions : Instantiate PcloudPvminstancesVolumesSetbootPutOptions
func (*PowervsV1) NewPcloudPvminstancesVolumesSetbootPutOptions(cloudInstanceID string, pvmInstanceID string, volumeID string) *PcloudPvminstancesVolumesSetbootPutOptions {
	return &PcloudPvminstancesVolumesSetbootPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		VolumeID: core.StringPtr(volumeID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudPvminstancesVolumesSetbootPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudPvminstancesVolumesSetbootPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudPvminstancesVolumesSetbootPutOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudPvminstancesVolumesSetbootPutOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetVolumeID : Allow user to set VolumeID
func (_options *PcloudPvminstancesVolumesSetbootPutOptions) SetVolumeID(volumeID string) *PcloudPvminstancesVolumesSetbootPutOptions {
	_options.VolumeID = core.StringPtr(volumeID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudPvminstancesVolumesSetbootPutOptions) SetHeaders(param map[string]string) *PcloudPvminstancesVolumesSetbootPutOptions {
	options.Headers = param
	return options
}

// PcloudSapGetOptions : The PcloudSapGet options.
type PcloudSapGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// SAP Profile ID.
	SapProfileID *string `json:"sap_profile_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudSapGetOptions : Instantiate PcloudSapGetOptions
func (*PowervsV1) NewPcloudSapGetOptions(cloudInstanceID string, sapProfileID string) *PcloudSapGetOptions {
	return &PcloudSapGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		SapProfileID: core.StringPtr(sapProfileID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudSapGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudSapGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetSapProfileID : Allow user to set SapProfileID
func (_options *PcloudSapGetOptions) SetSapProfileID(sapProfileID string) *PcloudSapGetOptions {
	_options.SapProfileID = core.StringPtr(sapProfileID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudSapGetOptions) SetHeaders(param map[string]string) *PcloudSapGetOptions {
	options.Headers = param
	return options
}

// PcloudSapGetallOptions : The PcloudSapGetall options.
type PcloudSapGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudSapGetallOptions : Instantiate PcloudSapGetallOptions
func (*PowervsV1) NewPcloudSapGetallOptions(cloudInstanceID string) *PcloudSapGetallOptions {
	return &PcloudSapGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudSapGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudSapGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudSapGetallOptions) SetHeaders(param map[string]string) *PcloudSapGetallOptions {
	options.Headers = param
	return options
}

// PcloudSapPostOptions : The PcloudSapPost options.
type PcloudSapPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Image ID of the sap image to use for the server.
	ImageID *string `json:"imageID" validate:"required"`

	// Name of the sap pvm-instance.
	Name *string `json:"name" validate:"required"`

	// The pvm instance networks information.
	Networks []PvmInstanceAddNetwork `json:"networks" validate:"required"`

	// SAP Profile ID for the amount of cores and memory.
	ProfileID *string `json:"profileID" validate:"required"`

	// Custom SAP Deployment Type Information (For Internal Use Only).
	DeploymentType *string `json:"deploymentType,omitempty"`

	Instances *PvmInstanceMultiCreate `json:"instances,omitempty"`

	// Specify PVM pin policy.
	PinPolicy *string `json:"pinPolicy,omitempty"`

	// The placement group for the server.
	PlacementGroup *string `json:"placementGroup,omitempty"`

	// The name of the SSH Key to provide to the server for authenticating.
	SshKeyName *string `json:"sshKeyName,omitempty"`

	StorageAffinity *StorageAffinity `json:"storageAffinity,omitempty"`

	// Storage Pool for server deployment; if provided then storageAffinity and storageType will be ignored; Only valid
	// when you deploy one of the IBM supplied stock images. Storage pool for a custom image (an imported image or an image
	// that is created from a PVMInstance capture) defaults to the storage pool the image was created in.
	StoragePool *string `json:"storagePool,omitempty"`

	// Storage type for server deployment; if storageType is not provided the storage type will default to 'tier3'.
	StorageType *string `json:"storageType,omitempty"`

	// System type used to host the instance. Only e880, e980, e1080 are supported.
	SysType *string `json:"sysType,omitempty"`

	// Cloud init user defined data.
	UserData *string `json:"userData,omitempty"`

	// List of Volume IDs to attach to the pvm-instance on creation.
	VolumeIDs []string `json:"volumeIDs,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudSapPostOptions.PinPolicy property.
// Specify PVM pin policy.
const (
	PcloudSapPostOptionsPinPolicyHardConst = "hard"
	PcloudSapPostOptionsPinPolicyNoneConst = "none"
	PcloudSapPostOptionsPinPolicySoftConst = "soft"
)

// NewPcloudSapPostOptions : Instantiate PcloudSapPostOptions
func (*PowervsV1) NewPcloudSapPostOptions(cloudInstanceID string, imageID string, name string, networks []PvmInstanceAddNetwork, profileID string) *PcloudSapPostOptions {
	return &PcloudSapPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		ImageID: core.StringPtr(imageID),
		Name: core.StringPtr(name),
		Networks: networks,
		ProfileID: core.StringPtr(profileID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudSapPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudSapPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetImageID : Allow user to set ImageID
func (_options *PcloudSapPostOptions) SetImageID(imageID string) *PcloudSapPostOptions {
	_options.ImageID = core.StringPtr(imageID)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudSapPostOptions) SetName(name string) *PcloudSapPostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetNetworks : Allow user to set Networks
func (_options *PcloudSapPostOptions) SetNetworks(networks []PvmInstanceAddNetwork) *PcloudSapPostOptions {
	_options.Networks = networks
	return _options
}

// SetProfileID : Allow user to set ProfileID
func (_options *PcloudSapPostOptions) SetProfileID(profileID string) *PcloudSapPostOptions {
	_options.ProfileID = core.StringPtr(profileID)
	return _options
}

// SetDeploymentType : Allow user to set DeploymentType
func (_options *PcloudSapPostOptions) SetDeploymentType(deploymentType string) *PcloudSapPostOptions {
	_options.DeploymentType = core.StringPtr(deploymentType)
	return _options
}

// SetInstances : Allow user to set Instances
func (_options *PcloudSapPostOptions) SetInstances(instances *PvmInstanceMultiCreate) *PcloudSapPostOptions {
	_options.Instances = instances
	return _options
}

// SetPinPolicy : Allow user to set PinPolicy
func (_options *PcloudSapPostOptions) SetPinPolicy(pinPolicy string) *PcloudSapPostOptions {
	_options.PinPolicy = core.StringPtr(pinPolicy)
	return _options
}

// SetPlacementGroup : Allow user to set PlacementGroup
func (_options *PcloudSapPostOptions) SetPlacementGroup(placementGroup string) *PcloudSapPostOptions {
	_options.PlacementGroup = core.StringPtr(placementGroup)
	return _options
}

// SetSshKeyName : Allow user to set SshKeyName
func (_options *PcloudSapPostOptions) SetSshKeyName(sshKeyName string) *PcloudSapPostOptions {
	_options.SshKeyName = core.StringPtr(sshKeyName)
	return _options
}

// SetStorageAffinity : Allow user to set StorageAffinity
func (_options *PcloudSapPostOptions) SetStorageAffinity(storageAffinity *StorageAffinity) *PcloudSapPostOptions {
	_options.StorageAffinity = storageAffinity
	return _options
}

// SetStoragePool : Allow user to set StoragePool
func (_options *PcloudSapPostOptions) SetStoragePool(storagePool string) *PcloudSapPostOptions {
	_options.StoragePool = core.StringPtr(storagePool)
	return _options
}

// SetStorageType : Allow user to set StorageType
func (_options *PcloudSapPostOptions) SetStorageType(storageType string) *PcloudSapPostOptions {
	_options.StorageType = core.StringPtr(storageType)
	return _options
}

// SetSysType : Allow user to set SysType
func (_options *PcloudSapPostOptions) SetSysType(sysType string) *PcloudSapPostOptions {
	_options.SysType = core.StringPtr(sysType)
	return _options
}

// SetUserData : Allow user to set UserData
func (_options *PcloudSapPostOptions) SetUserData(userData string) *PcloudSapPostOptions {
	_options.UserData = core.StringPtr(userData)
	return _options
}

// SetVolumeIDs : Allow user to set VolumeIDs
func (_options *PcloudSapPostOptions) SetVolumeIDs(volumeIDs []string) *PcloudSapPostOptions {
	_options.VolumeIDs = volumeIDs
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudSapPostOptions) SetHeaders(param map[string]string) *PcloudSapPostOptions {
	options.Headers = param
	return options
}

// PcloudSharedprocessorpoolsDeleteOptions : The PcloudSharedprocessorpoolsDelete options.
type PcloudSharedprocessorpoolsDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Shared Processor Pool ID or Name.
	SharedProcessorPoolID *string `json:"shared_processor_pool_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudSharedprocessorpoolsDeleteOptions : Instantiate PcloudSharedprocessorpoolsDeleteOptions
func (*PowervsV1) NewPcloudSharedprocessorpoolsDeleteOptions(cloudInstanceID string, sharedProcessorPoolID string) *PcloudSharedprocessorpoolsDeleteOptions {
	return &PcloudSharedprocessorpoolsDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		SharedProcessorPoolID: core.StringPtr(sharedProcessorPoolID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudSharedprocessorpoolsDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudSharedprocessorpoolsDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetSharedProcessorPoolID : Allow user to set SharedProcessorPoolID
func (_options *PcloudSharedprocessorpoolsDeleteOptions) SetSharedProcessorPoolID(sharedProcessorPoolID string) *PcloudSharedprocessorpoolsDeleteOptions {
	_options.SharedProcessorPoolID = core.StringPtr(sharedProcessorPoolID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudSharedprocessorpoolsDeleteOptions) SetHeaders(param map[string]string) *PcloudSharedprocessorpoolsDeleteOptions {
	options.Headers = param
	return options
}

// PcloudSharedprocessorpoolsGetOptions : The PcloudSharedprocessorpoolsGet options.
type PcloudSharedprocessorpoolsGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Shared Processor Pool ID or Name.
	SharedProcessorPoolID *string `json:"shared_processor_pool_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudSharedprocessorpoolsGetOptions : Instantiate PcloudSharedprocessorpoolsGetOptions
func (*PowervsV1) NewPcloudSharedprocessorpoolsGetOptions(cloudInstanceID string, sharedProcessorPoolID string) *PcloudSharedprocessorpoolsGetOptions {
	return &PcloudSharedprocessorpoolsGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		SharedProcessorPoolID: core.StringPtr(sharedProcessorPoolID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudSharedprocessorpoolsGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudSharedprocessorpoolsGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetSharedProcessorPoolID : Allow user to set SharedProcessorPoolID
func (_options *PcloudSharedprocessorpoolsGetOptions) SetSharedProcessorPoolID(sharedProcessorPoolID string) *PcloudSharedprocessorpoolsGetOptions {
	_options.SharedProcessorPoolID = core.StringPtr(sharedProcessorPoolID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudSharedprocessorpoolsGetOptions) SetHeaders(param map[string]string) *PcloudSharedprocessorpoolsGetOptions {
	options.Headers = param
	return options
}

// PcloudSharedprocessorpoolsGetallOptions : The PcloudSharedprocessorpoolsGetall options.
type PcloudSharedprocessorpoolsGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudSharedprocessorpoolsGetallOptions : Instantiate PcloudSharedprocessorpoolsGetallOptions
func (*PowervsV1) NewPcloudSharedprocessorpoolsGetallOptions(cloudInstanceID string) *PcloudSharedprocessorpoolsGetallOptions {
	return &PcloudSharedprocessorpoolsGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudSharedprocessorpoolsGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudSharedprocessorpoolsGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudSharedprocessorpoolsGetallOptions) SetHeaders(param map[string]string) *PcloudSharedprocessorpoolsGetallOptions {
	options.Headers = param
	return options
}

// PcloudSharedprocessorpoolsPostOptions : The PcloudSharedprocessorpoolsPost options.
type PcloudSharedprocessorpoolsPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// The host group; a host from the group will be automatically selected based on available resources.
	HostGroup *string `json:"hostGroup" validate:"required"`

	// The name of the Shared Processor Pool; minumum of 2 characters, maximum of 12, the only special character allowed is
	// the underscore '_'.
	Name *string `json:"name" validate:"required"`

	// The amount of reserved processor cores for the Shared Processor Pool; only integers allowed, no fractional values.
	ReservedCores *int64 `json:"reservedCores" validate:"required"`

	// The ID of the placement group.
	PlacementGroupID *string `json:"placementGroupID,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudSharedprocessorpoolsPostOptions : Instantiate PcloudSharedprocessorpoolsPostOptions
func (*PowervsV1) NewPcloudSharedprocessorpoolsPostOptions(cloudInstanceID string, hostGroup string, name string, reservedCores int64) *PcloudSharedprocessorpoolsPostOptions {
	return &PcloudSharedprocessorpoolsPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		HostGroup: core.StringPtr(hostGroup),
		Name: core.StringPtr(name),
		ReservedCores: core.Int64Ptr(reservedCores),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudSharedprocessorpoolsPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudSharedprocessorpoolsPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHostGroup : Allow user to set HostGroup
func (_options *PcloudSharedprocessorpoolsPostOptions) SetHostGroup(hostGroup string) *PcloudSharedprocessorpoolsPostOptions {
	_options.HostGroup = core.StringPtr(hostGroup)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudSharedprocessorpoolsPostOptions) SetName(name string) *PcloudSharedprocessorpoolsPostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetReservedCores : Allow user to set ReservedCores
func (_options *PcloudSharedprocessorpoolsPostOptions) SetReservedCores(reservedCores int64) *PcloudSharedprocessorpoolsPostOptions {
	_options.ReservedCores = core.Int64Ptr(reservedCores)
	return _options
}

// SetPlacementGroupID : Allow user to set PlacementGroupID
func (_options *PcloudSharedprocessorpoolsPostOptions) SetPlacementGroupID(placementGroupID string) *PcloudSharedprocessorpoolsPostOptions {
	_options.PlacementGroupID = core.StringPtr(placementGroupID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudSharedprocessorpoolsPostOptions) SetHeaders(param map[string]string) *PcloudSharedprocessorpoolsPostOptions {
	options.Headers = param
	return options
}

// PcloudSharedprocessorpoolsPutOptions : The PcloudSharedprocessorpoolsPut options.
type PcloudSharedprocessorpoolsPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Shared Processor Pool ID or Name.
	SharedProcessorPoolID *string `json:"shared_processor_pool_id" validate:"required,ne="`

	// The new name for the Shared Processor Pool; minumum of 2 characters, maximum of 12, the only special character
	// allowed is the underscore '_'.
	Name *string `json:"name,omitempty"`

	// The amount of reserved processor cores for the Shared Processor Pool; only integers allowed, no fractional values;
	// the amount can be increased (dependent on available resources) or decreased (dependent on currently allocated
	// resources).
	ReservedCores *int64 `json:"reservedCores,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudSharedprocessorpoolsPutOptions : Instantiate PcloudSharedprocessorpoolsPutOptions
func (*PowervsV1) NewPcloudSharedprocessorpoolsPutOptions(cloudInstanceID string, sharedProcessorPoolID string) *PcloudSharedprocessorpoolsPutOptions {
	return &PcloudSharedprocessorpoolsPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		SharedProcessorPoolID: core.StringPtr(sharedProcessorPoolID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudSharedprocessorpoolsPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudSharedprocessorpoolsPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetSharedProcessorPoolID : Allow user to set SharedProcessorPoolID
func (_options *PcloudSharedprocessorpoolsPutOptions) SetSharedProcessorPoolID(sharedProcessorPoolID string) *PcloudSharedprocessorpoolsPutOptions {
	_options.SharedProcessorPoolID = core.StringPtr(sharedProcessorPoolID)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudSharedprocessorpoolsPutOptions) SetName(name string) *PcloudSharedprocessorpoolsPutOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetReservedCores : Allow user to set ReservedCores
func (_options *PcloudSharedprocessorpoolsPutOptions) SetReservedCores(reservedCores int64) *PcloudSharedprocessorpoolsPutOptions {
	_options.ReservedCores = core.Int64Ptr(reservedCores)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudSharedprocessorpoolsPutOptions) SetHeaders(param map[string]string) *PcloudSharedprocessorpoolsPutOptions {
	options.Headers = param
	return options
}

// PcloudSppplacementgroupsDeleteOptions : The PcloudSppplacementgroupsDelete options.
type PcloudSppplacementgroupsDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Shared Processor Pool Placement Group ID or Name.
	SppPlacementGroupID *string `json:"spp_placement_group_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudSppplacementgroupsDeleteOptions : Instantiate PcloudSppplacementgroupsDeleteOptions
func (*PowervsV1) NewPcloudSppplacementgroupsDeleteOptions(cloudInstanceID string, sppPlacementGroupID string) *PcloudSppplacementgroupsDeleteOptions {
	return &PcloudSppplacementgroupsDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		SppPlacementGroupID: core.StringPtr(sppPlacementGroupID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudSppplacementgroupsDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudSppplacementgroupsDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetSppPlacementGroupID : Allow user to set SppPlacementGroupID
func (_options *PcloudSppplacementgroupsDeleteOptions) SetSppPlacementGroupID(sppPlacementGroupID string) *PcloudSppplacementgroupsDeleteOptions {
	_options.SppPlacementGroupID = core.StringPtr(sppPlacementGroupID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudSppplacementgroupsDeleteOptions) SetHeaders(param map[string]string) *PcloudSppplacementgroupsDeleteOptions {
	options.Headers = param
	return options
}

// PcloudSppplacementgroupsGetOptions : The PcloudSppplacementgroupsGet options.
type PcloudSppplacementgroupsGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Shared Processor Pool Placement Group ID or Name.
	SppPlacementGroupID *string `json:"spp_placement_group_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudSppplacementgroupsGetOptions : Instantiate PcloudSppplacementgroupsGetOptions
func (*PowervsV1) NewPcloudSppplacementgroupsGetOptions(cloudInstanceID string, sppPlacementGroupID string) *PcloudSppplacementgroupsGetOptions {
	return &PcloudSppplacementgroupsGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		SppPlacementGroupID: core.StringPtr(sppPlacementGroupID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudSppplacementgroupsGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudSppplacementgroupsGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetSppPlacementGroupID : Allow user to set SppPlacementGroupID
func (_options *PcloudSppplacementgroupsGetOptions) SetSppPlacementGroupID(sppPlacementGroupID string) *PcloudSppplacementgroupsGetOptions {
	_options.SppPlacementGroupID = core.StringPtr(sppPlacementGroupID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudSppplacementgroupsGetOptions) SetHeaders(param map[string]string) *PcloudSppplacementgroupsGetOptions {
	options.Headers = param
	return options
}

// PcloudSppplacementgroupsGetallOptions : The PcloudSppplacementgroupsGetall options.
type PcloudSppplacementgroupsGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudSppplacementgroupsGetallOptions : Instantiate PcloudSppplacementgroupsGetallOptions
func (*PowervsV1) NewPcloudSppplacementgroupsGetallOptions(cloudInstanceID string) *PcloudSppplacementgroupsGetallOptions {
	return &PcloudSppplacementgroupsGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudSppplacementgroupsGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudSppplacementgroupsGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudSppplacementgroupsGetallOptions) SetHeaders(param map[string]string) *PcloudSppplacementgroupsGetallOptions {
	options.Headers = param
	return options
}

// PcloudSppplacementgroupsMembersDeleteOptions : The PcloudSppplacementgroupsMembersDelete options.
type PcloudSppplacementgroupsMembersDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Shared Processor Pool Placement Group ID or Name.
	SppPlacementGroupID *string `json:"spp_placement_group_id" validate:"required,ne="`

	// Shared Processor Pool ID or Name.
	SharedProcessorPoolID *string `json:"shared_processor_pool_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudSppplacementgroupsMembersDeleteOptions : Instantiate PcloudSppplacementgroupsMembersDeleteOptions
func (*PowervsV1) NewPcloudSppplacementgroupsMembersDeleteOptions(cloudInstanceID string, sppPlacementGroupID string, sharedProcessorPoolID string) *PcloudSppplacementgroupsMembersDeleteOptions {
	return &PcloudSppplacementgroupsMembersDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		SppPlacementGroupID: core.StringPtr(sppPlacementGroupID),
		SharedProcessorPoolID: core.StringPtr(sharedProcessorPoolID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudSppplacementgroupsMembersDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudSppplacementgroupsMembersDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetSppPlacementGroupID : Allow user to set SppPlacementGroupID
func (_options *PcloudSppplacementgroupsMembersDeleteOptions) SetSppPlacementGroupID(sppPlacementGroupID string) *PcloudSppplacementgroupsMembersDeleteOptions {
	_options.SppPlacementGroupID = core.StringPtr(sppPlacementGroupID)
	return _options
}

// SetSharedProcessorPoolID : Allow user to set SharedProcessorPoolID
func (_options *PcloudSppplacementgroupsMembersDeleteOptions) SetSharedProcessorPoolID(sharedProcessorPoolID string) *PcloudSppplacementgroupsMembersDeleteOptions {
	_options.SharedProcessorPoolID = core.StringPtr(sharedProcessorPoolID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudSppplacementgroupsMembersDeleteOptions) SetHeaders(param map[string]string) *PcloudSppplacementgroupsMembersDeleteOptions {
	options.Headers = param
	return options
}

// PcloudSppplacementgroupsMembersPostOptions : The PcloudSppplacementgroupsMembersPost options.
type PcloudSppplacementgroupsMembersPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Shared Processor Pool Placement Group ID or Name.
	SppPlacementGroupID *string `json:"spp_placement_group_id" validate:"required,ne="`

	// Shared Processor Pool ID or Name.
	SharedProcessorPoolID *string `json:"shared_processor_pool_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudSppplacementgroupsMembersPostOptions : Instantiate PcloudSppplacementgroupsMembersPostOptions
func (*PowervsV1) NewPcloudSppplacementgroupsMembersPostOptions(cloudInstanceID string, sppPlacementGroupID string, sharedProcessorPoolID string) *PcloudSppplacementgroupsMembersPostOptions {
	return &PcloudSppplacementgroupsMembersPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		SppPlacementGroupID: core.StringPtr(sppPlacementGroupID),
		SharedProcessorPoolID: core.StringPtr(sharedProcessorPoolID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudSppplacementgroupsMembersPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudSppplacementgroupsMembersPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetSppPlacementGroupID : Allow user to set SppPlacementGroupID
func (_options *PcloudSppplacementgroupsMembersPostOptions) SetSppPlacementGroupID(sppPlacementGroupID string) *PcloudSppplacementgroupsMembersPostOptions {
	_options.SppPlacementGroupID = core.StringPtr(sppPlacementGroupID)
	return _options
}

// SetSharedProcessorPoolID : Allow user to set SharedProcessorPoolID
func (_options *PcloudSppplacementgroupsMembersPostOptions) SetSharedProcessorPoolID(sharedProcessorPoolID string) *PcloudSppplacementgroupsMembersPostOptions {
	_options.SharedProcessorPoolID = core.StringPtr(sharedProcessorPoolID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudSppplacementgroupsMembersPostOptions) SetHeaders(param map[string]string) *PcloudSppplacementgroupsMembersPostOptions {
	options.Headers = param
	return options
}

// PcloudSppplacementgroupsPostOptions : The PcloudSppplacementgroupsPost options.
type PcloudSppplacementgroupsPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// The name of the Shared Processor Pool Placement Group; minimum of 2 characters, maximum of 12, the only special
	// character allowed is the underscore '_'.
	Name *string `json:"name" validate:"required"`

	// The placement group policy.
	Policy *string `json:"policy" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudSppplacementgroupsPostOptions.Policy property.
// The placement group policy.
const (
	PcloudSppplacementgroupsPostOptionsPolicyAffinityConst = "affinity"
	PcloudSppplacementgroupsPostOptionsPolicyAntiAffinityConst = "anti-affinity"
)

// NewPcloudSppplacementgroupsPostOptions : Instantiate PcloudSppplacementgroupsPostOptions
func (*PowervsV1) NewPcloudSppplacementgroupsPostOptions(cloudInstanceID string, name string, policy string) *PcloudSppplacementgroupsPostOptions {
	return &PcloudSppplacementgroupsPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		Name: core.StringPtr(name),
		Policy: core.StringPtr(policy),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudSppplacementgroupsPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudSppplacementgroupsPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudSppplacementgroupsPostOptions) SetName(name string) *PcloudSppplacementgroupsPostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetPolicy : Allow user to set Policy
func (_options *PcloudSppplacementgroupsPostOptions) SetPolicy(policy string) *PcloudSppplacementgroupsPostOptions {
	_options.Policy = core.StringPtr(policy)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudSppplacementgroupsPostOptions) SetHeaders(param map[string]string) *PcloudSppplacementgroupsPostOptions {
	options.Headers = param
	return options
}

// PcloudStoragecapacityPoolsGetOptions : The PcloudStoragecapacityPoolsGet options.
type PcloudStoragecapacityPoolsGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Storage pool name.
	StoragePoolName *string `json:"storage_pool_name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudStoragecapacityPoolsGetOptions : Instantiate PcloudStoragecapacityPoolsGetOptions
func (*PowervsV1) NewPcloudStoragecapacityPoolsGetOptions(cloudInstanceID string, storagePoolName string) *PcloudStoragecapacityPoolsGetOptions {
	return &PcloudStoragecapacityPoolsGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		StoragePoolName: core.StringPtr(storagePoolName),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudStoragecapacityPoolsGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudStoragecapacityPoolsGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetStoragePoolName : Allow user to set StoragePoolName
func (_options *PcloudStoragecapacityPoolsGetOptions) SetStoragePoolName(storagePoolName string) *PcloudStoragecapacityPoolsGetOptions {
	_options.StoragePoolName = core.StringPtr(storagePoolName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudStoragecapacityPoolsGetOptions) SetHeaders(param map[string]string) *PcloudStoragecapacityPoolsGetOptions {
	options.Headers = param
	return options
}

// PcloudStoragecapacityPoolsGetallOptions : The PcloudStoragecapacityPoolsGetall options.
type PcloudStoragecapacityPoolsGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudStoragecapacityPoolsGetallOptions : Instantiate PcloudStoragecapacityPoolsGetallOptions
func (*PowervsV1) NewPcloudStoragecapacityPoolsGetallOptions(cloudInstanceID string) *PcloudStoragecapacityPoolsGetallOptions {
	return &PcloudStoragecapacityPoolsGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudStoragecapacityPoolsGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudStoragecapacityPoolsGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudStoragecapacityPoolsGetallOptions) SetHeaders(param map[string]string) *PcloudStoragecapacityPoolsGetallOptions {
	options.Headers = param
	return options
}

// PcloudStoragecapacityTypesGetOptions : The PcloudStoragecapacityTypesGet options.
type PcloudStoragecapacityTypesGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Storage type name.
	StorageTypeName *string `json:"storage_type_name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudStoragecapacityTypesGetOptions : Instantiate PcloudStoragecapacityTypesGetOptions
func (*PowervsV1) NewPcloudStoragecapacityTypesGetOptions(cloudInstanceID string, storageTypeName string) *PcloudStoragecapacityTypesGetOptions {
	return &PcloudStoragecapacityTypesGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		StorageTypeName: core.StringPtr(storageTypeName),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudStoragecapacityTypesGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudStoragecapacityTypesGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetStorageTypeName : Allow user to set StorageTypeName
func (_options *PcloudStoragecapacityTypesGetOptions) SetStorageTypeName(storageTypeName string) *PcloudStoragecapacityTypesGetOptions {
	_options.StorageTypeName = core.StringPtr(storageTypeName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudStoragecapacityTypesGetOptions) SetHeaders(param map[string]string) *PcloudStoragecapacityTypesGetOptions {
	options.Headers = param
	return options
}

// PcloudStoragecapacityTypesGetallOptions : The PcloudStoragecapacityTypesGetall options.
type PcloudStoragecapacityTypesGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudStoragecapacityTypesGetallOptions : Instantiate PcloudStoragecapacityTypesGetallOptions
func (*PowervsV1) NewPcloudStoragecapacityTypesGetallOptions(cloudInstanceID string) *PcloudStoragecapacityTypesGetallOptions {
	return &PcloudStoragecapacityTypesGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudStoragecapacityTypesGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudStoragecapacityTypesGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudStoragecapacityTypesGetallOptions) SetHeaders(param map[string]string) *PcloudStoragecapacityTypesGetallOptions {
	options.Headers = param
	return options
}

// PcloudSystempoolsGetOptions : The PcloudSystempoolsGet options.
type PcloudSystempoolsGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudSystempoolsGetOptions : Instantiate PcloudSystempoolsGetOptions
func (*PowervsV1) NewPcloudSystempoolsGetOptions(cloudInstanceID string) *PcloudSystempoolsGetOptions {
	return &PcloudSystempoolsGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudSystempoolsGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudSystempoolsGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudSystempoolsGetOptions) SetHeaders(param map[string]string) *PcloudSystempoolsGetOptions {
	options.Headers = param
	return options
}

// PcloudTasksDeleteOptions : The PcloudTasksDelete options.
type PcloudTasksDeleteOptions struct {
	// PCloud Task ID.
	TaskID *string `json:"task_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudTasksDeleteOptions : Instantiate PcloudTasksDeleteOptions
func (*PowervsV1) NewPcloudTasksDeleteOptions(taskID string) *PcloudTasksDeleteOptions {
	return &PcloudTasksDeleteOptions{
		TaskID: core.StringPtr(taskID),
	}
}

// SetTaskID : Allow user to set TaskID
func (_options *PcloudTasksDeleteOptions) SetTaskID(taskID string) *PcloudTasksDeleteOptions {
	_options.TaskID = core.StringPtr(taskID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudTasksDeleteOptions) SetHeaders(param map[string]string) *PcloudTasksDeleteOptions {
	options.Headers = param
	return options
}

// PcloudTasksGetOptions : The PcloudTasksGet options.
type PcloudTasksGetOptions struct {
	// PCloud Task ID.
	TaskID *string `json:"task_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudTasksGetOptions : Instantiate PcloudTasksGetOptions
func (*PowervsV1) NewPcloudTasksGetOptions(taskID string) *PcloudTasksGetOptions {
	return &PcloudTasksGetOptions{
		TaskID: core.StringPtr(taskID),
	}
}

// SetTaskID : Allow user to set TaskID
func (_options *PcloudTasksGetOptions) SetTaskID(taskID string) *PcloudTasksGetOptions {
	_options.TaskID = core.StringPtr(taskID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudTasksGetOptions) SetHeaders(param map[string]string) *PcloudTasksGetOptions {
	options.Headers = param
	return options
}

// PcloudTenantsGetOptions : The PcloudTenantsGet options.
type PcloudTenantsGetOptions struct {
	// Tenant ID of a pcloud tenant.
	TenantID *string `json:"tenant_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudTenantsGetOptions : Instantiate PcloudTenantsGetOptions
func (*PowervsV1) NewPcloudTenantsGetOptions(tenantID string) *PcloudTenantsGetOptions {
	return &PcloudTenantsGetOptions{
		TenantID: core.StringPtr(tenantID),
	}
}

// SetTenantID : Allow user to set TenantID
func (_options *PcloudTenantsGetOptions) SetTenantID(tenantID string) *PcloudTenantsGetOptions {
	_options.TenantID = core.StringPtr(tenantID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudTenantsGetOptions) SetHeaders(param map[string]string) *PcloudTenantsGetOptions {
	options.Headers = param
	return options
}

// PcloudTenantsPutOptions : The PcloudTenantsPut options.
type PcloudTenantsPutOptions struct {
	// Tenant ID of a pcloud tenant.
	TenantID *string `json:"tenant_id" validate:"required,ne="`

	// IBM Customer Number.
	Icn *string `json:"icn,omitempty"`

	// Peering Network Information (optional).
	PeeringNetworks []PeeringNetwork `json:"peeringNetworks,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudTenantsPutOptions : Instantiate PcloudTenantsPutOptions
func (*PowervsV1) NewPcloudTenantsPutOptions(tenantID string) *PcloudTenantsPutOptions {
	return &PcloudTenantsPutOptions{
		TenantID: core.StringPtr(tenantID),
	}
}

// SetTenantID : Allow user to set TenantID
func (_options *PcloudTenantsPutOptions) SetTenantID(tenantID string) *PcloudTenantsPutOptions {
	_options.TenantID = core.StringPtr(tenantID)
	return _options
}

// SetIcn : Allow user to set Icn
func (_options *PcloudTenantsPutOptions) SetIcn(icn string) *PcloudTenantsPutOptions {
	_options.Icn = core.StringPtr(icn)
	return _options
}

// SetPeeringNetworks : Allow user to set PeeringNetworks
func (_options *PcloudTenantsPutOptions) SetPeeringNetworks(peeringNetworks []PeeringNetwork) *PcloudTenantsPutOptions {
	_options.PeeringNetworks = peeringNetworks
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudTenantsPutOptions) SetHeaders(param map[string]string) *PcloudTenantsPutOptions {
	options.Headers = param
	return options
}

// PcloudTenantsSshkeysDeleteOptions : The PcloudTenantsSshkeysDelete options.
type PcloudTenantsSshkeysDeleteOptions struct {
	// Tenant ID of a pcloud tenant.
	TenantID *string `json:"tenant_id" validate:"required,ne="`

	// SSH key name for a pcloud tenant.
	SshkeyName *string `json:"sshkey_name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudTenantsSshkeysDeleteOptions : Instantiate PcloudTenantsSshkeysDeleteOptions
func (*PowervsV1) NewPcloudTenantsSshkeysDeleteOptions(tenantID string, sshkeyName string) *PcloudTenantsSshkeysDeleteOptions {
	return &PcloudTenantsSshkeysDeleteOptions{
		TenantID: core.StringPtr(tenantID),
		SshkeyName: core.StringPtr(sshkeyName),
	}
}

// SetTenantID : Allow user to set TenantID
func (_options *PcloudTenantsSshkeysDeleteOptions) SetTenantID(tenantID string) *PcloudTenantsSshkeysDeleteOptions {
	_options.TenantID = core.StringPtr(tenantID)
	return _options
}

// SetSshkeyName : Allow user to set SshkeyName
func (_options *PcloudTenantsSshkeysDeleteOptions) SetSshkeyName(sshkeyName string) *PcloudTenantsSshkeysDeleteOptions {
	_options.SshkeyName = core.StringPtr(sshkeyName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudTenantsSshkeysDeleteOptions) SetHeaders(param map[string]string) *PcloudTenantsSshkeysDeleteOptions {
	options.Headers = param
	return options
}

// PcloudTenantsSshkeysGetOptions : The PcloudTenantsSshkeysGet options.
type PcloudTenantsSshkeysGetOptions struct {
	// Tenant ID of a pcloud tenant.
	TenantID *string `json:"tenant_id" validate:"required,ne="`

	// SSH key name for a pcloud tenant.
	SshkeyName *string `json:"sshkey_name" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudTenantsSshkeysGetOptions : Instantiate PcloudTenantsSshkeysGetOptions
func (*PowervsV1) NewPcloudTenantsSshkeysGetOptions(tenantID string, sshkeyName string) *PcloudTenantsSshkeysGetOptions {
	return &PcloudTenantsSshkeysGetOptions{
		TenantID: core.StringPtr(tenantID),
		SshkeyName: core.StringPtr(sshkeyName),
	}
}

// SetTenantID : Allow user to set TenantID
func (_options *PcloudTenantsSshkeysGetOptions) SetTenantID(tenantID string) *PcloudTenantsSshkeysGetOptions {
	_options.TenantID = core.StringPtr(tenantID)
	return _options
}

// SetSshkeyName : Allow user to set SshkeyName
func (_options *PcloudTenantsSshkeysGetOptions) SetSshkeyName(sshkeyName string) *PcloudTenantsSshkeysGetOptions {
	_options.SshkeyName = core.StringPtr(sshkeyName)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudTenantsSshkeysGetOptions) SetHeaders(param map[string]string) *PcloudTenantsSshkeysGetOptions {
	options.Headers = param
	return options
}

// PcloudTenantsSshkeysGetallOptions : The PcloudTenantsSshkeysGetall options.
type PcloudTenantsSshkeysGetallOptions struct {
	// Tenant ID of a pcloud tenant.
	TenantID *string `json:"tenant_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudTenantsSshkeysGetallOptions : Instantiate PcloudTenantsSshkeysGetallOptions
func (*PowervsV1) NewPcloudTenantsSshkeysGetallOptions(tenantID string) *PcloudTenantsSshkeysGetallOptions {
	return &PcloudTenantsSshkeysGetallOptions{
		TenantID: core.StringPtr(tenantID),
	}
}

// SetTenantID : Allow user to set TenantID
func (_options *PcloudTenantsSshkeysGetallOptions) SetTenantID(tenantID string) *PcloudTenantsSshkeysGetallOptions {
	_options.TenantID = core.StringPtr(tenantID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudTenantsSshkeysGetallOptions) SetHeaders(param map[string]string) *PcloudTenantsSshkeysGetallOptions {
	options.Headers = param
	return options
}

// PcloudTenantsSshkeysPostOptions : The PcloudTenantsSshkeysPost options.
type PcloudTenantsSshkeysPostOptions struct {
	// Tenant ID of a pcloud tenant.
	TenantID *string `json:"tenant_id" validate:"required,ne="`

	// User defined name for the SSH key.
	Name *string `json:"name" validate:"required"`

	// SSH RSA key.
	SshKey *string `json:"sshKey" validate:"required"`

	// Date of sshkey creation.
	CreationDate *strfmt.DateTime `json:"creationDate,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudTenantsSshkeysPostOptions : Instantiate PcloudTenantsSshkeysPostOptions
func (*PowervsV1) NewPcloudTenantsSshkeysPostOptions(tenantID string, name string, sshKey string) *PcloudTenantsSshkeysPostOptions {
	return &PcloudTenantsSshkeysPostOptions{
		TenantID: core.StringPtr(tenantID),
		Name: core.StringPtr(name),
		SshKey: core.StringPtr(sshKey),
	}
}

// SetTenantID : Allow user to set TenantID
func (_options *PcloudTenantsSshkeysPostOptions) SetTenantID(tenantID string) *PcloudTenantsSshkeysPostOptions {
	_options.TenantID = core.StringPtr(tenantID)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudTenantsSshkeysPostOptions) SetName(name string) *PcloudTenantsSshkeysPostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetSshKey : Allow user to set SshKey
func (_options *PcloudTenantsSshkeysPostOptions) SetSshKey(sshKey string) *PcloudTenantsSshkeysPostOptions {
	_options.SshKey = core.StringPtr(sshKey)
	return _options
}

// SetCreationDate : Allow user to set CreationDate
func (_options *PcloudTenantsSshkeysPostOptions) SetCreationDate(creationDate *strfmt.DateTime) *PcloudTenantsSshkeysPostOptions {
	_options.CreationDate = creationDate
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudTenantsSshkeysPostOptions) SetHeaders(param map[string]string) *PcloudTenantsSshkeysPostOptions {
	options.Headers = param
	return options
}

// PcloudTenantsSshkeysPutOptions : The PcloudTenantsSshkeysPut options.
type PcloudTenantsSshkeysPutOptions struct {
	// Tenant ID of a pcloud tenant.
	TenantID *string `json:"tenant_id" validate:"required,ne="`

	// SSH key name for a pcloud tenant.
	SshkeyName *string `json:"sshkey_name" validate:"required,ne="`

	// User defined name for the SSH key.
	Name *string `json:"name" validate:"required"`

	// SSH RSA key.
	SshKey *string `json:"sshKey" validate:"required"`

	// Date of sshkey creation.
	CreationDate *strfmt.DateTime `json:"creationDate,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudTenantsSshkeysPutOptions : Instantiate PcloudTenantsSshkeysPutOptions
func (*PowervsV1) NewPcloudTenantsSshkeysPutOptions(tenantID string, sshkeyName string, name string, sshKey string) *PcloudTenantsSshkeysPutOptions {
	return &PcloudTenantsSshkeysPutOptions{
		TenantID: core.StringPtr(tenantID),
		SshkeyName: core.StringPtr(sshkeyName),
		Name: core.StringPtr(name),
		SshKey: core.StringPtr(sshKey),
	}
}

// SetTenantID : Allow user to set TenantID
func (_options *PcloudTenantsSshkeysPutOptions) SetTenantID(tenantID string) *PcloudTenantsSshkeysPutOptions {
	_options.TenantID = core.StringPtr(tenantID)
	return _options
}

// SetSshkeyName : Allow user to set SshkeyName
func (_options *PcloudTenantsSshkeysPutOptions) SetSshkeyName(sshkeyName string) *PcloudTenantsSshkeysPutOptions {
	_options.SshkeyName = core.StringPtr(sshkeyName)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudTenantsSshkeysPutOptions) SetName(name string) *PcloudTenantsSshkeysPutOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetSshKey : Allow user to set SshKey
func (_options *PcloudTenantsSshkeysPutOptions) SetSshKey(sshKey string) *PcloudTenantsSshkeysPutOptions {
	_options.SshKey = core.StringPtr(sshKey)
	return _options
}

// SetCreationDate : Allow user to set CreationDate
func (_options *PcloudTenantsSshkeysPutOptions) SetCreationDate(creationDate *strfmt.DateTime) *PcloudTenantsSshkeysPutOptions {
	_options.CreationDate = creationDate
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudTenantsSshkeysPutOptions) SetHeaders(param map[string]string) *PcloudTenantsSshkeysPutOptions {
	options.Headers = param
	return options
}

// PcloudV1CloudinstancesCosimagesGetOptions : The PcloudV1CloudinstancesCosimagesGet options.
type PcloudV1CloudinstancesCosimagesGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudV1CloudinstancesCosimagesGetOptions : Instantiate PcloudV1CloudinstancesCosimagesGetOptions
func (*PowervsV1) NewPcloudV1CloudinstancesCosimagesGetOptions(cloudInstanceID string) *PcloudV1CloudinstancesCosimagesGetOptions {
	return &PcloudV1CloudinstancesCosimagesGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV1CloudinstancesCosimagesGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV1CloudinstancesCosimagesGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV1CloudinstancesCosimagesGetOptions) SetHeaders(param map[string]string) *PcloudV1CloudinstancesCosimagesGetOptions {
	options.Headers = param
	return options
}

// PcloudV1CloudinstancesCosimagesPostOptions : The PcloudV1CloudinstancesCosimagesPost options.
type PcloudV1CloudinstancesCosimagesPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Cloud Object Storage bucket name; bucket-name[/optional/folder].
	BucketName *string `json:"bucketName" validate:"required"`

	// Cloud Object Storage image filename.
	ImageFilename *string `json:"imageFilename" validate:"required"`

	// Name for the image that will be loaded into the boot image catalog.
	ImageName *string `json:"imageName" validate:"required"`

	// Cloud Object Storage region.
	Region *string `json:"region" validate:"required"`

	// Cloud Object Storage access key; required for buckets with private access.
	AccessKey *string `json:"accessKey,omitempty"`

	// indicates if the bucket has public or private access public access require no authentication keys private access
	// requires hmac authentication keys (access,secret).
	BucketAccess *string `json:"bucketAccess,omitempty"`

	// Image OS Type, required if importing a raw image; raw images can only be imported using the command line interface.
	OsType *string `json:"osType,omitempty"`

	// Cloud Object Storage secret key; required for buckets with private access.
	SecretKey *string `json:"secretKey,omitempty"`

	StorageAffinity *StorageAffinity `json:"storageAffinity,omitempty"`

	// Storage pool where the image will be loaded, if provided then storageAffinity will be ignored.
	StoragePool *string `json:"storagePool,omitempty"`

	// Type of storage; If only using storageType for storage selection then the storage pool with the most available space
	// will be selected if storageType is not provided the storage type will default to 'tier3'.
	StorageType *string `json:"storageType,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudV1CloudinstancesCosimagesPostOptions.BucketAccess property.
// indicates if the bucket has public or private access public access require no authentication keys private access
// requires hmac authentication keys (access,secret).
const (
	PcloudV1CloudinstancesCosimagesPostOptionsBucketAccessPrivateConst = "private"
	PcloudV1CloudinstancesCosimagesPostOptionsBucketAccessPublicConst = "public"
)

// Constants associated with the PcloudV1CloudinstancesCosimagesPostOptions.OsType property.
// Image OS Type, required if importing a raw image; raw images can only be imported using the command line interface.
const (
	PcloudV1CloudinstancesCosimagesPostOptionsOsTypeAixConst = "aix"
	PcloudV1CloudinstancesCosimagesPostOptionsOsTypeIbmiConst = "ibmi"
	PcloudV1CloudinstancesCosimagesPostOptionsOsTypeRhelConst = "rhel"
	PcloudV1CloudinstancesCosimagesPostOptionsOsTypeSlesConst = "sles"
)

// NewPcloudV1CloudinstancesCosimagesPostOptions : Instantiate PcloudV1CloudinstancesCosimagesPostOptions
func (*PowervsV1) NewPcloudV1CloudinstancesCosimagesPostOptions(cloudInstanceID string, bucketName string, imageFilename string, imageName string, region string) *PcloudV1CloudinstancesCosimagesPostOptions {
	return &PcloudV1CloudinstancesCosimagesPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		BucketName: core.StringPtr(bucketName),
		ImageFilename: core.StringPtr(imageFilename),
		ImageName: core.StringPtr(imageName),
		Region: core.StringPtr(region),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV1CloudinstancesCosimagesPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV1CloudinstancesCosimagesPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetBucketName : Allow user to set BucketName
func (_options *PcloudV1CloudinstancesCosimagesPostOptions) SetBucketName(bucketName string) *PcloudV1CloudinstancesCosimagesPostOptions {
	_options.BucketName = core.StringPtr(bucketName)
	return _options
}

// SetImageFilename : Allow user to set ImageFilename
func (_options *PcloudV1CloudinstancesCosimagesPostOptions) SetImageFilename(imageFilename string) *PcloudV1CloudinstancesCosimagesPostOptions {
	_options.ImageFilename = core.StringPtr(imageFilename)
	return _options
}

// SetImageName : Allow user to set ImageName
func (_options *PcloudV1CloudinstancesCosimagesPostOptions) SetImageName(imageName string) *PcloudV1CloudinstancesCosimagesPostOptions {
	_options.ImageName = core.StringPtr(imageName)
	return _options
}

// SetRegion : Allow user to set Region
func (_options *PcloudV1CloudinstancesCosimagesPostOptions) SetRegion(region string) *PcloudV1CloudinstancesCosimagesPostOptions {
	_options.Region = core.StringPtr(region)
	return _options
}

// SetAccessKey : Allow user to set AccessKey
func (_options *PcloudV1CloudinstancesCosimagesPostOptions) SetAccessKey(accessKey string) *PcloudV1CloudinstancesCosimagesPostOptions {
	_options.AccessKey = core.StringPtr(accessKey)
	return _options
}

// SetBucketAccess : Allow user to set BucketAccess
func (_options *PcloudV1CloudinstancesCosimagesPostOptions) SetBucketAccess(bucketAccess string) *PcloudV1CloudinstancesCosimagesPostOptions {
	_options.BucketAccess = core.StringPtr(bucketAccess)
	return _options
}

// SetOsType : Allow user to set OsType
func (_options *PcloudV1CloudinstancesCosimagesPostOptions) SetOsType(osType string) *PcloudV1CloudinstancesCosimagesPostOptions {
	_options.OsType = core.StringPtr(osType)
	return _options
}

// SetSecretKey : Allow user to set SecretKey
func (_options *PcloudV1CloudinstancesCosimagesPostOptions) SetSecretKey(secretKey string) *PcloudV1CloudinstancesCosimagesPostOptions {
	_options.SecretKey = core.StringPtr(secretKey)
	return _options
}

// SetStorageAffinity : Allow user to set StorageAffinity
func (_options *PcloudV1CloudinstancesCosimagesPostOptions) SetStorageAffinity(storageAffinity *StorageAffinity) *PcloudV1CloudinstancesCosimagesPostOptions {
	_options.StorageAffinity = storageAffinity
	return _options
}

// SetStoragePool : Allow user to set StoragePool
func (_options *PcloudV1CloudinstancesCosimagesPostOptions) SetStoragePool(storagePool string) *PcloudV1CloudinstancesCosimagesPostOptions {
	_options.StoragePool = core.StringPtr(storagePool)
	return _options
}

// SetStorageType : Allow user to set StorageType
func (_options *PcloudV1CloudinstancesCosimagesPostOptions) SetStorageType(storageType string) *PcloudV1CloudinstancesCosimagesPostOptions {
	_options.StorageType = core.StringPtr(storageType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV1CloudinstancesCosimagesPostOptions) SetHeaders(param map[string]string) *PcloudV1CloudinstancesCosimagesPostOptions {
	options.Headers = param
	return options
}

// PcloudV2ImagesExportGetOptions : The PcloudV2ImagesExportGet options.
type PcloudV2ImagesExportGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Image ID of a image.
	ImageID *string `json:"image_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudV2ImagesExportGetOptions : Instantiate PcloudV2ImagesExportGetOptions
func (*PowervsV1) NewPcloudV2ImagesExportGetOptions(cloudInstanceID string, imageID string) *PcloudV2ImagesExportGetOptions {
	return &PcloudV2ImagesExportGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		ImageID: core.StringPtr(imageID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2ImagesExportGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2ImagesExportGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetImageID : Allow user to set ImageID
func (_options *PcloudV2ImagesExportGetOptions) SetImageID(imageID string) *PcloudV2ImagesExportGetOptions {
	_options.ImageID = core.StringPtr(imageID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2ImagesExportGetOptions) SetHeaders(param map[string]string) *PcloudV2ImagesExportGetOptions {
	options.Headers = param
	return options
}

// PcloudV2ImagesExportPostOptions : The PcloudV2ImagesExportPost options.
type PcloudV2ImagesExportPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Image ID of a image.
	ImageID *string `json:"image_id" validate:"required,ne="`

	// Cloud Object Storage Access key.
	AccessKey *string `json:"accessKey" validate:"required"`

	// Cloud Object Storage Bucket name.
	BucketName *string `json:"bucketName" validate:"required"`

	// Cloud Object Storage Region; required for IBM COS.
	Region *string `json:"region,omitempty"`

	// Cloud Object Storage Secret key.
	SecretKey *string `json:"secretKey,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudV2ImagesExportPostOptions : Instantiate PcloudV2ImagesExportPostOptions
func (*PowervsV1) NewPcloudV2ImagesExportPostOptions(cloudInstanceID string, imageID string, accessKey string, bucketName string) *PcloudV2ImagesExportPostOptions {
	return &PcloudV2ImagesExportPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		ImageID: core.StringPtr(imageID),
		AccessKey: core.StringPtr(accessKey),
		BucketName: core.StringPtr(bucketName),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2ImagesExportPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2ImagesExportPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetImageID : Allow user to set ImageID
func (_options *PcloudV2ImagesExportPostOptions) SetImageID(imageID string) *PcloudV2ImagesExportPostOptions {
	_options.ImageID = core.StringPtr(imageID)
	return _options
}

// SetAccessKey : Allow user to set AccessKey
func (_options *PcloudV2ImagesExportPostOptions) SetAccessKey(accessKey string) *PcloudV2ImagesExportPostOptions {
	_options.AccessKey = core.StringPtr(accessKey)
	return _options
}

// SetBucketName : Allow user to set BucketName
func (_options *PcloudV2ImagesExportPostOptions) SetBucketName(bucketName string) *PcloudV2ImagesExportPostOptions {
	_options.BucketName = core.StringPtr(bucketName)
	return _options
}

// SetRegion : Allow user to set Region
func (_options *PcloudV2ImagesExportPostOptions) SetRegion(region string) *PcloudV2ImagesExportPostOptions {
	_options.Region = core.StringPtr(region)
	return _options
}

// SetSecretKey : Allow user to set SecretKey
func (_options *PcloudV2ImagesExportPostOptions) SetSecretKey(secretKey string) *PcloudV2ImagesExportPostOptions {
	_options.SecretKey = core.StringPtr(secretKey)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2ImagesExportPostOptions) SetHeaders(param map[string]string) *PcloudV2ImagesExportPostOptions {
	options.Headers = param
	return options
}

// PcloudV2PvminstancesCaptureGetOptions : The PcloudV2PvminstancesCaptureGet options.
type PcloudV2PvminstancesCaptureGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudV2PvminstancesCaptureGetOptions : Instantiate PcloudV2PvminstancesCaptureGetOptions
func (*PowervsV1) NewPcloudV2PvminstancesCaptureGetOptions(cloudInstanceID string, pvmInstanceID string) *PcloudV2PvminstancesCaptureGetOptions {
	return &PcloudV2PvminstancesCaptureGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2PvminstancesCaptureGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2PvminstancesCaptureGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudV2PvminstancesCaptureGetOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudV2PvminstancesCaptureGetOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2PvminstancesCaptureGetOptions) SetHeaders(param map[string]string) *PcloudV2PvminstancesCaptureGetOptions {
	options.Headers = param
	return options
}

// PcloudV2PvminstancesCapturePostOptions : The PcloudV2PvminstancesCapturePost options.
type PcloudV2PvminstancesCapturePostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Destination for the deployable image.
	CaptureDestination *string `json:"captureDestination" validate:"required"`

	// Name of the deployable image created for the captured PVMInstance.
	CaptureName *string `json:"captureName" validate:"required"`

	// List of Data volume IDs to include in the captured PVMInstance.
	CaptureVolumeIDs []string `json:"captureVolumeIDs,omitempty"`

	// Cloud Storage Access key.
	CloudStorageAccessKey *string `json:"cloudStorageAccessKey,omitempty"`

	// Cloud Storage Image Path (bucket-name [/folder/../..]).
	CloudStorageImagePath *string `json:"cloudStorageImagePath,omitempty"`

	// Cloud Storage Region.
	CloudStorageRegion *string `json:"cloudStorageRegion,omitempty"`

	// Cloud Storage Secret key.
	CloudStorageSecretKey *string `json:"cloudStorageSecretKey,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudV2PvminstancesCapturePostOptions.CaptureDestination property.
// Destination for the deployable image.
const (
	PcloudV2PvminstancesCapturePostOptionsCaptureDestinationBothConst = "both"
	PcloudV2PvminstancesCapturePostOptionsCaptureDestinationCloudStorageConst = "cloud-storage"
	PcloudV2PvminstancesCapturePostOptionsCaptureDestinationImageCatalogConst = "image-catalog"
)

// NewPcloudV2PvminstancesCapturePostOptions : Instantiate PcloudV2PvminstancesCapturePostOptions
func (*PowervsV1) NewPcloudV2PvminstancesCapturePostOptions(cloudInstanceID string, pvmInstanceID string, captureDestination string, captureName string) *PcloudV2PvminstancesCapturePostOptions {
	return &PcloudV2PvminstancesCapturePostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		CaptureDestination: core.StringPtr(captureDestination),
		CaptureName: core.StringPtr(captureName),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2PvminstancesCapturePostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2PvminstancesCapturePostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudV2PvminstancesCapturePostOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudV2PvminstancesCapturePostOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetCaptureDestination : Allow user to set CaptureDestination
func (_options *PcloudV2PvminstancesCapturePostOptions) SetCaptureDestination(captureDestination string) *PcloudV2PvminstancesCapturePostOptions {
	_options.CaptureDestination = core.StringPtr(captureDestination)
	return _options
}

// SetCaptureName : Allow user to set CaptureName
func (_options *PcloudV2PvminstancesCapturePostOptions) SetCaptureName(captureName string) *PcloudV2PvminstancesCapturePostOptions {
	_options.CaptureName = core.StringPtr(captureName)
	return _options
}

// SetCaptureVolumeIDs : Allow user to set CaptureVolumeIDs
func (_options *PcloudV2PvminstancesCapturePostOptions) SetCaptureVolumeIDs(captureVolumeIDs []string) *PcloudV2PvminstancesCapturePostOptions {
	_options.CaptureVolumeIDs = captureVolumeIDs
	return _options
}

// SetCloudStorageAccessKey : Allow user to set CloudStorageAccessKey
func (_options *PcloudV2PvminstancesCapturePostOptions) SetCloudStorageAccessKey(cloudStorageAccessKey string) *PcloudV2PvminstancesCapturePostOptions {
	_options.CloudStorageAccessKey = core.StringPtr(cloudStorageAccessKey)
	return _options
}

// SetCloudStorageImagePath : Allow user to set CloudStorageImagePath
func (_options *PcloudV2PvminstancesCapturePostOptions) SetCloudStorageImagePath(cloudStorageImagePath string) *PcloudV2PvminstancesCapturePostOptions {
	_options.CloudStorageImagePath = core.StringPtr(cloudStorageImagePath)
	return _options
}

// SetCloudStorageRegion : Allow user to set CloudStorageRegion
func (_options *PcloudV2PvminstancesCapturePostOptions) SetCloudStorageRegion(cloudStorageRegion string) *PcloudV2PvminstancesCapturePostOptions {
	_options.CloudStorageRegion = core.StringPtr(cloudStorageRegion)
	return _options
}

// SetCloudStorageSecretKey : Allow user to set CloudStorageSecretKey
func (_options *PcloudV2PvminstancesCapturePostOptions) SetCloudStorageSecretKey(cloudStorageSecretKey string) *PcloudV2PvminstancesCapturePostOptions {
	_options.CloudStorageSecretKey = core.StringPtr(cloudStorageSecretKey)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2PvminstancesCapturePostOptions) SetHeaders(param map[string]string) *PcloudV2PvminstancesCapturePostOptions {
	options.Headers = param
	return options
}

// PcloudV2PvminstancesGetallOptions : The PcloudV2PvminstancesGetall options.
type PcloudV2PvminstancesGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudV2PvminstancesGetallOptions : Instantiate PcloudV2PvminstancesGetallOptions
func (*PowervsV1) NewPcloudV2PvminstancesGetallOptions(cloudInstanceID string) *PcloudV2PvminstancesGetallOptions {
	return &PcloudV2PvminstancesGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2PvminstancesGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2PvminstancesGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2PvminstancesGetallOptions) SetHeaders(param map[string]string) *PcloudV2PvminstancesGetallOptions {
	options.Headers = param
	return options
}

// PcloudV2PvminstancesVolumesDeleteOptions : The PcloudV2PvminstancesVolumesDelete options.
type PcloudV2PvminstancesVolumesDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Indicates if all volumes, except primary boot volume, attached to the PVMInstance should be detached
	// (default=false); required if volumeIDs is not provided.
	DetachAllVolumes *bool `json:"detachAllVolumes,omitempty"`

	// Indicates if primary boot volume attached to the PVMInstance should be detached (default=false).
	DetachPrimaryBootVolume *bool `json:"detachPrimaryBootVolume,omitempty"`

	// List of volumes to be detached from a PVM instance; required if detachAllVolumes is not provided.
	VolumeIDs []string `json:"volumeIDs,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudV2PvminstancesVolumesDeleteOptions : Instantiate PcloudV2PvminstancesVolumesDeleteOptions
func (*PowervsV1) NewPcloudV2PvminstancesVolumesDeleteOptions(cloudInstanceID string, pvmInstanceID string) *PcloudV2PvminstancesVolumesDeleteOptions {
	return &PcloudV2PvminstancesVolumesDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2PvminstancesVolumesDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2PvminstancesVolumesDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudV2PvminstancesVolumesDeleteOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudV2PvminstancesVolumesDeleteOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetDetachAllVolumes : Allow user to set DetachAllVolumes
func (_options *PcloudV2PvminstancesVolumesDeleteOptions) SetDetachAllVolumes(detachAllVolumes bool) *PcloudV2PvminstancesVolumesDeleteOptions {
	_options.DetachAllVolumes = core.BoolPtr(detachAllVolumes)
	return _options
}

// SetDetachPrimaryBootVolume : Allow user to set DetachPrimaryBootVolume
func (_options *PcloudV2PvminstancesVolumesDeleteOptions) SetDetachPrimaryBootVolume(detachPrimaryBootVolume bool) *PcloudV2PvminstancesVolumesDeleteOptions {
	_options.DetachPrimaryBootVolume = core.BoolPtr(detachPrimaryBootVolume)
	return _options
}

// SetVolumeIDs : Allow user to set VolumeIDs
func (_options *PcloudV2PvminstancesVolumesDeleteOptions) SetVolumeIDs(volumeIDs []string) *PcloudV2PvminstancesVolumesDeleteOptions {
	_options.VolumeIDs = volumeIDs
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2PvminstancesVolumesDeleteOptions) SetHeaders(param map[string]string) *PcloudV2PvminstancesVolumesDeleteOptions {
	options.Headers = param
	return options
}

// PcloudV2PvminstancesVolumesPostOptions : The PcloudV2PvminstancesVolumesPost options.
type PcloudV2PvminstancesVolumesPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// List of volumes to be attached to a PVM instance.
	VolumeIDs []string `json:"volumeIDs" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudV2PvminstancesVolumesPostOptions : Instantiate PcloudV2PvminstancesVolumesPostOptions
func (*PowervsV1) NewPcloudV2PvminstancesVolumesPostOptions(cloudInstanceID string, pvmInstanceID string, volumeIDs []string) *PcloudV2PvminstancesVolumesPostOptions {
	return &PcloudV2PvminstancesVolumesPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
		VolumeIDs: volumeIDs,
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2PvminstancesVolumesPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2PvminstancesVolumesPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *PcloudV2PvminstancesVolumesPostOptions) SetPvmInstanceID(pvmInstanceID string) *PcloudV2PvminstancesVolumesPostOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetVolumeIDs : Allow user to set VolumeIDs
func (_options *PcloudV2PvminstancesVolumesPostOptions) SetVolumeIDs(volumeIDs []string) *PcloudV2PvminstancesVolumesPostOptions {
	_options.VolumeIDs = volumeIDs
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2PvminstancesVolumesPostOptions) SetHeaders(param map[string]string) *PcloudV2PvminstancesVolumesPostOptions {
	options.Headers = param
	return options
}

// PcloudV2VolumesClonePostOptions : The PcloudV2VolumesClonePost options.
type PcloudV2VolumesClonePostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Base name of the new cloned volume(s). Cloned Volume names will be prefixed with 'clone-'
	//     and suffixed with '-#####' (where ##### is a 5 digit random number) If multiple volumes cloned they will be
	// further suffixed with an incremental number starting with 1.
	//   Example volume names using name="volume-abcdef"
	//     single volume clone will be named "clone-volume-abcdef-83081"
	//     multi volume clone will be named "clone-volume-abcdef-73721-1", "clone-volume-abcdef-73721-2", ...
	Name *string `json:"name" validate:"required"`

	// List of volumes to be cloned.
	VolumeIDs []string `json:"volumeIDs" validate:"required"`

	// Cloned volume will be non replication enabled if it is set to false. By default, the replication property of the
	// source volume will be used to determine the replication property of the cloned target volume.
	TargetReplicationEnabled *bool `json:"targetReplicationEnabled,omitempty"`

	// Target storage tier for the cloned volumes. Use to clone a set of volumes from one storage tier to a different
	// storage tier. Cloned volumes must remain in the same storage pool as the source volumes.
	TargetStorageTier *string `json:"targetStorageTier,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudV2VolumesClonePostOptions : Instantiate PcloudV2VolumesClonePostOptions
func (*PowervsV1) NewPcloudV2VolumesClonePostOptions(cloudInstanceID string, name string, volumeIDs []string) *PcloudV2VolumesClonePostOptions {
	return &PcloudV2VolumesClonePostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		Name: core.StringPtr(name),
		VolumeIDs: volumeIDs,
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2VolumesClonePostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2VolumesClonePostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudV2VolumesClonePostOptions) SetName(name string) *PcloudV2VolumesClonePostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetVolumeIDs : Allow user to set VolumeIDs
func (_options *PcloudV2VolumesClonePostOptions) SetVolumeIDs(volumeIDs []string) *PcloudV2VolumesClonePostOptions {
	_options.VolumeIDs = volumeIDs
	return _options
}

// SetTargetReplicationEnabled : Allow user to set TargetReplicationEnabled
func (_options *PcloudV2VolumesClonePostOptions) SetTargetReplicationEnabled(targetReplicationEnabled bool) *PcloudV2VolumesClonePostOptions {
	_options.TargetReplicationEnabled = core.BoolPtr(targetReplicationEnabled)
	return _options
}

// SetTargetStorageTier : Allow user to set TargetStorageTier
func (_options *PcloudV2VolumesClonePostOptions) SetTargetStorageTier(targetStorageTier string) *PcloudV2VolumesClonePostOptions {
	_options.TargetStorageTier = core.StringPtr(targetStorageTier)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2VolumesClonePostOptions) SetHeaders(param map[string]string) *PcloudV2VolumesClonePostOptions {
	options.Headers = param
	return options
}

// PcloudV2VolumesClonetasksGetOptions : The PcloudV2VolumesClonetasksGet options.
type PcloudV2VolumesClonetasksGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Volumes Clone Task ID.
	CloneTaskID *string `json:"clone_task_id" validate:"required,ne="`

	// The type of the response: application/json, percentComplete, or status.
	Accept *string `json:"Accept,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudV2VolumesClonetasksGetOptions : Instantiate PcloudV2VolumesClonetasksGetOptions
func (*PowervsV1) NewPcloudV2VolumesClonetasksGetOptions(cloudInstanceID string, cloneTaskID string) *PcloudV2VolumesClonetasksGetOptions {
	return &PcloudV2VolumesClonetasksGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		CloneTaskID: core.StringPtr(cloneTaskID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2VolumesClonetasksGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2VolumesClonetasksGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetCloneTaskID : Allow user to set CloneTaskID
func (_options *PcloudV2VolumesClonetasksGetOptions) SetCloneTaskID(cloneTaskID string) *PcloudV2VolumesClonetasksGetOptions {
	_options.CloneTaskID = core.StringPtr(cloneTaskID)
	return _options
}

// SetAccept : Allow user to set Accept
func (_options *PcloudV2VolumesClonetasksGetOptions) SetAccept(accept string) *PcloudV2VolumesClonetasksGetOptions {
	_options.Accept = core.StringPtr(accept)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2VolumesClonetasksGetOptions) SetHeaders(param map[string]string) *PcloudV2VolumesClonetasksGetOptions {
	options.Headers = param
	return options
}

// PcloudV2VolumesDeleteOptions : The PcloudV2VolumesDelete options.
type PcloudV2VolumesDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// List of volumes to be deleted.
	VolumeIDs []string `json:"volumeIDs" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudV2VolumesDeleteOptions : Instantiate PcloudV2VolumesDeleteOptions
func (*PowervsV1) NewPcloudV2VolumesDeleteOptions(cloudInstanceID string, volumeIDs []string) *PcloudV2VolumesDeleteOptions {
	return &PcloudV2VolumesDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumeIDs: volumeIDs,
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2VolumesDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2VolumesDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumeIDs : Allow user to set VolumeIDs
func (_options *PcloudV2VolumesDeleteOptions) SetVolumeIDs(volumeIDs []string) *PcloudV2VolumesDeleteOptions {
	_options.VolumeIDs = volumeIDs
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2VolumesDeleteOptions) SetHeaders(param map[string]string) *PcloudV2VolumesDeleteOptions {
	options.Headers = param
	return options
}

// PcloudV2VolumesPostOptions : The PcloudV2VolumesPost options.
type PcloudV2VolumesPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Base name of the volume(s).
	Name *string `json:"name" validate:"required"`

	// Volume Size (GB).
	Size *int64 `json:"size" validate:"required"`

	// PVM Instance (ID or Name)to base volume affinity policy against; required if requesting affinity and affinityVolume
	// is not provided.
	AffinityPvmInstance *string `json:"affinityPVMInstance,omitempty"`

	// Affinity policy for data volume being created; ignored if volumePool provided; for policy 'affinity' requires one of
	// affinityPVMInstance or affinityVolume to be specified; for policy 'anti-affinity' requires one of
	// antiAffinityPVMInstances or antiAffinityVolumes to be specified.
	AffinityPolicy *string `json:"affinityPolicy,omitempty"`

	// Volume (ID or Name) to base volume affinity policy against; required if requesting affinity and affinityPVMInstance
	// is not provided.
	AffinityVolume *string `json:"affinityVolume,omitempty"`

	// List of pvmInstances to base volume anti-affinity policy against; required if requesting anti-affinity and
	// antiAffinityVolumes is not provided.
	AntiAffinityPvmInstances []string `json:"antiAffinityPVMInstances,omitempty"`

	// List of volumes to base volume anti-affinity policy against; required if requesting anti-affinity and
	// antiAffinityPVMInstances is not provided.
	AntiAffinityVolumes []string `json:"antiAffinityVolumes,omitempty"`

	// Number of volumes to create.
	Count *int64 `json:"count,omitempty"`

	// Type of Disk; if diskType is not provided the disk type will default to 'tier3'.
	DiskType *string `json:"diskType,omitempty"`

	// Indicates if the volume should be replication enabled or not.
	ReplicationEnabled *bool `json:"replicationEnabled,omitempty"`

	// Indicates if the volume is shareable between VMs.
	Shareable *bool `json:"shareable,omitempty"`

	// Volume pool where the volume will be created; if provided then affinityPolicy value will be ignored.
	VolumePool *string `json:"volumePool,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudV2VolumesPostOptions.AffinityPolicy property.
// Affinity policy for data volume being created; ignored if volumePool provided; for policy 'affinity' requires one of
// affinityPVMInstance or affinityVolume to be specified; for policy 'anti-affinity' requires one of
// antiAffinityPVMInstances or antiAffinityVolumes to be specified.
const (
	PcloudV2VolumesPostOptionsAffinityPolicyAffinityConst = "affinity"
	PcloudV2VolumesPostOptionsAffinityPolicyAntiAffinityConst = "anti-affinity"
)

// NewPcloudV2VolumesPostOptions : Instantiate PcloudV2VolumesPostOptions
func (*PowervsV1) NewPcloudV2VolumesPostOptions(cloudInstanceID string, name string, size int64) *PcloudV2VolumesPostOptions {
	return &PcloudV2VolumesPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		Name: core.StringPtr(name),
		Size: core.Int64Ptr(size),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2VolumesPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2VolumesPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudV2VolumesPostOptions) SetName(name string) *PcloudV2VolumesPostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetSize : Allow user to set Size
func (_options *PcloudV2VolumesPostOptions) SetSize(size int64) *PcloudV2VolumesPostOptions {
	_options.Size = core.Int64Ptr(size)
	return _options
}

// SetAffinityPvmInstance : Allow user to set AffinityPvmInstance
func (_options *PcloudV2VolumesPostOptions) SetAffinityPvmInstance(affinityPvmInstance string) *PcloudV2VolumesPostOptions {
	_options.AffinityPvmInstance = core.StringPtr(affinityPvmInstance)
	return _options
}

// SetAffinityPolicy : Allow user to set AffinityPolicy
func (_options *PcloudV2VolumesPostOptions) SetAffinityPolicy(affinityPolicy string) *PcloudV2VolumesPostOptions {
	_options.AffinityPolicy = core.StringPtr(affinityPolicy)
	return _options
}

// SetAffinityVolume : Allow user to set AffinityVolume
func (_options *PcloudV2VolumesPostOptions) SetAffinityVolume(affinityVolume string) *PcloudV2VolumesPostOptions {
	_options.AffinityVolume = core.StringPtr(affinityVolume)
	return _options
}

// SetAntiAffinityPvmInstances : Allow user to set AntiAffinityPvmInstances
func (_options *PcloudV2VolumesPostOptions) SetAntiAffinityPvmInstances(antiAffinityPvmInstances []string) *PcloudV2VolumesPostOptions {
	_options.AntiAffinityPvmInstances = antiAffinityPvmInstances
	return _options
}

// SetAntiAffinityVolumes : Allow user to set AntiAffinityVolumes
func (_options *PcloudV2VolumesPostOptions) SetAntiAffinityVolumes(antiAffinityVolumes []string) *PcloudV2VolumesPostOptions {
	_options.AntiAffinityVolumes = antiAffinityVolumes
	return _options
}

// SetCount : Allow user to set Count
func (_options *PcloudV2VolumesPostOptions) SetCount(count int64) *PcloudV2VolumesPostOptions {
	_options.Count = core.Int64Ptr(count)
	return _options
}

// SetDiskType : Allow user to set DiskType
func (_options *PcloudV2VolumesPostOptions) SetDiskType(diskType string) *PcloudV2VolumesPostOptions {
	_options.DiskType = core.StringPtr(diskType)
	return _options
}

// SetReplicationEnabled : Allow user to set ReplicationEnabled
func (_options *PcloudV2VolumesPostOptions) SetReplicationEnabled(replicationEnabled bool) *PcloudV2VolumesPostOptions {
	_options.ReplicationEnabled = core.BoolPtr(replicationEnabled)
	return _options
}

// SetShareable : Allow user to set Shareable
func (_options *PcloudV2VolumesPostOptions) SetShareable(shareable bool) *PcloudV2VolumesPostOptions {
	_options.Shareable = core.BoolPtr(shareable)
	return _options
}

// SetVolumePool : Allow user to set VolumePool
func (_options *PcloudV2VolumesPostOptions) SetVolumePool(volumePool string) *PcloudV2VolumesPostOptions {
	_options.VolumePool = core.StringPtr(volumePool)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2VolumesPostOptions) SetHeaders(param map[string]string) *PcloudV2VolumesPostOptions {
	options.Headers = param
	return options
}

// PcloudV2VolumescloneCancelPostOptions : The PcloudV2VolumescloneCancelPost options.
type PcloudV2VolumescloneCancelPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Volumes Clone ID.
	VolumesCloneID *string `json:"volumes_clone_id" validate:"required,ne="`

	// default False, Cancel will only be allowed if the status is 'prepared', or 'available' True, Cancel will be allowed
	// when the status is NOT completed, cancelling, cancelled, or failed.
	Force *bool `json:"force,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudV2VolumescloneCancelPostOptions : Instantiate PcloudV2VolumescloneCancelPostOptions
func (*PowervsV1) NewPcloudV2VolumescloneCancelPostOptions(cloudInstanceID string, volumesCloneID string) *PcloudV2VolumescloneCancelPostOptions {
	return &PcloudV2VolumescloneCancelPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumesCloneID: core.StringPtr(volumesCloneID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2VolumescloneCancelPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2VolumescloneCancelPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumesCloneID : Allow user to set VolumesCloneID
func (_options *PcloudV2VolumescloneCancelPostOptions) SetVolumesCloneID(volumesCloneID string) *PcloudV2VolumescloneCancelPostOptions {
	_options.VolumesCloneID = core.StringPtr(volumesCloneID)
	return _options
}

// SetForce : Allow user to set Force
func (_options *PcloudV2VolumescloneCancelPostOptions) SetForce(force bool) *PcloudV2VolumescloneCancelPostOptions {
	_options.Force = core.BoolPtr(force)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2VolumescloneCancelPostOptions) SetHeaders(param map[string]string) *PcloudV2VolumescloneCancelPostOptions {
	options.Headers = param
	return options
}

// PcloudV2VolumescloneDeleteOptions : The PcloudV2VolumescloneDelete options.
type PcloudV2VolumescloneDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Volumes Clone ID.
	VolumesCloneID *string `json:"volumes_clone_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudV2VolumescloneDeleteOptions : Instantiate PcloudV2VolumescloneDeleteOptions
func (*PowervsV1) NewPcloudV2VolumescloneDeleteOptions(cloudInstanceID string, volumesCloneID string) *PcloudV2VolumescloneDeleteOptions {
	return &PcloudV2VolumescloneDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumesCloneID: core.StringPtr(volumesCloneID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2VolumescloneDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2VolumescloneDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumesCloneID : Allow user to set VolumesCloneID
func (_options *PcloudV2VolumescloneDeleteOptions) SetVolumesCloneID(volumesCloneID string) *PcloudV2VolumescloneDeleteOptions {
	_options.VolumesCloneID = core.StringPtr(volumesCloneID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2VolumescloneDeleteOptions) SetHeaders(param map[string]string) *PcloudV2VolumescloneDeleteOptions {
	options.Headers = param
	return options
}

// PcloudV2VolumescloneExecutePostOptions : The PcloudV2VolumescloneExecutePost options.
type PcloudV2VolumescloneExecutePostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Volumes Clone ID.
	VolumesCloneID *string `json:"volumes_clone_id" validate:"required,ne="`

	// Base name of the new cloned volume(s). Cloned Volume names will be prefixed with 'clone-'
	//     and suffixed with '-#####' (where ##### is a 5 digit random number) If multiple volumes cloned they will be
	// further suffixed with an incremental number starting with 1.
	//   Example volume names using name="volume-abcdef"
	//     single volume clone will be named "clone-volume-abcdef-83081"
	//     multi volume clone will be named "clone-volume-abcdef-73721-1", "clone-volume-abcdef-73721-2", ...
	Name *string `json:"name" validate:"required"`

	// default False, Execute failure rolls back clone activity but leaves prepared snapshot True, Execute failure rolls
	// back clone activity and removes the prepared snapshot.
	RollbackPrepare *bool `json:"rollbackPrepare,omitempty"`

	// Cloned volume will be non replication enabled if it is set to false. By default, the replication property of the
	// source volume will be used to determine the replication property of the cloned target volume.
	TargetReplicationEnabled *bool `json:"targetReplicationEnabled,omitempty"`

	// Target storage tier for the cloned volumes. Use to clone a set of volumes from one storage tier to a different
	// storage tier. Cloned volumes must remain in the same storage pool as the source volumes.
	TargetStorageTier *string `json:"targetStorageTier,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudV2VolumescloneExecutePostOptions : Instantiate PcloudV2VolumescloneExecutePostOptions
func (*PowervsV1) NewPcloudV2VolumescloneExecutePostOptions(cloudInstanceID string, volumesCloneID string, name string) *PcloudV2VolumescloneExecutePostOptions {
	return &PcloudV2VolumescloneExecutePostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumesCloneID: core.StringPtr(volumesCloneID),
		Name: core.StringPtr(name),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2VolumescloneExecutePostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2VolumescloneExecutePostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumesCloneID : Allow user to set VolumesCloneID
func (_options *PcloudV2VolumescloneExecutePostOptions) SetVolumesCloneID(volumesCloneID string) *PcloudV2VolumescloneExecutePostOptions {
	_options.VolumesCloneID = core.StringPtr(volumesCloneID)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudV2VolumescloneExecutePostOptions) SetName(name string) *PcloudV2VolumescloneExecutePostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetRollbackPrepare : Allow user to set RollbackPrepare
func (_options *PcloudV2VolumescloneExecutePostOptions) SetRollbackPrepare(rollbackPrepare bool) *PcloudV2VolumescloneExecutePostOptions {
	_options.RollbackPrepare = core.BoolPtr(rollbackPrepare)
	return _options
}

// SetTargetReplicationEnabled : Allow user to set TargetReplicationEnabled
func (_options *PcloudV2VolumescloneExecutePostOptions) SetTargetReplicationEnabled(targetReplicationEnabled bool) *PcloudV2VolumescloneExecutePostOptions {
	_options.TargetReplicationEnabled = core.BoolPtr(targetReplicationEnabled)
	return _options
}

// SetTargetStorageTier : Allow user to set TargetStorageTier
func (_options *PcloudV2VolumescloneExecutePostOptions) SetTargetStorageTier(targetStorageTier string) *PcloudV2VolumescloneExecutePostOptions {
	_options.TargetStorageTier = core.StringPtr(targetStorageTier)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2VolumescloneExecutePostOptions) SetHeaders(param map[string]string) *PcloudV2VolumescloneExecutePostOptions {
	options.Headers = param
	return options
}

// PcloudV2VolumescloneGetOptions : The PcloudV2VolumescloneGet options.
type PcloudV2VolumescloneGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Volumes Clone ID.
	VolumesCloneID *string `json:"volumes_clone_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudV2VolumescloneGetOptions : Instantiate PcloudV2VolumescloneGetOptions
func (*PowervsV1) NewPcloudV2VolumescloneGetOptions(cloudInstanceID string, volumesCloneID string) *PcloudV2VolumescloneGetOptions {
	return &PcloudV2VolumescloneGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumesCloneID: core.StringPtr(volumesCloneID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2VolumescloneGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2VolumescloneGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumesCloneID : Allow user to set VolumesCloneID
func (_options *PcloudV2VolumescloneGetOptions) SetVolumesCloneID(volumesCloneID string) *PcloudV2VolumescloneGetOptions {
	_options.VolumesCloneID = core.StringPtr(volumesCloneID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2VolumescloneGetOptions) SetHeaders(param map[string]string) *PcloudV2VolumescloneGetOptions {
	options.Headers = param
	return options
}

// PcloudV2VolumescloneGetallOptions : The PcloudV2VolumescloneGetall options.
type PcloudV2VolumescloneGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// volumes-clone filter to limit list items:
	//   prepare - includes status values (preparing, prepared)
	//   start   - includes status values (starting, available)
	//   execute - includes status values (executing, available-rollback)
	//   cancel  - includes status values (cancelling)
	//   completed - includes status values (completed)
	//   failed - includes status values (failed)
	//   cancelled - includes status values (cancelled)
	//   finalized - included status values (completed, failed, cancelled).
	Filter *string `json:"filter,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudV2VolumescloneGetallOptions.Filter property.
// volumes-clone filter to limit list items:
//   prepare - includes status values (preparing, prepared)
//   start   - includes status values (starting, available)
//   execute - includes status values (executing, available-rollback)
//   cancel  - includes status values (cancelling)
//   completed - includes status values (completed)
//   failed - includes status values (failed)
//   cancelled - includes status values (cancelled)
//   finalized - included status values (completed, failed, cancelled).
const (
	PcloudV2VolumescloneGetallOptionsFilterCancelConst = "cancel"
	PcloudV2VolumescloneGetallOptionsFilterCancelledConst = "cancelled"
	PcloudV2VolumescloneGetallOptionsFilterCompletedConst = "completed"
	PcloudV2VolumescloneGetallOptionsFilterExecuteConst = "execute"
	PcloudV2VolumescloneGetallOptionsFilterFailedConst = "failed"
	PcloudV2VolumescloneGetallOptionsFilterFinalizedConst = "finalized"
	PcloudV2VolumescloneGetallOptionsFilterPrepareConst = "prepare"
	PcloudV2VolumescloneGetallOptionsFilterStartConst = "start"
)

// NewPcloudV2VolumescloneGetallOptions : Instantiate PcloudV2VolumescloneGetallOptions
func (*PowervsV1) NewPcloudV2VolumescloneGetallOptions(cloudInstanceID string) *PcloudV2VolumescloneGetallOptions {
	return &PcloudV2VolumescloneGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2VolumescloneGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2VolumescloneGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetFilter : Allow user to set Filter
func (_options *PcloudV2VolumescloneGetallOptions) SetFilter(filter string) *PcloudV2VolumescloneGetallOptions {
	_options.Filter = core.StringPtr(filter)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2VolumescloneGetallOptions) SetHeaders(param map[string]string) *PcloudV2VolumescloneGetallOptions {
	options.Headers = param
	return options
}

// PcloudV2VolumesclonePostOptions : The PcloudV2VolumesclonePost options.
type PcloudV2VolumesclonePostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Unique name within a cloud instance used to identify a volumes-clone request name can be used in replace of a
	// volumesCloneID when used as a URL path parameter.
	Name *string `json:"name" validate:"required"`

	// List of volumes to be cloned.
	VolumeIDs []string `json:"volumeIDs" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudV2VolumesclonePostOptions : Instantiate PcloudV2VolumesclonePostOptions
func (*PowervsV1) NewPcloudV2VolumesclonePostOptions(cloudInstanceID string, name string, volumeIDs []string) *PcloudV2VolumesclonePostOptions {
	return &PcloudV2VolumesclonePostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		Name: core.StringPtr(name),
		VolumeIDs: volumeIDs,
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2VolumesclonePostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2VolumesclonePostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudV2VolumesclonePostOptions) SetName(name string) *PcloudV2VolumesclonePostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetVolumeIDs : Allow user to set VolumeIDs
func (_options *PcloudV2VolumesclonePostOptions) SetVolumeIDs(volumeIDs []string) *PcloudV2VolumesclonePostOptions {
	_options.VolumeIDs = volumeIDs
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2VolumesclonePostOptions) SetHeaders(param map[string]string) *PcloudV2VolumesclonePostOptions {
	options.Headers = param
	return options
}

// PcloudV2VolumescloneStartPostOptions : The PcloudV2VolumescloneStartPost options.
type PcloudV2VolumescloneStartPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Volumes Clone ID.
	VolumesCloneID *string `json:"volumes_clone_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudV2VolumescloneStartPostOptions : Instantiate PcloudV2VolumescloneStartPostOptions
func (*PowervsV1) NewPcloudV2VolumescloneStartPostOptions(cloudInstanceID string, volumesCloneID string) *PcloudV2VolumescloneStartPostOptions {
	return &PcloudV2VolumescloneStartPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumesCloneID: core.StringPtr(volumesCloneID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudV2VolumescloneStartPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudV2VolumescloneStartPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumesCloneID : Allow user to set VolumesCloneID
func (_options *PcloudV2VolumescloneStartPostOptions) SetVolumesCloneID(volumesCloneID string) *PcloudV2VolumescloneStartPostOptions {
	_options.VolumesCloneID = core.StringPtr(volumesCloneID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudV2VolumescloneStartPostOptions) SetHeaders(param map[string]string) *PcloudV2VolumescloneStartPostOptions {
	options.Headers = param
	return options
}

// PcloudVolumeOnboardingGetOptions : The PcloudVolumeOnboardingGet options.
type PcloudVolumeOnboardingGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Indicates volume onboarding operation id.
	VolumeOnboardingID *string `json:"volume_onboarding_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVolumeOnboardingGetOptions : Instantiate PcloudVolumeOnboardingGetOptions
func (*PowervsV1) NewPcloudVolumeOnboardingGetOptions(cloudInstanceID string, volumeOnboardingID string) *PcloudVolumeOnboardingGetOptions {
	return &PcloudVolumeOnboardingGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumeOnboardingID: core.StringPtr(volumeOnboardingID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVolumeOnboardingGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVolumeOnboardingGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumeOnboardingID : Allow user to set VolumeOnboardingID
func (_options *PcloudVolumeOnboardingGetOptions) SetVolumeOnboardingID(volumeOnboardingID string) *PcloudVolumeOnboardingGetOptions {
	_options.VolumeOnboardingID = core.StringPtr(volumeOnboardingID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVolumeOnboardingGetOptions) SetHeaders(param map[string]string) *PcloudVolumeOnboardingGetOptions {
	options.Headers = param
	return options
}

// PcloudVolumeOnboardingGetallOptions : The PcloudVolumeOnboardingGetall options.
type PcloudVolumeOnboardingGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVolumeOnboardingGetallOptions : Instantiate PcloudVolumeOnboardingGetallOptions
func (*PowervsV1) NewPcloudVolumeOnboardingGetallOptions(cloudInstanceID string) *PcloudVolumeOnboardingGetallOptions {
	return &PcloudVolumeOnboardingGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVolumeOnboardingGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVolumeOnboardingGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVolumeOnboardingGetallOptions) SetHeaders(param map[string]string) *PcloudVolumeOnboardingGetallOptions {
	options.Headers = param
	return options
}

// PcloudVolumeOnboardingPostOptions : The PcloudVolumeOnboardingPost options.
type PcloudVolumeOnboardingPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	Volumes []AuxiliaryVolumesForOnboarding `json:"Volumes" validate:"required"`

	// Description of the volume onboarding operation.
	Description *string `json:"description,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVolumeOnboardingPostOptions : Instantiate PcloudVolumeOnboardingPostOptions
func (*PowervsV1) NewPcloudVolumeOnboardingPostOptions(cloudInstanceID string, volumes []AuxiliaryVolumesForOnboarding) *PcloudVolumeOnboardingPostOptions {
	return &PcloudVolumeOnboardingPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		Volumes: volumes,
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVolumeOnboardingPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVolumeOnboardingPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumes : Allow user to set Volumes
func (_options *PcloudVolumeOnboardingPostOptions) SetVolumes(volumes []AuxiliaryVolumesForOnboarding) *PcloudVolumeOnboardingPostOptions {
	_options.Volumes = volumes
	return _options
}

// SetDescription : Allow user to set Description
func (_options *PcloudVolumeOnboardingPostOptions) SetDescription(description string) *PcloudVolumeOnboardingPostOptions {
	_options.Description = core.StringPtr(description)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVolumeOnboardingPostOptions) SetHeaders(param map[string]string) *PcloudVolumeOnboardingPostOptions {
	options.Headers = param
	return options
}

// PcloudVolumegroupsActionPostOptions : The PcloudVolumegroupsActionPost options.
type PcloudVolumegroupsActionPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// The ID of the volume group.
	VolumeGroupID *string `json:"volume_group_id" validate:"required,ne="`

	// Parameters for the desire action.
	Body *VolumeGroupAction `json:"body" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVolumegroupsActionPostOptions : Instantiate PcloudVolumegroupsActionPostOptions
func (*PowervsV1) NewPcloudVolumegroupsActionPostOptions(cloudInstanceID string, volumeGroupID string, body *VolumeGroupAction) *PcloudVolumegroupsActionPostOptions {
	return &PcloudVolumegroupsActionPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumeGroupID: core.StringPtr(volumeGroupID),
		Body: body,
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVolumegroupsActionPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVolumegroupsActionPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumeGroupID : Allow user to set VolumeGroupID
func (_options *PcloudVolumegroupsActionPostOptions) SetVolumeGroupID(volumeGroupID string) *PcloudVolumegroupsActionPostOptions {
	_options.VolumeGroupID = core.StringPtr(volumeGroupID)
	return _options
}

// SetBody : Allow user to set Body
func (_options *PcloudVolumegroupsActionPostOptions) SetBody(body *VolumeGroupAction) *PcloudVolumegroupsActionPostOptions {
	_options.Body = body
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVolumegroupsActionPostOptions) SetHeaders(param map[string]string) *PcloudVolumegroupsActionPostOptions {
	options.Headers = param
	return options
}

// PcloudVolumegroupsDeleteOptions : The PcloudVolumegroupsDelete options.
type PcloudVolumegroupsDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// The ID of the volume group.
	VolumeGroupID *string `json:"volume_group_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVolumegroupsDeleteOptions : Instantiate PcloudVolumegroupsDeleteOptions
func (*PowervsV1) NewPcloudVolumegroupsDeleteOptions(cloudInstanceID string, volumeGroupID string) *PcloudVolumegroupsDeleteOptions {
	return &PcloudVolumegroupsDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumeGroupID: core.StringPtr(volumeGroupID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVolumegroupsDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVolumegroupsDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumeGroupID : Allow user to set VolumeGroupID
func (_options *PcloudVolumegroupsDeleteOptions) SetVolumeGroupID(volumeGroupID string) *PcloudVolumegroupsDeleteOptions {
	_options.VolumeGroupID = core.StringPtr(volumeGroupID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVolumegroupsDeleteOptions) SetHeaders(param map[string]string) *PcloudVolumegroupsDeleteOptions {
	options.Headers = param
	return options
}

// PcloudVolumegroupsGetDetailsOptions : The PcloudVolumegroupsGetDetails options.
type PcloudVolumegroupsGetDetailsOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// The ID of the volume group.
	VolumeGroupID *string `json:"volume_group_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVolumegroupsGetDetailsOptions : Instantiate PcloudVolumegroupsGetDetailsOptions
func (*PowervsV1) NewPcloudVolumegroupsGetDetailsOptions(cloudInstanceID string, volumeGroupID string) *PcloudVolumegroupsGetDetailsOptions {
	return &PcloudVolumegroupsGetDetailsOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumeGroupID: core.StringPtr(volumeGroupID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVolumegroupsGetDetailsOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVolumegroupsGetDetailsOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumeGroupID : Allow user to set VolumeGroupID
func (_options *PcloudVolumegroupsGetDetailsOptions) SetVolumeGroupID(volumeGroupID string) *PcloudVolumegroupsGetDetailsOptions {
	_options.VolumeGroupID = core.StringPtr(volumeGroupID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVolumegroupsGetDetailsOptions) SetHeaders(param map[string]string) *PcloudVolumegroupsGetDetailsOptions {
	options.Headers = param
	return options
}

// PcloudVolumegroupsGetOptions : The PcloudVolumegroupsGet options.
type PcloudVolumegroupsGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// The ID of the volume group.
	VolumeGroupID *string `json:"volume_group_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVolumegroupsGetOptions : Instantiate PcloudVolumegroupsGetOptions
func (*PowervsV1) NewPcloudVolumegroupsGetOptions(cloudInstanceID string, volumeGroupID string) *PcloudVolumegroupsGetOptions {
	return &PcloudVolumegroupsGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumeGroupID: core.StringPtr(volumeGroupID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVolumegroupsGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVolumegroupsGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumeGroupID : Allow user to set VolumeGroupID
func (_options *PcloudVolumegroupsGetOptions) SetVolumeGroupID(volumeGroupID string) *PcloudVolumegroupsGetOptions {
	_options.VolumeGroupID = core.StringPtr(volumeGroupID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVolumegroupsGetOptions) SetHeaders(param map[string]string) *PcloudVolumegroupsGetOptions {
	options.Headers = param
	return options
}

// PcloudVolumegroupsGetallDetailsOptions : The PcloudVolumegroupsGetallDetails options.
type PcloudVolumegroupsGetallDetailsOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVolumegroupsGetallDetailsOptions : Instantiate PcloudVolumegroupsGetallDetailsOptions
func (*PowervsV1) NewPcloudVolumegroupsGetallDetailsOptions(cloudInstanceID string) *PcloudVolumegroupsGetallDetailsOptions {
	return &PcloudVolumegroupsGetallDetailsOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVolumegroupsGetallDetailsOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVolumegroupsGetallDetailsOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVolumegroupsGetallDetailsOptions) SetHeaders(param map[string]string) *PcloudVolumegroupsGetallDetailsOptions {
	options.Headers = param
	return options
}

// PcloudVolumegroupsGetallOptions : The PcloudVolumegroupsGetall options.
type PcloudVolumegroupsGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVolumegroupsGetallOptions : Instantiate PcloudVolumegroupsGetallOptions
func (*PowervsV1) NewPcloudVolumegroupsGetallOptions(cloudInstanceID string) *PcloudVolumegroupsGetallOptions {
	return &PcloudVolumegroupsGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVolumegroupsGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVolumegroupsGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVolumegroupsGetallOptions) SetHeaders(param map[string]string) *PcloudVolumegroupsGetallOptions {
	options.Headers = param
	return options
}

// PcloudVolumegroupsPostOptions : The PcloudVolumegroupsPost options.
type PcloudVolumegroupsPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// List of volume IDs,members of VolumeGroup.
	VolumeIDs []string `json:"volumeIDs" validate:"required"`

	// The name of consistencyGroup at storage controller level. This is required to onboard existing volume group on the
	// target site for DR set up; name and consistencyGroupName are mutually exclusive.
	ConsistencyGroupName *string `json:"consistencyGroupName,omitempty"`

	// The name of the volume group. This field is required for creation of new volume group; name and consistencyGroupName
	// are mutually exclusive.
	Name *string `json:"name,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVolumegroupsPostOptions : Instantiate PcloudVolumegroupsPostOptions
func (*PowervsV1) NewPcloudVolumegroupsPostOptions(cloudInstanceID string, volumeIDs []string) *PcloudVolumegroupsPostOptions {
	return &PcloudVolumegroupsPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumeIDs: volumeIDs,
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVolumegroupsPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVolumegroupsPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumeIDs : Allow user to set VolumeIDs
func (_options *PcloudVolumegroupsPostOptions) SetVolumeIDs(volumeIDs []string) *PcloudVolumegroupsPostOptions {
	_options.VolumeIDs = volumeIDs
	return _options
}

// SetConsistencyGroupName : Allow user to set ConsistencyGroupName
func (_options *PcloudVolumegroupsPostOptions) SetConsistencyGroupName(consistencyGroupName string) *PcloudVolumegroupsPostOptions {
	_options.ConsistencyGroupName = core.StringPtr(consistencyGroupName)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudVolumegroupsPostOptions) SetName(name string) *PcloudVolumegroupsPostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVolumegroupsPostOptions) SetHeaders(param map[string]string) *PcloudVolumegroupsPostOptions {
	options.Headers = param
	return options
}

// PcloudVolumegroupsPutOptions : The PcloudVolumegroupsPut options.
type PcloudVolumegroupsPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// The ID of the volume group.
	VolumeGroupID *string `json:"volume_group_id" validate:"required,ne="`

	// List of volume IDs to add to the volume-group.
	AddVolumes []string `json:"addVolumes,omitempty"`

	// List of volume IDs to remove from the volume-group.
	RemoveVolumes []string `json:"removeVolumes,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVolumegroupsPutOptions : Instantiate PcloudVolumegroupsPutOptions
func (*PowervsV1) NewPcloudVolumegroupsPutOptions(cloudInstanceID string, volumeGroupID string) *PcloudVolumegroupsPutOptions {
	return &PcloudVolumegroupsPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumeGroupID: core.StringPtr(volumeGroupID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVolumegroupsPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVolumegroupsPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumeGroupID : Allow user to set VolumeGroupID
func (_options *PcloudVolumegroupsPutOptions) SetVolumeGroupID(volumeGroupID string) *PcloudVolumegroupsPutOptions {
	_options.VolumeGroupID = core.StringPtr(volumeGroupID)
	return _options
}

// SetAddVolumes : Allow user to set AddVolumes
func (_options *PcloudVolumegroupsPutOptions) SetAddVolumes(addVolumes []string) *PcloudVolumegroupsPutOptions {
	_options.AddVolumes = addVolumes
	return _options
}

// SetRemoveVolumes : Allow user to set RemoveVolumes
func (_options *PcloudVolumegroupsPutOptions) SetRemoveVolumes(removeVolumes []string) *PcloudVolumegroupsPutOptions {
	_options.RemoveVolumes = removeVolumes
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVolumegroupsPutOptions) SetHeaders(param map[string]string) *PcloudVolumegroupsPutOptions {
	options.Headers = param
	return options
}

// PcloudVolumegroupsRemoteCopyRelationshipsGetOptions : The PcloudVolumegroupsRemoteCopyRelationshipsGet options.
type PcloudVolumegroupsRemoteCopyRelationshipsGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// The ID of the volume group.
	VolumeGroupID *string `json:"volume_group_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVolumegroupsRemoteCopyRelationshipsGetOptions : Instantiate PcloudVolumegroupsRemoteCopyRelationshipsGetOptions
func (*PowervsV1) NewPcloudVolumegroupsRemoteCopyRelationshipsGetOptions(cloudInstanceID string, volumeGroupID string) *PcloudVolumegroupsRemoteCopyRelationshipsGetOptions {
	return &PcloudVolumegroupsRemoteCopyRelationshipsGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumeGroupID: core.StringPtr(volumeGroupID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVolumegroupsRemoteCopyRelationshipsGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVolumegroupsRemoteCopyRelationshipsGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumeGroupID : Allow user to set VolumeGroupID
func (_options *PcloudVolumegroupsRemoteCopyRelationshipsGetOptions) SetVolumeGroupID(volumeGroupID string) *PcloudVolumegroupsRemoteCopyRelationshipsGetOptions {
	_options.VolumeGroupID = core.StringPtr(volumeGroupID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVolumegroupsRemoteCopyRelationshipsGetOptions) SetHeaders(param map[string]string) *PcloudVolumegroupsRemoteCopyRelationshipsGetOptions {
	options.Headers = param
	return options
}

// PcloudVolumegroupsStorageDetailsGetOptions : The PcloudVolumegroupsStorageDetailsGet options.
type PcloudVolumegroupsStorageDetailsGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// The ID of the volume group.
	VolumeGroupID *string `json:"volume_group_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVolumegroupsStorageDetailsGetOptions : Instantiate PcloudVolumegroupsStorageDetailsGetOptions
func (*PowervsV1) NewPcloudVolumegroupsStorageDetailsGetOptions(cloudInstanceID string, volumeGroupID string) *PcloudVolumegroupsStorageDetailsGetOptions {
	return &PcloudVolumegroupsStorageDetailsGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VolumeGroupID: core.StringPtr(volumeGroupID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVolumegroupsStorageDetailsGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVolumegroupsStorageDetailsGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVolumeGroupID : Allow user to set VolumeGroupID
func (_options *PcloudVolumegroupsStorageDetailsGetOptions) SetVolumeGroupID(volumeGroupID string) *PcloudVolumegroupsStorageDetailsGetOptions {
	_options.VolumeGroupID = core.StringPtr(volumeGroupID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVolumegroupsStorageDetailsGetOptions) SetHeaders(param map[string]string) *PcloudVolumegroupsStorageDetailsGetOptions {
	options.Headers = param
	return options
}

// PcloudVolumesClonePostOptions : The PcloudVolumesClonePost options.
type PcloudVolumesClonePostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Display name for the new cloned volumes. Cloned Volume names will be prefixed with 'clone-'. If multiple volumes
	// cloned they will be suffix with a '-' and an incremental number starting with 1.
	//   Example volume names using displayName="volume-abcdef"
	//     single volume clone will be named "clone-volume-abcdef"
	//     multi volume clone will be named "clone-volume-abcdef-1", "clone-volume-abcdef-2", ...
	DisplayName *string `json:"displayName" validate:"required"`

	// List of volumes to be cloned.
	VolumeIDs []string `json:"volumeIDs" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVolumesClonePostOptions : Instantiate PcloudVolumesClonePostOptions
func (*PowervsV1) NewPcloudVolumesClonePostOptions(cloudInstanceID string, displayName string, volumeIDs []string) *PcloudVolumesClonePostOptions {
	return &PcloudVolumesClonePostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		DisplayName: core.StringPtr(displayName),
		VolumeIDs: volumeIDs,
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVolumesClonePostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVolumesClonePostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetDisplayName : Allow user to set DisplayName
func (_options *PcloudVolumesClonePostOptions) SetDisplayName(displayName string) *PcloudVolumesClonePostOptions {
	_options.DisplayName = core.StringPtr(displayName)
	return _options
}

// SetVolumeIDs : Allow user to set VolumeIDs
func (_options *PcloudVolumesClonePostOptions) SetVolumeIDs(volumeIDs []string) *PcloudVolumesClonePostOptions {
	_options.VolumeIDs = volumeIDs
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVolumesClonePostOptions) SetHeaders(param map[string]string) *PcloudVolumesClonePostOptions {
	options.Headers = param
	return options
}

// PcloudVpnconnectionsDeleteOptions : The PcloudVpnconnectionsDelete options.
type PcloudVpnconnectionsDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// ID of a VPN connection.
	VPNConnectionID *string `json:"vpn_connection_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVpnconnectionsDeleteOptions : Instantiate PcloudVpnconnectionsDeleteOptions
func (*PowervsV1) NewPcloudVpnconnectionsDeleteOptions(cloudInstanceID string, vpnConnectionID string) *PcloudVpnconnectionsDeleteOptions {
	return &PcloudVpnconnectionsDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VPNConnectionID: core.StringPtr(vpnConnectionID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVpnconnectionsDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVpnconnectionsDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVPNConnectionID : Allow user to set VPNConnectionID
func (_options *PcloudVpnconnectionsDeleteOptions) SetVPNConnectionID(vpnConnectionID string) *PcloudVpnconnectionsDeleteOptions {
	_options.VPNConnectionID = core.StringPtr(vpnConnectionID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVpnconnectionsDeleteOptions) SetHeaders(param map[string]string) *PcloudVpnconnectionsDeleteOptions {
	options.Headers = param
	return options
}

// PcloudVpnconnectionsGetOptions : The PcloudVpnconnectionsGet options.
type PcloudVpnconnectionsGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// ID of a VPN connection.
	VPNConnectionID *string `json:"vpn_connection_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVpnconnectionsGetOptions : Instantiate PcloudVpnconnectionsGetOptions
func (*PowervsV1) NewPcloudVpnconnectionsGetOptions(cloudInstanceID string, vpnConnectionID string) *PcloudVpnconnectionsGetOptions {
	return &PcloudVpnconnectionsGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VPNConnectionID: core.StringPtr(vpnConnectionID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVpnconnectionsGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVpnconnectionsGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVPNConnectionID : Allow user to set VPNConnectionID
func (_options *PcloudVpnconnectionsGetOptions) SetVPNConnectionID(vpnConnectionID string) *PcloudVpnconnectionsGetOptions {
	_options.VPNConnectionID = core.StringPtr(vpnConnectionID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVpnconnectionsGetOptions) SetHeaders(param map[string]string) *PcloudVpnconnectionsGetOptions {
	options.Headers = param
	return options
}

// PcloudVpnconnectionsGetallOptions : The PcloudVpnconnectionsGetall options.
type PcloudVpnconnectionsGetallOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVpnconnectionsGetallOptions : Instantiate PcloudVpnconnectionsGetallOptions
func (*PowervsV1) NewPcloudVpnconnectionsGetallOptions(cloudInstanceID string) *PcloudVpnconnectionsGetallOptions {
	return &PcloudVpnconnectionsGetallOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVpnconnectionsGetallOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVpnconnectionsGetallOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVpnconnectionsGetallOptions) SetHeaders(param map[string]string) *PcloudVpnconnectionsGetallOptions {
	options.Headers = param
	return options
}

// PcloudVpnconnectionsNetworksDeleteOptions : The PcloudVpnconnectionsNetworksDelete options.
type PcloudVpnconnectionsNetworksDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// ID of a VPN connection.
	VPNConnectionID *string `json:"vpn_connection_id" validate:"required,ne="`

	NetworkID *string `json:"networkID" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVpnconnectionsNetworksDeleteOptions : Instantiate PcloudVpnconnectionsNetworksDeleteOptions
func (*PowervsV1) NewPcloudVpnconnectionsNetworksDeleteOptions(cloudInstanceID string, vpnConnectionID string, networkID string) *PcloudVpnconnectionsNetworksDeleteOptions {
	return &PcloudVpnconnectionsNetworksDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VPNConnectionID: core.StringPtr(vpnConnectionID),
		NetworkID: core.StringPtr(networkID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVpnconnectionsNetworksDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVpnconnectionsNetworksDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVPNConnectionID : Allow user to set VPNConnectionID
func (_options *PcloudVpnconnectionsNetworksDeleteOptions) SetVPNConnectionID(vpnConnectionID string) *PcloudVpnconnectionsNetworksDeleteOptions {
	_options.VPNConnectionID = core.StringPtr(vpnConnectionID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *PcloudVpnconnectionsNetworksDeleteOptions) SetNetworkID(networkID string) *PcloudVpnconnectionsNetworksDeleteOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVpnconnectionsNetworksDeleteOptions) SetHeaders(param map[string]string) *PcloudVpnconnectionsNetworksDeleteOptions {
	options.Headers = param
	return options
}

// PcloudVpnconnectionsNetworksGetOptions : The PcloudVpnconnectionsNetworksGet options.
type PcloudVpnconnectionsNetworksGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// ID of a VPN connection.
	VPNConnectionID *string `json:"vpn_connection_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVpnconnectionsNetworksGetOptions : Instantiate PcloudVpnconnectionsNetworksGetOptions
func (*PowervsV1) NewPcloudVpnconnectionsNetworksGetOptions(cloudInstanceID string, vpnConnectionID string) *PcloudVpnconnectionsNetworksGetOptions {
	return &PcloudVpnconnectionsNetworksGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VPNConnectionID: core.StringPtr(vpnConnectionID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVpnconnectionsNetworksGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVpnconnectionsNetworksGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVPNConnectionID : Allow user to set VPNConnectionID
func (_options *PcloudVpnconnectionsNetworksGetOptions) SetVPNConnectionID(vpnConnectionID string) *PcloudVpnconnectionsNetworksGetOptions {
	_options.VPNConnectionID = core.StringPtr(vpnConnectionID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVpnconnectionsNetworksGetOptions) SetHeaders(param map[string]string) *PcloudVpnconnectionsNetworksGetOptions {
	options.Headers = param
	return options
}

// PcloudVpnconnectionsNetworksPutOptions : The PcloudVpnconnectionsNetworksPut options.
type PcloudVpnconnectionsNetworksPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// ID of a VPN connection.
	VPNConnectionID *string `json:"vpn_connection_id" validate:"required,ne="`

	NetworkID *string `json:"networkID" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVpnconnectionsNetworksPutOptions : Instantiate PcloudVpnconnectionsNetworksPutOptions
func (*PowervsV1) NewPcloudVpnconnectionsNetworksPutOptions(cloudInstanceID string, vpnConnectionID string, networkID string) *PcloudVpnconnectionsNetworksPutOptions {
	return &PcloudVpnconnectionsNetworksPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VPNConnectionID: core.StringPtr(vpnConnectionID),
		NetworkID: core.StringPtr(networkID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVpnconnectionsNetworksPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVpnconnectionsNetworksPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVPNConnectionID : Allow user to set VPNConnectionID
func (_options *PcloudVpnconnectionsNetworksPutOptions) SetVPNConnectionID(vpnConnectionID string) *PcloudVpnconnectionsNetworksPutOptions {
	_options.VPNConnectionID = core.StringPtr(vpnConnectionID)
	return _options
}

// SetNetworkID : Allow user to set NetworkID
func (_options *PcloudVpnconnectionsNetworksPutOptions) SetNetworkID(networkID string) *PcloudVpnconnectionsNetworksPutOptions {
	_options.NetworkID = core.StringPtr(networkID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVpnconnectionsNetworksPutOptions) SetHeaders(param map[string]string) *PcloudVpnconnectionsNetworksPutOptions {
	options.Headers = param
	return options
}

// PcloudVpnconnectionsPeersubnetsDeleteOptions : The PcloudVpnconnectionsPeersubnetsDelete options.
type PcloudVpnconnectionsPeersubnetsDeleteOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// ID of a VPN connection.
	VPNConnectionID *string `json:"vpn_connection_id" validate:"required,ne="`

	CIDR *string `json:"cidr" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVpnconnectionsPeersubnetsDeleteOptions : Instantiate PcloudVpnconnectionsPeersubnetsDeleteOptions
func (*PowervsV1) NewPcloudVpnconnectionsPeersubnetsDeleteOptions(cloudInstanceID string, vpnConnectionID string, cidr string) *PcloudVpnconnectionsPeersubnetsDeleteOptions {
	return &PcloudVpnconnectionsPeersubnetsDeleteOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VPNConnectionID: core.StringPtr(vpnConnectionID),
		CIDR: core.StringPtr(cidr),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVpnconnectionsPeersubnetsDeleteOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVpnconnectionsPeersubnetsDeleteOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVPNConnectionID : Allow user to set VPNConnectionID
func (_options *PcloudVpnconnectionsPeersubnetsDeleteOptions) SetVPNConnectionID(vpnConnectionID string) *PcloudVpnconnectionsPeersubnetsDeleteOptions {
	_options.VPNConnectionID = core.StringPtr(vpnConnectionID)
	return _options
}

// SetCIDR : Allow user to set CIDR
func (_options *PcloudVpnconnectionsPeersubnetsDeleteOptions) SetCIDR(cidr string) *PcloudVpnconnectionsPeersubnetsDeleteOptions {
	_options.CIDR = core.StringPtr(cidr)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVpnconnectionsPeersubnetsDeleteOptions) SetHeaders(param map[string]string) *PcloudVpnconnectionsPeersubnetsDeleteOptions {
	options.Headers = param
	return options
}

// PcloudVpnconnectionsPeersubnetsGetOptions : The PcloudVpnconnectionsPeersubnetsGet options.
type PcloudVpnconnectionsPeersubnetsGetOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// ID of a VPN connection.
	VPNConnectionID *string `json:"vpn_connection_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVpnconnectionsPeersubnetsGetOptions : Instantiate PcloudVpnconnectionsPeersubnetsGetOptions
func (*PowervsV1) NewPcloudVpnconnectionsPeersubnetsGetOptions(cloudInstanceID string, vpnConnectionID string) *PcloudVpnconnectionsPeersubnetsGetOptions {
	return &PcloudVpnconnectionsPeersubnetsGetOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VPNConnectionID: core.StringPtr(vpnConnectionID),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVpnconnectionsPeersubnetsGetOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVpnconnectionsPeersubnetsGetOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVPNConnectionID : Allow user to set VPNConnectionID
func (_options *PcloudVpnconnectionsPeersubnetsGetOptions) SetVPNConnectionID(vpnConnectionID string) *PcloudVpnconnectionsPeersubnetsGetOptions {
	_options.VPNConnectionID = core.StringPtr(vpnConnectionID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVpnconnectionsPeersubnetsGetOptions) SetHeaders(param map[string]string) *PcloudVpnconnectionsPeersubnetsGetOptions {
	options.Headers = param
	return options
}

// PcloudVpnconnectionsPeersubnetsPutOptions : The PcloudVpnconnectionsPeersubnetsPut options.
type PcloudVpnconnectionsPeersubnetsPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// ID of a VPN connection.
	VPNConnectionID *string `json:"vpn_connection_id" validate:"required,ne="`

	CIDR *string `json:"cidr" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVpnconnectionsPeersubnetsPutOptions : Instantiate PcloudVpnconnectionsPeersubnetsPutOptions
func (*PowervsV1) NewPcloudVpnconnectionsPeersubnetsPutOptions(cloudInstanceID string, vpnConnectionID string, cidr string) *PcloudVpnconnectionsPeersubnetsPutOptions {
	return &PcloudVpnconnectionsPeersubnetsPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VPNConnectionID: core.StringPtr(vpnConnectionID),
		CIDR: core.StringPtr(cidr),
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVpnconnectionsPeersubnetsPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVpnconnectionsPeersubnetsPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVPNConnectionID : Allow user to set VPNConnectionID
func (_options *PcloudVpnconnectionsPeersubnetsPutOptions) SetVPNConnectionID(vpnConnectionID string) *PcloudVpnconnectionsPeersubnetsPutOptions {
	_options.VPNConnectionID = core.StringPtr(vpnConnectionID)
	return _options
}

// SetCIDR : Allow user to set CIDR
func (_options *PcloudVpnconnectionsPeersubnetsPutOptions) SetCIDR(cidr string) *PcloudVpnconnectionsPeersubnetsPutOptions {
	_options.CIDR = core.StringPtr(cidr)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVpnconnectionsPeersubnetsPutOptions) SetHeaders(param map[string]string) *PcloudVpnconnectionsPeersubnetsPutOptions {
	options.Headers = param
	return options
}

// PcloudVpnconnectionsPostOptions : The PcloudVpnconnectionsPost options.
type PcloudVpnconnectionsPostOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// unique identifier of IKEPolicy selected for this VPNConnection.
	IkePolicy *string `json:"ikePolicy" validate:"required"`

	// unique identifier of IPSecPolicy selected for this VPNConnection.
	IPSecPolicy *string `json:"ipSecPolicy" validate:"required"`

	// Mode used by this VPNConnection, either policy-based, or route-based, this attribute is set at the creation and
	// cannot be updated later.
	Mode *string `json:"mode" validate:"required"`

	// VPN Connection name.
	Name *string `json:"name" validate:"required"`

	// an array of network IDs to attach to this VPNConnection.
	Networks []string `json:"networks" validate:"required"`

	// IP address of the Peer Gateway attached to this VPNConnection.
	PeerGatewayAddress *string `json:"peerGatewayAddress" validate:"required"`

	// an array of strings containing CIDR of peer subnets.
	PeerSubnets []string `json:"peerSubnets" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the PcloudVpnconnectionsPostOptions.Mode property.
// Mode used by this VPNConnection, either policy-based, or route-based, this attribute is set at the creation and
// cannot be updated later.
const (
	PcloudVpnconnectionsPostOptionsModePolicyConst = "policy"
	PcloudVpnconnectionsPostOptionsModeRouteConst = "route"
)

// NewPcloudVpnconnectionsPostOptions : Instantiate PcloudVpnconnectionsPostOptions
func (*PowervsV1) NewPcloudVpnconnectionsPostOptions(cloudInstanceID string, ikePolicy string, ipSecPolicy string, mode string, name string, networks []string, peerGatewayAddress string, peerSubnets []string) *PcloudVpnconnectionsPostOptions {
	return &PcloudVpnconnectionsPostOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		IkePolicy: core.StringPtr(ikePolicy),
		IPSecPolicy: core.StringPtr(ipSecPolicy),
		Mode: core.StringPtr(mode),
		Name: core.StringPtr(name),
		Networks: networks,
		PeerGatewayAddress: core.StringPtr(peerGatewayAddress),
		PeerSubnets: peerSubnets,
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVpnconnectionsPostOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVpnconnectionsPostOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetIkePolicy : Allow user to set IkePolicy
func (_options *PcloudVpnconnectionsPostOptions) SetIkePolicy(ikePolicy string) *PcloudVpnconnectionsPostOptions {
	_options.IkePolicy = core.StringPtr(ikePolicy)
	return _options
}

// SetIPSecPolicy : Allow user to set IPSecPolicy
func (_options *PcloudVpnconnectionsPostOptions) SetIPSecPolicy(ipSecPolicy string) *PcloudVpnconnectionsPostOptions {
	_options.IPSecPolicy = core.StringPtr(ipSecPolicy)
	return _options
}

// SetMode : Allow user to set Mode
func (_options *PcloudVpnconnectionsPostOptions) SetMode(mode string) *PcloudVpnconnectionsPostOptions {
	_options.Mode = core.StringPtr(mode)
	return _options
}

// SetName : Allow user to set Name
func (_options *PcloudVpnconnectionsPostOptions) SetName(name string) *PcloudVpnconnectionsPostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetNetworks : Allow user to set Networks
func (_options *PcloudVpnconnectionsPostOptions) SetNetworks(networks []string) *PcloudVpnconnectionsPostOptions {
	_options.Networks = networks
	return _options
}

// SetPeerGatewayAddress : Allow user to set PeerGatewayAddress
func (_options *PcloudVpnconnectionsPostOptions) SetPeerGatewayAddress(peerGatewayAddress string) *PcloudVpnconnectionsPostOptions {
	_options.PeerGatewayAddress = core.StringPtr(peerGatewayAddress)
	return _options
}

// SetPeerSubnets : Allow user to set PeerSubnets
func (_options *PcloudVpnconnectionsPostOptions) SetPeerSubnets(peerSubnets []string) *PcloudVpnconnectionsPostOptions {
	_options.PeerSubnets = peerSubnets
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVpnconnectionsPostOptions) SetHeaders(param map[string]string) *PcloudVpnconnectionsPostOptions {
	options.Headers = param
	return options
}

// PcloudVpnconnectionsPutOptions : The PcloudVpnconnectionsPut options.
type PcloudVpnconnectionsPutOptions struct {
	// Cloud Instance ID of a PCloud Instance.
	CloudInstanceID *string `json:"cloud_instance_id" validate:"required,ne="`

	// ID of a VPN connection.
	VPNConnectionID *string `json:"vpn_connection_id" validate:"required,ne="`

	// VPN Connection object used for update.
	Body *VPNConnectionUpdate `json:"body" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewPcloudVpnconnectionsPutOptions : Instantiate PcloudVpnconnectionsPutOptions
func (*PowervsV1) NewPcloudVpnconnectionsPutOptions(cloudInstanceID string, vpnConnectionID string, body *VPNConnectionUpdate) *PcloudVpnconnectionsPutOptions {
	return &PcloudVpnconnectionsPutOptions{
		CloudInstanceID: core.StringPtr(cloudInstanceID),
		VPNConnectionID: core.StringPtr(vpnConnectionID),
		Body: body,
	}
}

// SetCloudInstanceID : Allow user to set CloudInstanceID
func (_options *PcloudVpnconnectionsPutOptions) SetCloudInstanceID(cloudInstanceID string) *PcloudVpnconnectionsPutOptions {
	_options.CloudInstanceID = core.StringPtr(cloudInstanceID)
	return _options
}

// SetVPNConnectionID : Allow user to set VPNConnectionID
func (_options *PcloudVpnconnectionsPutOptions) SetVPNConnectionID(vpnConnectionID string) *PcloudVpnconnectionsPutOptions {
	_options.VPNConnectionID = core.StringPtr(vpnConnectionID)
	return _options
}

// SetBody : Allow user to set Body
func (_options *PcloudVpnconnectionsPutOptions) SetBody(body *VPNConnectionUpdate) *PcloudVpnconnectionsPutOptions {
	_options.Body = body
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *PcloudVpnconnectionsPutOptions) SetHeaders(param map[string]string) *PcloudVpnconnectionsPutOptions {
	options.Headers = param
	return options
}

// PeerSubnets : PeerSubnets struct
type PeerSubnets struct {
	// an array of strings containing CIDR of peer subnets.
	PeerSubnets []string `json:"peerSubnets,omitempty"`
}

// UnmarshalPeerSubnets unmarshals an instance of PeerSubnets from the specified map of raw messages.
func UnmarshalPeerSubnets(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PeerSubnets)
	err = core.UnmarshalPrimitive(m, "peerSubnets", &obj.PeerSubnets)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PeeringNetwork : PeeringNetwork struct
type PeeringNetwork struct {
	// Network in CIDR notation (192.168.0.0/24).
	CIDR *string `json:"cidr" validate:"required"`

	// DNS Servers.
	DnsServers []string `json:"dnsServers,omitempty"`

	// Name of project to be peered.
	ProjectName *string `json:"projectName" validate:"required"`
}

// NewPeeringNetwork : Instantiate PeeringNetwork (Generic Model Constructor)
func (*PowervsV1) NewPeeringNetwork(cidr string, projectName string) (_model *PeeringNetwork, err error) {
	_model = &PeeringNetwork{
		CIDR: core.StringPtr(cidr),
		ProjectName: core.StringPtr(projectName),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalPeeringNetwork unmarshals an instance of PeeringNetwork from the specified map of raw messages.
func UnmarshalPeeringNetwork(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PeeringNetwork)
	err = core.UnmarshalPrimitive(m, "cidr", &obj.CIDR)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "dnsServers", &obj.DnsServers)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "projectName", &obj.ProjectName)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PlacementGroup : PlacementGroup struct
type PlacementGroup struct {
	// The id of the Placement Group.
	ID *string `json:"id" validate:"required"`

	// The List of PVM Instance IDs associated with the Placement Group.
	Members []string `json:"members" validate:"required"`

	// The name of the Placement Group.
	Name *string `json:"name" validate:"required"`

	// The Placement Group Policy.
	Policy *string `json:"policy" validate:"required"`
}

// Constants associated with the PlacementGroup.Policy property.
// The Placement Group Policy.
const (
	PlacementGroupPolicyAffinityConst = "affinity"
	PlacementGroupPolicyAntiAffinityConst = "anti-affinity"
)

// UnmarshalPlacementGroup unmarshals an instance of PlacementGroup from the specified map of raw messages.
func UnmarshalPlacementGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PlacementGroup)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "members", &obj.Members)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "policy", &obj.Policy)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PlacementGroups : PlacementGroups struct
type PlacementGroups struct {
	// List of Server Placement Groups.
	PlacementGroups []PlacementGroup `json:"placementGroups" validate:"required"`
}

// UnmarshalPlacementGroups unmarshals an instance of PlacementGroups from the specified map of raw messages.
func UnmarshalPlacementGroups(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PlacementGroups)
	err = core.UnmarshalModel(m, "placementGroups", &obj.PlacementGroups, UnmarshalPlacementGroup)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Plan : Plan struct
type Plan struct {
	Bindable *bool `json:"bindable,omitempty"`

	Description *string `json:"description" validate:"required"`

	Free *bool `json:"free,omitempty"`

	ID *string `json:"id" validate:"required"`

	// See [Service Metadata
	// Conventions](https://github.com/openservicebrokerapi/servicebroker/blob/master/profile.md#service-metadata) for more
	// details.
	Metadata *Metadata `json:"metadata,omitempty"`

	Name *string `json:"name" validate:"required"`

	Schemas *SchemasObject `json:"schemas,omitempty"`
}

// UnmarshalPlan unmarshals an instance of Plan from the specified map of raw messages.
func UnmarshalPlan(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Plan)
	err = core.UnmarshalPrimitive(m, "bindable", &obj.Bindable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "free", &obj.Free)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata", &obj.Metadata, UnmarshalMetadata)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "schemas", &obj.Schemas, UnmarshalSchemasObject)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PodCapacity : List of available resources within a Pod.
type PodCapacity struct {
	// Description of a PPCaaS Pod.
	PodData *PodData `json:"PodData,omitempty"`

	// List of available storage controllers within a particular DataCenter.
	StorageControllers map[string]StorageController `json:"StorageControllers,omitempty"`

	// List of available system pools within a Pod.
	SystemPools map[string]SystemPoolCapacity `json:"SystemPools,omitempty"`
}

// UnmarshalPodCapacity unmarshals an instance of PodCapacity from the specified map of raw messages.
func UnmarshalPodCapacity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PodCapacity)
	err = core.UnmarshalModel(m, "PodData", &obj.PodData, UnmarshalPodData)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "StorageControllers", &obj.StorageControllers, UnmarshalStorageController)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "SystemPools", &obj.SystemPools, UnmarshalSystemPoolCapacity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PodData : Description of a PPCaaS Pod.
type PodData struct {
	// Number of available cores in the Pod.
	Cores *float64 `json:"cores" validate:"required"`

	// Amount of available memory in the Pod (GB).
	Memory *int64 `json:"memory" validate:"required"`

	// ID of the Satellite Location.
	SatLocationID *string `json:"satLocationID" validate:"required"`

	// Amount of available storage in the Pod (GB).
	Storage *int64 `json:"storage" validate:"required"`

	// Total number of cores in the Pod.
	TotalCores *float64 `json:"totalCores" validate:"required"`

	// Total amount of memory in the Pod (GB).
	TotalMemory *int64 `json:"totalMemory" validate:"required"`

	// Total amount of storage in the Pod (GB).
	TotalStorage *int64 `json:"totalStorage" validate:"required"`
}

// UnmarshalPodData unmarshals an instance of PodData from the specified map of raw messages.
func UnmarshalPodData(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PodData)
	err = core.UnmarshalPrimitive(m, "cores", &obj.Cores)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "satLocationID", &obj.SatLocationID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storage", &obj.Storage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "totalCores", &obj.TotalCores)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "totalMemory", &obj.TotalMemory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "totalStorage", &obj.TotalStorage)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PowerVsInstance : PowerVS Instance for a specific IBM Cloud Account.
type PowerVsInstance struct {
	// List of available capabilities for a specific service.
	Capabilities map[string]bool `json:"capabilities" validate:"required"`

	// The timestamp in which the PowerVS service instance was created.
	CreationDate *string `json:"creationDate" validate:"required"`

	// The PowerVS Service Instance CRN.
	CRN *string `json:"crn" validate:"required"`

	// The PowerVS IBM Cloud URL path for UI (Tentative, still need verification that this is possible).
	Href *string `json:"href" validate:"required"`

	// The PowerVS Service Instance ID.
	ID *string `json:"id" validate:"required"`

	// Location of the PowerVS Instance.
	Location *string `json:"location" validate:"required"`

	// The PowerVS URL path to access specific service instance information.
	LocationURL *string `json:"locationUrl" validate:"required"`

	// The name of the service instance (This field will be empty for old accounts as PowerVS did not previously saved the
	// names).
	Name *string `json:"name" validate:"required"`

	// Defines if the user has administrator privileges.
	PrivilegedUser *bool `json:"privilegedUser" validate:"required"`

	// IBM Resource Group ID associated with the PowerVS Service Instance (This field will be empty for old accounts as
	// PowerVS did not previously saved the Resource Group ID).
	ResourceGroupID *string `json:"resourceGroupId,omitempty"`

	// The status of the service instance (PowerVS behavior, if Service Instance exists then then status is active).
	Status *string `json:"status" validate:"required"`
}

// UnmarshalPowerVsInstance unmarshals an instance of PowerVsInstance from the specified map of raw messages.
func UnmarshalPowerVsInstance(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PowerVsInstance)
	err = core.UnmarshalPrimitive(m, "capabilities", &obj.Capabilities)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "creationDate", &obj.CreationDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "locationUrl", &obj.LocationURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "privilegedUser", &obj.PrivilegedUser)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroupId", &obj.ResourceGroupID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PowerVsInstances : The List of PowerVS Instances for a specific IBM Cloud Account.
type PowerVsInstances struct {
	PowerVsInstances []PowerVsInstance `json:"powerVsInstances" validate:"required"`
}

// UnmarshalPowerVsInstances unmarshals an instance of PowerVsInstances from the specified map of raw messages.
func UnmarshalPowerVsInstances(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PowerVsInstances)
	err = core.UnmarshalModel(m, "powerVsInstances", &obj.PowerVsInstances, UnmarshalPowerVsInstance)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceDeployment : PvmInstanceDeployment struct
type PvmInstanceDeployment struct {
	// Machine type used to host the instance.
	MachineType *string `json:"machineType,omitempty"`

	// VM pin policy to use [none, soft, hard].
	PinPolicy *string `json:"pinPolicy,omitempty"`

	// Processor mode (dedicated, shared, capped).
	ProcessorMode *string `json:"processorMode" validate:"required"`

	// Type of Deployment [SAP-RISE, EPIC].
	Type *string `json:"type,omitempty"`
}

// Constants associated with the PvmInstanceDeployment.ProcessorMode property.
// Processor mode (dedicated, shared, capped).
const (
	PvmInstanceDeploymentProcessorModeCappedConst = "capped"
	PvmInstanceDeploymentProcessorModeDedicatedConst = "dedicated"
	PvmInstanceDeploymentProcessorModeSharedConst = "shared"
)

// UnmarshalPvmInstanceDeployment unmarshals an instance of PvmInstanceDeployment from the specified map of raw messages.
func UnmarshalPvmInstanceDeployment(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceDeployment)
	err = core.UnmarshalPrimitive(m, "machineType", &obj.MachineType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pinPolicy", &obj.PinPolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "processorMode", &obj.ProcessorMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstanceHost : PvmInstanceHost struct
type PvmInstanceHost struct {
	// The PVM Instance Host ID (Internal Use Only).
	ID *int64 `json:"id,omitempty"`
}

// UnmarshalPvmInstanceHost unmarshals an instance of PvmInstanceHost from the specified map of raw messages.
func UnmarshalPvmInstanceHost(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstanceHost)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// PvmInstancePlacementGroup : PvmInstancePlacementGroup struct
type PvmInstancePlacementGroup struct {
	// The placement group id of the server.
	ID *string `json:"id" validate:"required"`
}

// UnmarshalPvmInstancePlacementGroup unmarshals an instance of PvmInstancePlacementGroup from the specified map of raw messages.
func UnmarshalPvmInstancePlacementGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(PvmInstancePlacementGroup)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// RemoteCopyRelationship : RemoteCopyRelationship struct
type RemoteCopyRelationship struct {
	// Name of the volume that is acting as the auxiliary change volume for the relationship.
	AuxChangedVolumeName *string `json:"auxChangedVolumeName,omitempty"`

	// Auxiliary volume name at storage host level.
	AuxVolumeName *string `json:"auxVolumeName,omitempty"`

	// Consistency Group Name if volume is a part of volume group.
	ConsistencyGroupName *string `json:"consistencyGroupName,omitempty"`

	// Indicates the copy type.
	CopyType *string `json:"copyType,omitempty"`

	// Indicates the type of cycling mode used.
	CyclingMode *string `json:"cyclingMode,omitempty"`

	// Freeze time of remote copy relationship.
	FreezeTime *strfmt.DateTime `json:"freezeTime,omitempty"`

	// Name of the volume that is acting as the master change volume for the relationship.
	MasterChangedVolumeName *string `json:"masterChangedVolumeName,omitempty"`

	// Master volume name at storage host level.
	MasterVolumeName *string `json:"masterVolumeName,omitempty"`

	// Remote copy relationship name.
	Name *string `json:"name" validate:"required"`

	// Indicates whether master/aux volume is playing the primary role.
	PrimaryRole *string `json:"primaryRole,omitempty"`

	// Indicates the relationship progress.
	Progress *int64 `json:"progress,omitempty"`

	// Remote copy relationship ID.
	RemoteCopyID *string `json:"remoteCopyID" validate:"required"`

	// Indicates the relationship state.
	State *string `json:"state,omitempty"`

	// Indicates whether the relationship is synchronized.
	Sync *string `json:"sync,omitempty"`
}

// UnmarshalRemoteCopyRelationship unmarshals an instance of RemoteCopyRelationship from the specified map of raw messages.
func UnmarshalRemoteCopyRelationship(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(RemoteCopyRelationship)
	err = core.UnmarshalPrimitive(m, "auxChangedVolumeName", &obj.AuxChangedVolumeName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auxVolumeName", &obj.AuxVolumeName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "consistencyGroupName", &obj.ConsistencyGroupName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "copyType", &obj.CopyType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cyclingMode", &obj.CyclingMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "freezeTime", &obj.FreezeTime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterChangedVolumeName", &obj.MasterChangedVolumeName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterVolumeName", &obj.MasterVolumeName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "primaryRole", &obj.PrimaryRole)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "progress", &obj.Progress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remoteCopyID", &obj.RemoteCopyID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sync", &obj.Sync)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SapProfile : SapProfile struct
type SapProfile struct {
	// Has certification been performed on profile.
	Certified *bool `json:"certified" validate:"required"`

	// Amount of cores.
	Cores *int64 `json:"cores" validate:"required"`

	// Amount of memory (in GB).
	Memory *int64 `json:"memory" validate:"required"`

	// SAP Profile ID.
	ProfileID *string `json:"profileID" validate:"required"`

	// Type of profile.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the SapProfile.Type property.
// Type of profile.
const (
	SapProfileTypeBalancedConst = "balanced"
	SapProfileTypeComputeConst = "compute"
	SapProfileTypeMemoryConst = "memory"
	SapProfileTypeNonProductionConst = "non-production"
	SapProfileTypeUltraMemoryConst = "ultra-memory"
)

// UnmarshalSapProfile unmarshals an instance of SapProfile from the specified map of raw messages.
func UnmarshalSapProfile(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SapProfile)
	err = core.UnmarshalPrimitive(m, "certified", &obj.Certified)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cores", &obj.Cores)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "profileID", &obj.ProfileID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SapProfileReference : SapProfileReference struct
type SapProfileReference struct {
	// Link to SAP profile resource.
	Href *string `json:"href" validate:"required"`

	// SAP Profile ID.
	ProfileID *string `json:"profileID" validate:"required"`
}

// UnmarshalSapProfileReference unmarshals an instance of SapProfileReference from the specified map of raw messages.
func UnmarshalSapProfileReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SapProfileReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "profileID", &obj.ProfileID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SapProfiles : SapProfiles struct
type SapProfiles struct {
	// SAP Profiles.
	Profiles []SapProfile `json:"profiles" validate:"required"`
}

// UnmarshalSapProfiles unmarshals an instance of SapProfiles from the specified map of raw messages.
func UnmarshalSapProfiles(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SapProfiles)
	err = core.UnmarshalModel(m, "profiles", &obj.Profiles, UnmarshalSapProfile)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SppPlacementGroup : SppPlacementGroup struct
type SppPlacementGroup struct {
	// The id of the Shared Processor Pool Placement Group.
	ID *string `json:"id" validate:"required"`

	// The list of Shared Processor Pool names that are a member of the Shared Processor Pool Placement Group.
	MemberSharedProcessorPools []string `json:"memberSharedProcessorPools,omitempty"`

	// The name of the Shared Processor Pool Placement Group.
	Name *string `json:"name" validate:"required"`

	// The Shared Processor Pool Placement Group policy.
	Policy *string `json:"policy" validate:"required"`
}

// UnmarshalSppPlacementGroup unmarshals an instance of SppPlacementGroup from the specified map of raw messages.
func UnmarshalSppPlacementGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SppPlacementGroup)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memberSharedProcessorPools", &obj.MemberSharedProcessorPools)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "policy", &obj.Policy)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SppPlacementGroups : SppPlacementGroups struct
type SppPlacementGroups struct {
	// list of Shared Processor Pool Placement Groups.
	SppPlacementGroups []SppPlacementGroup `json:"sppPlacementGroups,omitempty"`
}

// UnmarshalSppPlacementGroups unmarshals an instance of SppPlacementGroups from the specified map of raw messages.
func UnmarshalSppPlacementGroups(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SppPlacementGroups)
	err = core.UnmarshalModel(m, "sppPlacementGroups", &obj.SppPlacementGroups, UnmarshalSppPlacementGroup)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Src : Src struct
type Src struct {
	// The SRC reference code.
	Src *string `json:"src,omitempty"`

	// The date stamp of the SRC.
	Timestamp *string `json:"timestamp,omitempty"`
}

// UnmarshalSrc unmarshals an instance of Src from the specified map of raw messages.
func UnmarshalSrc(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Src)
	err = core.UnmarshalPrimitive(m, "src", &obj.Src)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "timestamp", &obj.Timestamp)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SshKey : SshKey struct
type SshKey struct {
	// Date of sshkey creation.
	CreationDate *strfmt.DateTime `json:"creationDate,omitempty"`

	// User defined name for the SSH key.
	Name *string `json:"name" validate:"required"`

	// SSH RSA key.
	SshKey *string `json:"sshKey" validate:"required"`
}

// NewSshKey : Instantiate SshKey (Generic Model Constructor)
func (*PowervsV1) NewSshKey(name string, sshKey string) (_model *SshKey, err error) {
	_model = &SshKey{
		Name: core.StringPtr(name),
		SshKey: core.StringPtr(sshKey),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalSshKey unmarshals an instance of SshKey from the specified map of raw messages.
func UnmarshalSshKey(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SshKey)
	err = core.UnmarshalPrimitive(m, "creationDate", &obj.CreationDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sshKey", &obj.SshKey)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SshKeys : SshKeys struct
type SshKeys struct {
	// SSH Keys.
	SshKeys []SshKey `json:"sshKeys" validate:"required"`
}

// UnmarshalSshKeys unmarshals an instance of SshKeys from the specified map of raw messages.
func UnmarshalSshKeys(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SshKeys)
	err = core.UnmarshalModel(m, "sshKeys", &obj.SshKeys, UnmarshalSshKey)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SchemaParameters : SchemaParameters struct
type SchemaParameters struct {
	Parameters *JSONSchemaObject `json:"parameters,omitempty"`
}

// UnmarshalSchemaParameters unmarshals an instance of SchemaParameters from the specified map of raw messages.
func UnmarshalSchemaParameters(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SchemaParameters)
	err = core.UnmarshalModel(m, "parameters", &obj.Parameters, UnmarshalJSONSchemaObject)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SchemasObject : SchemasObject struct
type SchemasObject struct {
	ServiceBinding *ServiceBindingSchemaObject `json:"service_binding,omitempty"`

	ServiceInstance *ServiceInstanceSchemaObject `json:"service_instance,omitempty"`
}

// UnmarshalSchemasObject unmarshals an instance of SchemasObject from the specified map of raw messages.
func UnmarshalSchemasObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SchemasObject)
	err = core.UnmarshalModel(m, "service_binding", &obj.ServiceBinding, UnmarshalServiceBindingSchemaObject)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "service_instance", &obj.ServiceInstance, UnmarshalServiceInstanceSchemaObject)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Service : Service struct
type Service struct {
	Bindable *bool `json:"bindable" validate:"required"`

	DashboardClient *DashboardClient `json:"dashboard_client,omitempty"`

	Description *string `json:"description" validate:"required"`

	IamCompatible *bool `json:"iam_compatible,omitempty"`

	ID *string `json:"id" validate:"required"`

	// See [Service Metadata
	// Conventions](https://github.com/openservicebrokerapi/servicebroker/blob/master/profile.md#service-metadata) for more
	// details.
	Metadata *Metadata `json:"metadata,omitempty"`

	Name *string `json:"name" validate:"required"`

	PlanUpdateable *bool `json:"plan_updateable,omitempty"`

	Plans []Plan `json:"plans" validate:"required"`

	Provisionable *bool `json:"provisionable,omitempty"`

	RcCompatible *bool `json:"rc_compatible,omitempty"`

	Requires []string `json:"requires,omitempty"`

	Tags []string `json:"tags,omitempty"`

	UniqueApiKey *bool `json:"unique_api_key,omitempty"`
}

// Constants associated with the Service.Requires property.
const (
	ServiceRequiresRouteForwardingConst = "route_forwarding"
	ServiceRequiresSyslogDrainConst = "syslog_drain"
	ServiceRequiresVolumeMountConst = "volume_mount"
)

// UnmarshalService unmarshals an instance of Service from the specified map of raw messages.
func UnmarshalService(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Service)
	err = core.UnmarshalPrimitive(m, "bindable", &obj.Bindable)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "dashboard_client", &obj.DashboardClient, UnmarshalDashboardClient)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "iam_compatible", &obj.IamCompatible)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "metadata", &obj.Metadata, UnmarshalMetadata)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "plan_updateable", &obj.PlanUpdateable)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "plans", &obj.Plans, UnmarshalPlan)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "provisionable", &obj.Provisionable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "rc_compatible", &obj.RcCompatible)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "requires", &obj.Requires)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tags", &obj.Tags)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "unique_api_key", &obj.UniqueApiKey)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceBinding : ServiceBinding struct
type ServiceBinding struct {
	Credentials *Object `json:"credentials,omitempty"`

	RouteServiceURL *string `json:"route_service_url,omitempty"`

	SyslogDrainURL *string `json:"syslog_drain_url,omitempty"`

	VolumeMounts []ServiceBindingVolumeMount `json:"volume_mounts,omitempty"`
}

// UnmarshalServiceBinding unmarshals an instance of ServiceBinding from the specified map of raw messages.
func UnmarshalServiceBinding(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceBinding)
	err = core.UnmarshalModel(m, "credentials", &obj.Credentials, UnmarshalObject)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "route_service_url", &obj.RouteServiceURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "syslog_drain_url", &obj.SyslogDrainURL)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_mounts", &obj.VolumeMounts, UnmarshalServiceBindingVolumeMount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceBindingBindingOptions : The ServiceBindingBinding options.
type ServiceBindingBindingOptions struct {
	// version number of the Service Broker API that the Platform will use.
	XBrokerApiVersion *string `json:"X-Broker-API-Version" validate:"required"`

	// instance id of instance to provision.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// binding id of binding to create.
	BindingID *string `json:"binding_id" validate:"required,ne="`

	PlanID *string `json:"plan_id" validate:"required"`

	ServiceID *string `json:"service_id" validate:"required"`

	AppGuid *string `json:"app_guid,omitempty"`

	BindResource *ServiceBindingResourceObject `json:"bind_resource,omitempty"`

	// See [Context
	// Conventions](https://github.com/openservicebrokerapi/servicebroker/blob/master/profile.md#context-object) for more
	// details.
	Context *Context `json:"context,omitempty"`

	Parameters *Object `json:"parameters,omitempty"`

	// identity of the user that initiated the request from the Platform.
	XBrokerApiOriginatingIdentity *string `json:"X-Broker-API-Originating-Identity,omitempty"`

	// asynchronous operations supported.
	AcceptsIncomplete *bool `json:"accepts_incomplete,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBindingBindingOptions : Instantiate ServiceBindingBindingOptions
func (*PowervsV1) NewServiceBindingBindingOptions(xBrokerApiVersion string, instanceID string, bindingID string, planID string, serviceID string) *ServiceBindingBindingOptions {
	return &ServiceBindingBindingOptions{
		XBrokerApiVersion: core.StringPtr(xBrokerApiVersion),
		InstanceID: core.StringPtr(instanceID),
		BindingID: core.StringPtr(bindingID),
		PlanID: core.StringPtr(planID),
		ServiceID: core.StringPtr(serviceID),
	}
}

// SetXBrokerApiVersion : Allow user to set XBrokerApiVersion
func (_options *ServiceBindingBindingOptions) SetXBrokerApiVersion(xBrokerApiVersion string) *ServiceBindingBindingOptions {
	_options.XBrokerApiVersion = core.StringPtr(xBrokerApiVersion)
	return _options
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ServiceBindingBindingOptions) SetInstanceID(instanceID string) *ServiceBindingBindingOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetBindingID : Allow user to set BindingID
func (_options *ServiceBindingBindingOptions) SetBindingID(bindingID string) *ServiceBindingBindingOptions {
	_options.BindingID = core.StringPtr(bindingID)
	return _options
}

// SetPlanID : Allow user to set PlanID
func (_options *ServiceBindingBindingOptions) SetPlanID(planID string) *ServiceBindingBindingOptions {
	_options.PlanID = core.StringPtr(planID)
	return _options
}

// SetServiceID : Allow user to set ServiceID
func (_options *ServiceBindingBindingOptions) SetServiceID(serviceID string) *ServiceBindingBindingOptions {
	_options.ServiceID = core.StringPtr(serviceID)
	return _options
}

// SetAppGuid : Allow user to set AppGuid
func (_options *ServiceBindingBindingOptions) SetAppGuid(appGuid string) *ServiceBindingBindingOptions {
	_options.AppGuid = core.StringPtr(appGuid)
	return _options
}

// SetBindResource : Allow user to set BindResource
func (_options *ServiceBindingBindingOptions) SetBindResource(bindResource *ServiceBindingResourceObject) *ServiceBindingBindingOptions {
	_options.BindResource = bindResource
	return _options
}

// SetContext : Allow user to set Context
func (_options *ServiceBindingBindingOptions) SetContext(context *Context) *ServiceBindingBindingOptions {
	_options.Context = context
	return _options
}

// SetParameters : Allow user to set Parameters
func (_options *ServiceBindingBindingOptions) SetParameters(parameters *Object) *ServiceBindingBindingOptions {
	_options.Parameters = parameters
	return _options
}

// SetXBrokerApiOriginatingIdentity : Allow user to set XBrokerApiOriginatingIdentity
func (_options *ServiceBindingBindingOptions) SetXBrokerApiOriginatingIdentity(xBrokerApiOriginatingIdentity string) *ServiceBindingBindingOptions {
	_options.XBrokerApiOriginatingIdentity = core.StringPtr(xBrokerApiOriginatingIdentity)
	return _options
}

// SetAcceptsIncomplete : Allow user to set AcceptsIncomplete
func (_options *ServiceBindingBindingOptions) SetAcceptsIncomplete(acceptsIncomplete bool) *ServiceBindingBindingOptions {
	_options.AcceptsIncomplete = core.BoolPtr(acceptsIncomplete)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBindingBindingOptions) SetHeaders(param map[string]string) *ServiceBindingBindingOptions {
	options.Headers = param
	return options
}

// ServiceBindingGetOptions : The ServiceBindingGet options.
type ServiceBindingGetOptions struct {
	// version number of the Service Broker API that the Platform will use.
	XBrokerApiVersion *string `json:"X-Broker-API-Version" validate:"required"`

	// instance id of instance to provision.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// binding id of binding to create.
	BindingID *string `json:"binding_id" validate:"required,ne="`

	// identity of the user that initiated the request from the Platform.
	XBrokerApiOriginatingIdentity *string `json:"X-Broker-API-Originating-Identity,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBindingGetOptions : Instantiate ServiceBindingGetOptions
func (*PowervsV1) NewServiceBindingGetOptions(xBrokerApiVersion string, instanceID string, bindingID string) *ServiceBindingGetOptions {
	return &ServiceBindingGetOptions{
		XBrokerApiVersion: core.StringPtr(xBrokerApiVersion),
		InstanceID: core.StringPtr(instanceID),
		BindingID: core.StringPtr(bindingID),
	}
}

// SetXBrokerApiVersion : Allow user to set XBrokerApiVersion
func (_options *ServiceBindingGetOptions) SetXBrokerApiVersion(xBrokerApiVersion string) *ServiceBindingGetOptions {
	_options.XBrokerApiVersion = core.StringPtr(xBrokerApiVersion)
	return _options
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ServiceBindingGetOptions) SetInstanceID(instanceID string) *ServiceBindingGetOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetBindingID : Allow user to set BindingID
func (_options *ServiceBindingGetOptions) SetBindingID(bindingID string) *ServiceBindingGetOptions {
	_options.BindingID = core.StringPtr(bindingID)
	return _options
}

// SetXBrokerApiOriginatingIdentity : Allow user to set XBrokerApiOriginatingIdentity
func (_options *ServiceBindingGetOptions) SetXBrokerApiOriginatingIdentity(xBrokerApiOriginatingIdentity string) *ServiceBindingGetOptions {
	_options.XBrokerApiOriginatingIdentity = core.StringPtr(xBrokerApiOriginatingIdentity)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBindingGetOptions) SetHeaders(param map[string]string) *ServiceBindingGetOptions {
	options.Headers = param
	return options
}

// ServiceBindingLastOperationGetOptions : The ServiceBindingLastOperationGet options.
type ServiceBindingLastOperationGetOptions struct {
	// version number of the Service Broker API that the Platform will use.
	XBrokerApiVersion *string `json:"X-Broker-API-Version" validate:"required"`

	// instance id of instance to provision.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// binding id of binding to create.
	BindingID *string `json:"binding_id" validate:"required,ne="`

	// id of the service associated with the instance.
	ServiceID *string `json:"service_id,omitempty"`

	// id of the plan associated with the instance.
	PlanID *string `json:"plan_id,omitempty"`

	// a provided identifier for the operation.
	Operation *string `json:"operation,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBindingLastOperationGetOptions : Instantiate ServiceBindingLastOperationGetOptions
func (*PowervsV1) NewServiceBindingLastOperationGetOptions(xBrokerApiVersion string, instanceID string, bindingID string) *ServiceBindingLastOperationGetOptions {
	return &ServiceBindingLastOperationGetOptions{
		XBrokerApiVersion: core.StringPtr(xBrokerApiVersion),
		InstanceID: core.StringPtr(instanceID),
		BindingID: core.StringPtr(bindingID),
	}
}

// SetXBrokerApiVersion : Allow user to set XBrokerApiVersion
func (_options *ServiceBindingLastOperationGetOptions) SetXBrokerApiVersion(xBrokerApiVersion string) *ServiceBindingLastOperationGetOptions {
	_options.XBrokerApiVersion = core.StringPtr(xBrokerApiVersion)
	return _options
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ServiceBindingLastOperationGetOptions) SetInstanceID(instanceID string) *ServiceBindingLastOperationGetOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetBindingID : Allow user to set BindingID
func (_options *ServiceBindingLastOperationGetOptions) SetBindingID(bindingID string) *ServiceBindingLastOperationGetOptions {
	_options.BindingID = core.StringPtr(bindingID)
	return _options
}

// SetServiceID : Allow user to set ServiceID
func (_options *ServiceBindingLastOperationGetOptions) SetServiceID(serviceID string) *ServiceBindingLastOperationGetOptions {
	_options.ServiceID = core.StringPtr(serviceID)
	return _options
}

// SetPlanID : Allow user to set PlanID
func (_options *ServiceBindingLastOperationGetOptions) SetPlanID(planID string) *ServiceBindingLastOperationGetOptions {
	_options.PlanID = core.StringPtr(planID)
	return _options
}

// SetOperation : Allow user to set Operation
func (_options *ServiceBindingLastOperationGetOptions) SetOperation(operation string) *ServiceBindingLastOperationGetOptions {
	_options.Operation = core.StringPtr(operation)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBindingLastOperationGetOptions) SetHeaders(param map[string]string) *ServiceBindingLastOperationGetOptions {
	options.Headers = param
	return options
}

// ServiceBindingResource : ServiceBindingResource struct
type ServiceBindingResource struct {
	Credentials *Object `json:"credentials,omitempty"`

	Parameters *Object `json:"parameters,omitempty"`

	RouteServiceURL *string `json:"route_service_url,omitempty"`

	SyslogDrainURL *string `json:"syslog_drain_url,omitempty"`

	VolumeMounts []ServiceBindingVolumeMount `json:"volume_mounts,omitempty"`
}

// UnmarshalServiceBindingResource unmarshals an instance of ServiceBindingResource from the specified map of raw messages.
func UnmarshalServiceBindingResource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceBindingResource)
	err = core.UnmarshalModel(m, "credentials", &obj.Credentials, UnmarshalObject)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "parameters", &obj.Parameters, UnmarshalObject)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "route_service_url", &obj.RouteServiceURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "syslog_drain_url", &obj.SyslogDrainURL)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volume_mounts", &obj.VolumeMounts, UnmarshalServiceBindingVolumeMount)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceBindingResourceObject : ServiceBindingResourceObject struct
type ServiceBindingResourceObject struct {
	AppGuid *string `json:"app_guid,omitempty"`

	Route *string `json:"route,omitempty"`
}

// UnmarshalServiceBindingResourceObject unmarshals an instance of ServiceBindingResourceObject from the specified map of raw messages.
func UnmarshalServiceBindingResourceObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceBindingResourceObject)
	err = core.UnmarshalPrimitive(m, "app_guid", &obj.AppGuid)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "route", &obj.Route)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceBindingSchemaObject : ServiceBindingSchemaObject struct
type ServiceBindingSchemaObject struct {
	Create *SchemaParameters `json:"create,omitempty"`
}

// UnmarshalServiceBindingSchemaObject unmarshals an instance of ServiceBindingSchemaObject from the specified map of raw messages.
func UnmarshalServiceBindingSchemaObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceBindingSchemaObject)
	err = core.UnmarshalModel(m, "create", &obj.Create, UnmarshalSchemaParameters)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceBindingUnbindingOptions : The ServiceBindingUnbinding options.
type ServiceBindingUnbindingOptions struct {
	// version number of the Service Broker API that the Platform will use.
	XBrokerApiVersion *string `json:"X-Broker-API-Version" validate:"required"`

	// instance id of instance to provision.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// binding id of binding to create.
	BindingID *string `json:"binding_id" validate:"required,ne="`

	// id of the service associated with the instance being deleted.
	ServiceID *string `json:"service_id" validate:"required"`

	// id of the plan associated with the instance being deleted.
	PlanID *string `json:"plan_id" validate:"required"`

	// identity of the user that initiated the request from the Platform.
	XBrokerApiOriginatingIdentity *string `json:"X-Broker-API-Originating-Identity,omitempty"`

	// asynchronous operations supported.
	AcceptsIncomplete *bool `json:"accepts_incomplete,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBindingUnbindingOptions : Instantiate ServiceBindingUnbindingOptions
func (*PowervsV1) NewServiceBindingUnbindingOptions(xBrokerApiVersion string, instanceID string, bindingID string, serviceID string, planID string) *ServiceBindingUnbindingOptions {
	return &ServiceBindingUnbindingOptions{
		XBrokerApiVersion: core.StringPtr(xBrokerApiVersion),
		InstanceID: core.StringPtr(instanceID),
		BindingID: core.StringPtr(bindingID),
		ServiceID: core.StringPtr(serviceID),
		PlanID: core.StringPtr(planID),
	}
}

// SetXBrokerApiVersion : Allow user to set XBrokerApiVersion
func (_options *ServiceBindingUnbindingOptions) SetXBrokerApiVersion(xBrokerApiVersion string) *ServiceBindingUnbindingOptions {
	_options.XBrokerApiVersion = core.StringPtr(xBrokerApiVersion)
	return _options
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ServiceBindingUnbindingOptions) SetInstanceID(instanceID string) *ServiceBindingUnbindingOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetBindingID : Allow user to set BindingID
func (_options *ServiceBindingUnbindingOptions) SetBindingID(bindingID string) *ServiceBindingUnbindingOptions {
	_options.BindingID = core.StringPtr(bindingID)
	return _options
}

// SetServiceID : Allow user to set ServiceID
func (_options *ServiceBindingUnbindingOptions) SetServiceID(serviceID string) *ServiceBindingUnbindingOptions {
	_options.ServiceID = core.StringPtr(serviceID)
	return _options
}

// SetPlanID : Allow user to set PlanID
func (_options *ServiceBindingUnbindingOptions) SetPlanID(planID string) *ServiceBindingUnbindingOptions {
	_options.PlanID = core.StringPtr(planID)
	return _options
}

// SetXBrokerApiOriginatingIdentity : Allow user to set XBrokerApiOriginatingIdentity
func (_options *ServiceBindingUnbindingOptions) SetXBrokerApiOriginatingIdentity(xBrokerApiOriginatingIdentity string) *ServiceBindingUnbindingOptions {
	_options.XBrokerApiOriginatingIdentity = core.StringPtr(xBrokerApiOriginatingIdentity)
	return _options
}

// SetAcceptsIncomplete : Allow user to set AcceptsIncomplete
func (_options *ServiceBindingUnbindingOptions) SetAcceptsIncomplete(acceptsIncomplete bool) *ServiceBindingUnbindingOptions {
	_options.AcceptsIncomplete = core.BoolPtr(acceptsIncomplete)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBindingUnbindingOptions) SetHeaders(param map[string]string) *ServiceBindingUnbindingOptions {
	options.Headers = param
	return options
}

// ServiceBindingVolumeMount : ServiceBindingVolumeMount struct
type ServiceBindingVolumeMount struct {
	ContainerDir *string `json:"container_dir" validate:"required"`

	Device *ServiceBindingVolumeMountDevice `json:"device" validate:"required"`

	DeviceType *string `json:"device_type" validate:"required"`

	Driver *string `json:"driver" validate:"required"`

	Mode *string `json:"mode" validate:"required"`
}

// Constants associated with the ServiceBindingVolumeMount.DeviceType property.
const (
	ServiceBindingVolumeMountDeviceTypeSharedConst = "shared"
)

// Constants associated with the ServiceBindingVolumeMount.Mode property.
const (
	ServiceBindingVolumeMountModeRConst = "r"
	ServiceBindingVolumeMountModeRwConst = "rw"
)

// UnmarshalServiceBindingVolumeMount unmarshals an instance of ServiceBindingVolumeMount from the specified map of raw messages.
func UnmarshalServiceBindingVolumeMount(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceBindingVolumeMount)
	err = core.UnmarshalPrimitive(m, "container_dir", &obj.ContainerDir)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "device", &obj.Device, UnmarshalServiceBindingVolumeMountDevice)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "device_type", &obj.DeviceType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "driver", &obj.Driver)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceBindingVolumeMountDevice : ServiceBindingVolumeMountDevice struct
type ServiceBindingVolumeMountDevice struct {
	MountConfig *Object `json:"mount_config,omitempty"`

	VolumeID *string `json:"volume_id" validate:"required"`
}

// UnmarshalServiceBindingVolumeMountDevice unmarshals an instance of ServiceBindingVolumeMountDevice from the specified map of raw messages.
func UnmarshalServiceBindingVolumeMountDevice(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceBindingVolumeMountDevice)
	err = core.UnmarshalModel(m, "mount_config", &obj.MountConfig, UnmarshalObject)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "volume_id", &obj.VolumeID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceBrokerAuthCallbackOptions : The ServiceBrokerAuthCallback options.
type ServiceBrokerAuthCallbackOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerAuthCallbackOptions : Instantiate ServiceBrokerAuthCallbackOptions
func (*PowervsV1) NewServiceBrokerAuthCallbackOptions() *ServiceBrokerAuthCallbackOptions {
	return &ServiceBrokerAuthCallbackOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerAuthCallbackOptions) SetHeaders(param map[string]string) *ServiceBrokerAuthCallbackOptions {
	options.Headers = param
	return options
}

// ServiceBrokerAuthDeviceCodePostOptions : The ServiceBrokerAuthDeviceCodePost options.
type ServiceBrokerAuthDeviceCodePostOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerAuthDeviceCodePostOptions : Instantiate ServiceBrokerAuthDeviceCodePostOptions
func (*PowervsV1) NewServiceBrokerAuthDeviceCodePostOptions() *ServiceBrokerAuthDeviceCodePostOptions {
	return &ServiceBrokerAuthDeviceCodePostOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerAuthDeviceCodePostOptions) SetHeaders(param map[string]string) *ServiceBrokerAuthDeviceCodePostOptions {
	options.Headers = param
	return options
}

// ServiceBrokerAuthDeviceTokenPostOptions : The ServiceBrokerAuthDeviceTokenPost options.
type ServiceBrokerAuthDeviceTokenPostOptions struct {
	// The deviceCode that the authorization server returned.
	DeviceCode *string `json:"deviceCode,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerAuthDeviceTokenPostOptions : Instantiate ServiceBrokerAuthDeviceTokenPostOptions
func (*PowervsV1) NewServiceBrokerAuthDeviceTokenPostOptions() *ServiceBrokerAuthDeviceTokenPostOptions {
	return &ServiceBrokerAuthDeviceTokenPostOptions{}
}

// SetDeviceCode : Allow user to set DeviceCode
func (_options *ServiceBrokerAuthDeviceTokenPostOptions) SetDeviceCode(deviceCode string) *ServiceBrokerAuthDeviceTokenPostOptions {
	_options.DeviceCode = core.StringPtr(deviceCode)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerAuthDeviceTokenPostOptions) SetHeaders(param map[string]string) *ServiceBrokerAuthDeviceTokenPostOptions {
	options.Headers = param
	return options
}

// ServiceBrokerAuthInfoTokenOptions : The ServiceBrokerAuthInfoToken options.
type ServiceBrokerAuthInfoTokenOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerAuthInfoTokenOptions : Instantiate ServiceBrokerAuthInfoTokenOptions
func (*PowervsV1) NewServiceBrokerAuthInfoTokenOptions() *ServiceBrokerAuthInfoTokenOptions {
	return &ServiceBrokerAuthInfoTokenOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerAuthInfoTokenOptions) SetHeaders(param map[string]string) *ServiceBrokerAuthInfoTokenOptions {
	options.Headers = param
	return options
}

// ServiceBrokerAuthInfoUserOptions : The ServiceBrokerAuthInfoUser options.
type ServiceBrokerAuthInfoUserOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerAuthInfoUserOptions : Instantiate ServiceBrokerAuthInfoUserOptions
func (*PowervsV1) NewServiceBrokerAuthInfoUserOptions() *ServiceBrokerAuthInfoUserOptions {
	return &ServiceBrokerAuthInfoUserOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerAuthInfoUserOptions) SetHeaders(param map[string]string) *ServiceBrokerAuthInfoUserOptions {
	options.Headers = param
	return options
}

// ServiceBrokerAuthLoginOptions : The ServiceBrokerAuthLogin options.
type ServiceBrokerAuthLoginOptions struct {
	// The user id of the user.
	UserID *string `json:"user_id,omitempty"`

	// The URL to redirect to after login/registration.
	RedirectURL *string `json:"redirect_url,omitempty"`

	// Determines if a refresh token is returned.
	AccessType *string `json:"access_type,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ServiceBrokerAuthLoginOptions.AccessType property.
// Determines if a refresh token is returned.
const (
	ServiceBrokerAuthLoginOptionsAccessTypeOfflineConst = "offline"
	ServiceBrokerAuthLoginOptionsAccessTypeOnlineConst = "online"
)

// NewServiceBrokerAuthLoginOptions : Instantiate ServiceBrokerAuthLoginOptions
func (*PowervsV1) NewServiceBrokerAuthLoginOptions() *ServiceBrokerAuthLoginOptions {
	return &ServiceBrokerAuthLoginOptions{}
}

// SetUserID : Allow user to set UserID
func (_options *ServiceBrokerAuthLoginOptions) SetUserID(userID string) *ServiceBrokerAuthLoginOptions {
	_options.UserID = core.StringPtr(userID)
	return _options
}

// SetRedirectURL : Allow user to set RedirectURL
func (_options *ServiceBrokerAuthLoginOptions) SetRedirectURL(redirectURL string) *ServiceBrokerAuthLoginOptions {
	_options.RedirectURL = core.StringPtr(redirectURL)
	return _options
}

// SetAccessType : Allow user to set AccessType
func (_options *ServiceBrokerAuthLoginOptions) SetAccessType(accessType string) *ServiceBrokerAuthLoginOptions {
	_options.AccessType = core.StringPtr(accessType)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerAuthLoginOptions) SetHeaders(param map[string]string) *ServiceBrokerAuthLoginOptions {
	options.Headers = param
	return options
}

// ServiceBrokerAuthLogoutOptions : The ServiceBrokerAuthLogout options.
type ServiceBrokerAuthLogoutOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerAuthLogoutOptions : Instantiate ServiceBrokerAuthLogoutOptions
func (*PowervsV1) NewServiceBrokerAuthLogoutOptions() *ServiceBrokerAuthLogoutOptions {
	return &ServiceBrokerAuthLogoutOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerAuthLogoutOptions) SetHeaders(param map[string]string) *ServiceBrokerAuthLogoutOptions {
	options.Headers = param
	return options
}

// ServiceBrokerAuthRegistrationCallbackOptions : The ServiceBrokerAuthRegistrationCallback options.
type ServiceBrokerAuthRegistrationCallbackOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerAuthRegistrationCallbackOptions : Instantiate ServiceBrokerAuthRegistrationCallbackOptions
func (*PowervsV1) NewServiceBrokerAuthRegistrationCallbackOptions() *ServiceBrokerAuthRegistrationCallbackOptions {
	return &ServiceBrokerAuthRegistrationCallbackOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerAuthRegistrationCallbackOptions) SetHeaders(param map[string]string) *ServiceBrokerAuthRegistrationCallbackOptions {
	options.Headers = param
	return options
}

// ServiceBrokerAuthRegistrationOptions : The ServiceBrokerAuthRegistration options.
type ServiceBrokerAuthRegistrationOptions struct {
	// Tenant ID of a pcloud tenant.
	TenantID *string `json:"tenant_id" validate:"required"`

	// Entitlement ID of for this tenant.
	EntitlementID *string `json:"entitlement_id" validate:"required"`

	// Plan for this tenant and entitlement.
	Plan *string `json:"plan" validate:"required"`

	// IBM Customer Number (ICN) for this tenant.
	Icn *string `json:"icn" validate:"required"`

	// An array of regions matching the number of cloud-instances in the plan.
	Regions []string `json:"regions" validate:"required"`

	// The URL to redirect to after login/registration.
	RedirectURL *string `json:"redirect_url,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerAuthRegistrationOptions : Instantiate ServiceBrokerAuthRegistrationOptions
func (*PowervsV1) NewServiceBrokerAuthRegistrationOptions(tenantID string, entitlementID string, plan string, icn string, regions []string) *ServiceBrokerAuthRegistrationOptions {
	return &ServiceBrokerAuthRegistrationOptions{
		TenantID: core.StringPtr(tenantID),
		EntitlementID: core.StringPtr(entitlementID),
		Plan: core.StringPtr(plan),
		Icn: core.StringPtr(icn),
		Regions: regions,
	}
}

// SetTenantID : Allow user to set TenantID
func (_options *ServiceBrokerAuthRegistrationOptions) SetTenantID(tenantID string) *ServiceBrokerAuthRegistrationOptions {
	_options.TenantID = core.StringPtr(tenantID)
	return _options
}

// SetEntitlementID : Allow user to set EntitlementID
func (_options *ServiceBrokerAuthRegistrationOptions) SetEntitlementID(entitlementID string) *ServiceBrokerAuthRegistrationOptions {
	_options.EntitlementID = core.StringPtr(entitlementID)
	return _options
}

// SetPlan : Allow user to set Plan
func (_options *ServiceBrokerAuthRegistrationOptions) SetPlan(plan string) *ServiceBrokerAuthRegistrationOptions {
	_options.Plan = core.StringPtr(plan)
	return _options
}

// SetIcn : Allow user to set Icn
func (_options *ServiceBrokerAuthRegistrationOptions) SetIcn(icn string) *ServiceBrokerAuthRegistrationOptions {
	_options.Icn = core.StringPtr(icn)
	return _options
}

// SetRegions : Allow user to set Regions
func (_options *ServiceBrokerAuthRegistrationOptions) SetRegions(regions []string) *ServiceBrokerAuthRegistrationOptions {
	_options.Regions = regions
	return _options
}

// SetRedirectURL : Allow user to set RedirectURL
func (_options *ServiceBrokerAuthRegistrationOptions) SetRedirectURL(redirectURL string) *ServiceBrokerAuthRegistrationOptions {
	_options.RedirectURL = core.StringPtr(redirectURL)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerAuthRegistrationOptions) SetHeaders(param map[string]string) *ServiceBrokerAuthRegistrationOptions {
	options.Headers = param
	return options
}

// ServiceBrokerAuthTokenPostOptions : The ServiceBrokerAuthTokenPost options.
type ServiceBrokerAuthTokenPostOptions struct {
	// The refresh token to request the new Access Token.
	RefreshToken *string `json:"refreshToken" validate:"required"`

	// Source type of the token request (web or cli).
	Source *string `json:"source" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ServiceBrokerAuthTokenPostOptions.Source property.
// Source type of the token request (web or cli).
const (
	ServiceBrokerAuthTokenPostOptionsSourceCliConst = "cli"
	ServiceBrokerAuthTokenPostOptionsSourceWebConst = "web"
)

// NewServiceBrokerAuthTokenPostOptions : Instantiate ServiceBrokerAuthTokenPostOptions
func (*PowervsV1) NewServiceBrokerAuthTokenPostOptions(refreshToken string, source string) *ServiceBrokerAuthTokenPostOptions {
	return &ServiceBrokerAuthTokenPostOptions{
		RefreshToken: core.StringPtr(refreshToken),
		Source: core.StringPtr(source),
	}
}

// SetRefreshToken : Allow user to set RefreshToken
func (_options *ServiceBrokerAuthTokenPostOptions) SetRefreshToken(refreshToken string) *ServiceBrokerAuthTokenPostOptions {
	_options.RefreshToken = core.StringPtr(refreshToken)
	return _options
}

// SetSource : Allow user to set Source
func (_options *ServiceBrokerAuthTokenPostOptions) SetSource(source string) *ServiceBrokerAuthTokenPostOptions {
	_options.Source = core.StringPtr(source)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerAuthTokenPostOptions) SetHeaders(param map[string]string) *ServiceBrokerAuthTokenPostOptions {
	options.Headers = param
	return options
}

// ServiceBrokerHardwareplatformsGetOptions : The ServiceBrokerHardwareplatformsGet options.
type ServiceBrokerHardwareplatformsGetOptions struct {
	// The region zone of the cloud instance.
	RegionZone *string `json:"regionZone,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// Constants associated with the ServiceBrokerHardwareplatformsGetOptions.RegionZone property.
// The region zone of the cloud instance.
const (
	ServiceBrokerHardwareplatformsGetOptionsRegionZoneEuDe1Const = "eu-de-1"
	ServiceBrokerHardwareplatformsGetOptionsRegionZoneEuDe2Const = "eu-de-2"
	ServiceBrokerHardwareplatformsGetOptionsRegionZoneUsEastConst = "us-east"
	ServiceBrokerHardwareplatformsGetOptionsRegionZoneUsEast4Const = "us-east4"
	ServiceBrokerHardwareplatformsGetOptionsRegionZoneUsSouthConst = "us-south"
)

// NewServiceBrokerHardwareplatformsGetOptions : Instantiate ServiceBrokerHardwareplatformsGetOptions
func (*PowervsV1) NewServiceBrokerHardwareplatformsGetOptions() *ServiceBrokerHardwareplatformsGetOptions {
	return &ServiceBrokerHardwareplatformsGetOptions{}
}

// SetRegionZone : Allow user to set RegionZone
func (_options *ServiceBrokerHardwareplatformsGetOptions) SetRegionZone(regionZone string) *ServiceBrokerHardwareplatformsGetOptions {
	_options.RegionZone = core.StringPtr(regionZone)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerHardwareplatformsGetOptions) SetHeaders(param map[string]string) *ServiceBrokerHardwareplatformsGetOptions {
	options.Headers = param
	return options
}

// ServiceBrokerHealthHeadOptions : The ServiceBrokerHealthHead options.
type ServiceBrokerHealthHeadOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerHealthHeadOptions : Instantiate ServiceBrokerHealthHeadOptions
func (*PowervsV1) NewServiceBrokerHealthHeadOptions() *ServiceBrokerHealthHeadOptions {
	return &ServiceBrokerHealthHeadOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerHealthHeadOptions) SetHeaders(param map[string]string) *ServiceBrokerHealthHeadOptions {
	options.Headers = param
	return options
}

// ServiceBrokerHealthOptions : The ServiceBrokerHealth options.
type ServiceBrokerHealthOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerHealthOptions : Instantiate ServiceBrokerHealthOptions
func (*PowervsV1) NewServiceBrokerHealthOptions() *ServiceBrokerHealthOptions {
	return &ServiceBrokerHealthOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerHealthOptions) SetHeaders(param map[string]string) *ServiceBrokerHealthOptions {
	options.Headers = param
	return options
}

// ServiceBrokerOpenstacksGetOptions : The ServiceBrokerOpenstacksGet options.
type ServiceBrokerOpenstacksGetOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerOpenstacksGetOptions : Instantiate ServiceBrokerOpenstacksGetOptions
func (*PowervsV1) NewServiceBrokerOpenstacksGetOptions() *ServiceBrokerOpenstacksGetOptions {
	return &ServiceBrokerOpenstacksGetOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerOpenstacksGetOptions) SetHeaders(param map[string]string) *ServiceBrokerOpenstacksGetOptions {
	options.Headers = param
	return options
}

// ServiceBrokerOpenstacksHostsGetOptions : The ServiceBrokerOpenstacksHostsGet options.
type ServiceBrokerOpenstacksHostsGetOptions struct {
	// Hostname.
	Hostname *string `json:"hostname" validate:"required,ne="`

	// Openstack ID.
	OpenstackID *string `json:"openstack_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerOpenstacksHostsGetOptions : Instantiate ServiceBrokerOpenstacksHostsGetOptions
func (*PowervsV1) NewServiceBrokerOpenstacksHostsGetOptions(hostname string, openstackID string) *ServiceBrokerOpenstacksHostsGetOptions {
	return &ServiceBrokerOpenstacksHostsGetOptions{
		Hostname: core.StringPtr(hostname),
		OpenstackID: core.StringPtr(openstackID),
	}
}

// SetHostname : Allow user to set Hostname
func (_options *ServiceBrokerOpenstacksHostsGetOptions) SetHostname(hostname string) *ServiceBrokerOpenstacksHostsGetOptions {
	_options.Hostname = core.StringPtr(hostname)
	return _options
}

// SetOpenstackID : Allow user to set OpenstackID
func (_options *ServiceBrokerOpenstacksHostsGetOptions) SetOpenstackID(openstackID string) *ServiceBrokerOpenstacksHostsGetOptions {
	_options.OpenstackID = core.StringPtr(openstackID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerOpenstacksHostsGetOptions) SetHeaders(param map[string]string) *ServiceBrokerOpenstacksHostsGetOptions {
	options.Headers = param
	return options
}

// ServiceBrokerOpenstacksOpenstackGetOptions : The ServiceBrokerOpenstacksOpenstackGet options.
type ServiceBrokerOpenstacksOpenstackGetOptions struct {
	// Openstack ID.
	OpenstackID *string `json:"openstack_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerOpenstacksOpenstackGetOptions : Instantiate ServiceBrokerOpenstacksOpenstackGetOptions
func (*PowervsV1) NewServiceBrokerOpenstacksOpenstackGetOptions(openstackID string) *ServiceBrokerOpenstacksOpenstackGetOptions {
	return &ServiceBrokerOpenstacksOpenstackGetOptions{
		OpenstackID: core.StringPtr(openstackID),
	}
}

// SetOpenstackID : Allow user to set OpenstackID
func (_options *ServiceBrokerOpenstacksOpenstackGetOptions) SetOpenstackID(openstackID string) *ServiceBrokerOpenstacksOpenstackGetOptions {
	_options.OpenstackID = core.StringPtr(openstackID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerOpenstacksOpenstackGetOptions) SetHeaders(param map[string]string) *ServiceBrokerOpenstacksOpenstackGetOptions {
	options.Headers = param
	return options
}

// ServiceBrokerOpenstacksPostOptions : The ServiceBrokerOpenstacksPost options.
type ServiceBrokerOpenstacksPostOptions struct {
	// Internal IP address of the OpenStack instance.
	IPAddress *string `json:"ipAddress" validate:"required"`

	// Shortname of the OpenStack instance.
	Name *string `json:"name" validate:"required"`

	// The region where the open stack lives.
	Region *string `json:"region" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerOpenstacksPostOptions : Instantiate ServiceBrokerOpenstacksPostOptions
func (*PowervsV1) NewServiceBrokerOpenstacksPostOptions(ipAddress string, name string, region string) *ServiceBrokerOpenstacksPostOptions {
	return &ServiceBrokerOpenstacksPostOptions{
		IPAddress: core.StringPtr(ipAddress),
		Name: core.StringPtr(name),
		Region: core.StringPtr(region),
	}
}

// SetIPAddress : Allow user to set IPAddress
func (_options *ServiceBrokerOpenstacksPostOptions) SetIPAddress(ipAddress string) *ServiceBrokerOpenstacksPostOptions {
	_options.IPAddress = core.StringPtr(ipAddress)
	return _options
}

// SetName : Allow user to set Name
func (_options *ServiceBrokerOpenstacksPostOptions) SetName(name string) *ServiceBrokerOpenstacksPostOptions {
	_options.Name = core.StringPtr(name)
	return _options
}

// SetRegion : Allow user to set Region
func (_options *ServiceBrokerOpenstacksPostOptions) SetRegion(region string) *ServiceBrokerOpenstacksPostOptions {
	_options.Region = core.StringPtr(region)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerOpenstacksPostOptions) SetHeaders(param map[string]string) *ServiceBrokerOpenstacksPostOptions {
	options.Headers = param
	return options
}

// ServiceBrokerOpenstacksServersGetOptions : The ServiceBrokerOpenstacksServersGet options.
type ServiceBrokerOpenstacksServersGetOptions struct {
	// Openstack ID.
	OpenstackID *string `json:"openstack_id" validate:"required,ne="`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvm_instance_id" validate:"required,ne="`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerOpenstacksServersGetOptions : Instantiate ServiceBrokerOpenstacksServersGetOptions
func (*PowervsV1) NewServiceBrokerOpenstacksServersGetOptions(openstackID string, pvmInstanceID string) *ServiceBrokerOpenstacksServersGetOptions {
	return &ServiceBrokerOpenstacksServersGetOptions{
		OpenstackID: core.StringPtr(openstackID),
		PvmInstanceID: core.StringPtr(pvmInstanceID),
	}
}

// SetOpenstackID : Allow user to set OpenstackID
func (_options *ServiceBrokerOpenstacksServersGetOptions) SetOpenstackID(openstackID string) *ServiceBrokerOpenstacksServersGetOptions {
	_options.OpenstackID = core.StringPtr(openstackID)
	return _options
}

// SetPvmInstanceID : Allow user to set PvmInstanceID
func (_options *ServiceBrokerOpenstacksServersGetOptions) SetPvmInstanceID(pvmInstanceID string) *ServiceBrokerOpenstacksServersGetOptions {
	_options.PvmInstanceID = core.StringPtr(pvmInstanceID)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerOpenstacksServersGetOptions) SetHeaders(param map[string]string) *ServiceBrokerOpenstacksServersGetOptions {
	options.Headers = param
	return options
}

// ServiceBrokerStoragetypesGetOptions : The ServiceBrokerStoragetypesGet options.
type ServiceBrokerStoragetypesGetOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerStoragetypesGetOptions : Instantiate ServiceBrokerStoragetypesGetOptions
func (*PowervsV1) NewServiceBrokerStoragetypesGetOptions() *ServiceBrokerStoragetypesGetOptions {
	return &ServiceBrokerStoragetypesGetOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerStoragetypesGetOptions) SetHeaders(param map[string]string) *ServiceBrokerStoragetypesGetOptions {
	options.Headers = param
	return options
}

// ServiceBrokerSwaggerspecOptions : The ServiceBrokerSwaggerspec options.
type ServiceBrokerSwaggerspecOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerSwaggerspecOptions : Instantiate ServiceBrokerSwaggerspecOptions
func (*PowervsV1) NewServiceBrokerSwaggerspecOptions() *ServiceBrokerSwaggerspecOptions {
	return &ServiceBrokerSwaggerspecOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerSwaggerspecOptions) SetHeaders(param map[string]string) *ServiceBrokerSwaggerspecOptions {
	options.Headers = param
	return options
}

// ServiceBrokerTestTimeoutOptions : The ServiceBrokerTestTimeout options.
type ServiceBrokerTestTimeoutOptions struct {
	// seconds.
	T *int64 `json:"t" validate:"required"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerTestTimeoutOptions : Instantiate ServiceBrokerTestTimeoutOptions
func (*PowervsV1) NewServiceBrokerTestTimeoutOptions(t int64) *ServiceBrokerTestTimeoutOptions {
	return &ServiceBrokerTestTimeoutOptions{
		T: core.Int64Ptr(t),
	}
}

// SetT : Allow user to set T
func (_options *ServiceBrokerTestTimeoutOptions) SetT(t int64) *ServiceBrokerTestTimeoutOptions {
	_options.T = core.Int64Ptr(t)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerTestTimeoutOptions) SetHeaders(param map[string]string) *ServiceBrokerTestTimeoutOptions {
	options.Headers = param
	return options
}

// ServiceBrokerVersionOptions : The ServiceBrokerVersion options.
type ServiceBrokerVersionOptions struct {

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceBrokerVersionOptions : Instantiate ServiceBrokerVersionOptions
func (*PowervsV1) NewServiceBrokerVersionOptions() *ServiceBrokerVersionOptions {
	return &ServiceBrokerVersionOptions{}
}

// SetHeaders : Allow user to set Headers
func (options *ServiceBrokerVersionOptions) SetHeaders(param map[string]string) *ServiceBrokerVersionOptions {
	options.Headers = param
	return options
}

// ServiceInstance : ServiceInstance struct
type ServiceInstance struct {
	// Indicates (from the viewpoint of the provider) whether the service instance is (perceived) active or not and is
	// meaningful if enabled is true. The default value is true if not specified.
	Active *bool `json:"active" validate:"required"`

	// Indicates the current state of the service instance.
	Enable *bool `json:"enable" validate:"required"`

	// Indicates when the service instance was last accessed or modified, and is meaningful if enabled is true AND active
	// is false. Represented as milliseconds since the epoch, but does not need to be accurate to the second/hour.
	LastActive *float64 `json:"last_active" validate:"required"`
}

// UnmarshalServiceInstance unmarshals an instance of ServiceInstance from the specified map of raw messages.
func UnmarshalServiceInstance(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceInstance)
	err = core.UnmarshalPrimitive(m, "active", &obj.Active)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enable", &obj.Enable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "last_active", &obj.LastActive)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceInstanceDeprovisionOptions : The ServiceInstanceDeprovision options.
type ServiceInstanceDeprovisionOptions struct {
	// version number of the Service Broker API that the Platform will use.
	XBrokerApiVersion *string `json:"X-Broker-API-Version" validate:"required"`

	// instance id of instance to provision.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// id of the service associated with the instance being deleted.
	ServiceID *string `json:"service_id" validate:"required"`

	// id of the plan associated with the instance being deleted.
	PlanID *string `json:"plan_id" validate:"required"`

	// identity of the user that initiated the request from the Platform.
	XBrokerApiOriginatingIdentity *string `json:"X-Broker-API-Originating-Identity,omitempty"`

	// asynchronous operations supported.
	AcceptsIncomplete *bool `json:"accepts_incomplete,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceInstanceDeprovisionOptions : Instantiate ServiceInstanceDeprovisionOptions
func (*PowervsV1) NewServiceInstanceDeprovisionOptions(xBrokerApiVersion string, instanceID string, serviceID string, planID string) *ServiceInstanceDeprovisionOptions {
	return &ServiceInstanceDeprovisionOptions{
		XBrokerApiVersion: core.StringPtr(xBrokerApiVersion),
		InstanceID: core.StringPtr(instanceID),
		ServiceID: core.StringPtr(serviceID),
		PlanID: core.StringPtr(planID),
	}
}

// SetXBrokerApiVersion : Allow user to set XBrokerApiVersion
func (_options *ServiceInstanceDeprovisionOptions) SetXBrokerApiVersion(xBrokerApiVersion string) *ServiceInstanceDeprovisionOptions {
	_options.XBrokerApiVersion = core.StringPtr(xBrokerApiVersion)
	return _options
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ServiceInstanceDeprovisionOptions) SetInstanceID(instanceID string) *ServiceInstanceDeprovisionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetServiceID : Allow user to set ServiceID
func (_options *ServiceInstanceDeprovisionOptions) SetServiceID(serviceID string) *ServiceInstanceDeprovisionOptions {
	_options.ServiceID = core.StringPtr(serviceID)
	return _options
}

// SetPlanID : Allow user to set PlanID
func (_options *ServiceInstanceDeprovisionOptions) SetPlanID(planID string) *ServiceInstanceDeprovisionOptions {
	_options.PlanID = core.StringPtr(planID)
	return _options
}

// SetXBrokerApiOriginatingIdentity : Allow user to set XBrokerApiOriginatingIdentity
func (_options *ServiceInstanceDeprovisionOptions) SetXBrokerApiOriginatingIdentity(xBrokerApiOriginatingIdentity string) *ServiceInstanceDeprovisionOptions {
	_options.XBrokerApiOriginatingIdentity = core.StringPtr(xBrokerApiOriginatingIdentity)
	return _options
}

// SetAcceptsIncomplete : Allow user to set AcceptsIncomplete
func (_options *ServiceInstanceDeprovisionOptions) SetAcceptsIncomplete(acceptsIncomplete bool) *ServiceInstanceDeprovisionOptions {
	_options.AcceptsIncomplete = core.BoolPtr(acceptsIncomplete)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceInstanceDeprovisionOptions) SetHeaders(param map[string]string) *ServiceInstanceDeprovisionOptions {
	options.Headers = param
	return options
}

// ServiceInstanceGetOptions : The ServiceInstanceGet options.
type ServiceInstanceGetOptions struct {
	// version number of the Service Broker API that the Platform will use.
	XBrokerApiVersion *string `json:"X-Broker-API-Version" validate:"required"`

	// instance id of instance to provision.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// identity of the user that initiated the request from the Platform.
	XBrokerApiOriginatingIdentity *string `json:"X-Broker-API-Originating-Identity,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceInstanceGetOptions : Instantiate ServiceInstanceGetOptions
func (*PowervsV1) NewServiceInstanceGetOptions(xBrokerApiVersion string, instanceID string) *ServiceInstanceGetOptions {
	return &ServiceInstanceGetOptions{
		XBrokerApiVersion: core.StringPtr(xBrokerApiVersion),
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetXBrokerApiVersion : Allow user to set XBrokerApiVersion
func (_options *ServiceInstanceGetOptions) SetXBrokerApiVersion(xBrokerApiVersion string) *ServiceInstanceGetOptions {
	_options.XBrokerApiVersion = core.StringPtr(xBrokerApiVersion)
	return _options
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ServiceInstanceGetOptions) SetInstanceID(instanceID string) *ServiceInstanceGetOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetXBrokerApiOriginatingIdentity : Allow user to set XBrokerApiOriginatingIdentity
func (_options *ServiceInstanceGetOptions) SetXBrokerApiOriginatingIdentity(xBrokerApiOriginatingIdentity string) *ServiceInstanceGetOptions {
	_options.XBrokerApiOriginatingIdentity = core.StringPtr(xBrokerApiOriginatingIdentity)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceInstanceGetOptions) SetHeaders(param map[string]string) *ServiceInstanceGetOptions {
	options.Headers = param
	return options
}

// ServiceInstanceLastOperationGetOptions : The ServiceInstanceLastOperationGet options.
type ServiceInstanceLastOperationGetOptions struct {
	// version number of the Service Broker API that the Platform will use.
	XBrokerApiVersion *string `json:"X-Broker-API-Version" validate:"required"`

	// instance id of instance to provision.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	// id of the service associated with the instance.
	ServiceID *string `json:"service_id,omitempty"`

	// id of the plan associated with the instance.
	PlanID *string `json:"plan_id,omitempty"`

	// a provided identifier for the operation.
	Operation *string `json:"operation,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceInstanceLastOperationGetOptions : Instantiate ServiceInstanceLastOperationGetOptions
func (*PowervsV1) NewServiceInstanceLastOperationGetOptions(xBrokerApiVersion string, instanceID string) *ServiceInstanceLastOperationGetOptions {
	return &ServiceInstanceLastOperationGetOptions{
		XBrokerApiVersion: core.StringPtr(xBrokerApiVersion),
		InstanceID: core.StringPtr(instanceID),
	}
}

// SetXBrokerApiVersion : Allow user to set XBrokerApiVersion
func (_options *ServiceInstanceLastOperationGetOptions) SetXBrokerApiVersion(xBrokerApiVersion string) *ServiceInstanceLastOperationGetOptions {
	_options.XBrokerApiVersion = core.StringPtr(xBrokerApiVersion)
	return _options
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ServiceInstanceLastOperationGetOptions) SetInstanceID(instanceID string) *ServiceInstanceLastOperationGetOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetServiceID : Allow user to set ServiceID
func (_options *ServiceInstanceLastOperationGetOptions) SetServiceID(serviceID string) *ServiceInstanceLastOperationGetOptions {
	_options.ServiceID = core.StringPtr(serviceID)
	return _options
}

// SetPlanID : Allow user to set PlanID
func (_options *ServiceInstanceLastOperationGetOptions) SetPlanID(planID string) *ServiceInstanceLastOperationGetOptions {
	_options.PlanID = core.StringPtr(planID)
	return _options
}

// SetOperation : Allow user to set Operation
func (_options *ServiceInstanceLastOperationGetOptions) SetOperation(operation string) *ServiceInstanceLastOperationGetOptions {
	_options.Operation = core.StringPtr(operation)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceInstanceLastOperationGetOptions) SetHeaders(param map[string]string) *ServiceInstanceLastOperationGetOptions {
	options.Headers = param
	return options
}

// ServiceInstancePreviousValues : ServiceInstancePreviousValues struct
type ServiceInstancePreviousValues struct {
	OrganizationID *string `json:"organization_id,omitempty"`

	PlanID *string `json:"plan_id,omitempty"`

	ServiceID *string `json:"service_id,omitempty"`

	SpaceID *string `json:"space_id,omitempty"`
}

// UnmarshalServiceInstancePreviousValues unmarshals an instance of ServiceInstancePreviousValues from the specified map of raw messages.
func UnmarshalServiceInstancePreviousValues(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceInstancePreviousValues)
	err = core.UnmarshalPrimitive(m, "organization_id", &obj.OrganizationID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "plan_id", &obj.PlanID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_id", &obj.ServiceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "space_id", &obj.SpaceID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceInstanceProvision : ServiceInstanceProvision struct
type ServiceInstanceProvision struct {
	DashboardURL *string `json:"dashboard_url,omitempty"`
}

// UnmarshalServiceInstanceProvision unmarshals an instance of ServiceInstanceProvision from the specified map of raw messages.
func UnmarshalServiceInstanceProvision(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceInstanceProvision)
	err = core.UnmarshalPrimitive(m, "dashboard_url", &obj.DashboardURL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceInstanceProvisionOptions : The ServiceInstanceProvision options.
type ServiceInstanceProvisionOptions struct {
	// version number of the Service Broker API that the Platform will use.
	XBrokerApiVersion *string `json:"X-Broker-API-Version" validate:"required"`

	// instance id of instance to provision.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	PlanID *string `json:"plan_id" validate:"required"`

	ServiceID *string `json:"service_id" validate:"required"`

	// See [Context
	// Conventions](https://github.com/openservicebrokerapi/servicebroker/blob/master/profile.md#context-object) for more
	// details.
	Context *Context `json:"context,omitempty"`

	OrganizationGuid *string `json:"organization_guid,omitempty"`

	Parameters *Object `json:"parameters,omitempty"`

	SpaceGuid *string `json:"space_guid,omitempty"`

	// identity of the user that initiated the request from the Platform.
	XBrokerApiOriginatingIdentity *string `json:"X-Broker-API-Originating-Identity,omitempty"`

	// asynchronous operations supported.
	AcceptsIncomplete *bool `json:"accepts_incomplete,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceInstanceProvisionOptions : Instantiate ServiceInstanceProvisionOptions
func (*PowervsV1) NewServiceInstanceProvisionOptions(xBrokerApiVersion string, instanceID string, planID string, serviceID string) *ServiceInstanceProvisionOptions {
	return &ServiceInstanceProvisionOptions{
		XBrokerApiVersion: core.StringPtr(xBrokerApiVersion),
		InstanceID: core.StringPtr(instanceID),
		PlanID: core.StringPtr(planID),
		ServiceID: core.StringPtr(serviceID),
	}
}

// SetXBrokerApiVersion : Allow user to set XBrokerApiVersion
func (_options *ServiceInstanceProvisionOptions) SetXBrokerApiVersion(xBrokerApiVersion string) *ServiceInstanceProvisionOptions {
	_options.XBrokerApiVersion = core.StringPtr(xBrokerApiVersion)
	return _options
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ServiceInstanceProvisionOptions) SetInstanceID(instanceID string) *ServiceInstanceProvisionOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetPlanID : Allow user to set PlanID
func (_options *ServiceInstanceProvisionOptions) SetPlanID(planID string) *ServiceInstanceProvisionOptions {
	_options.PlanID = core.StringPtr(planID)
	return _options
}

// SetServiceID : Allow user to set ServiceID
func (_options *ServiceInstanceProvisionOptions) SetServiceID(serviceID string) *ServiceInstanceProvisionOptions {
	_options.ServiceID = core.StringPtr(serviceID)
	return _options
}

// SetContext : Allow user to set Context
func (_options *ServiceInstanceProvisionOptions) SetContext(context *Context) *ServiceInstanceProvisionOptions {
	_options.Context = context
	return _options
}

// SetOrganizationGuid : Allow user to set OrganizationGuid
func (_options *ServiceInstanceProvisionOptions) SetOrganizationGuid(organizationGuid string) *ServiceInstanceProvisionOptions {
	_options.OrganizationGuid = core.StringPtr(organizationGuid)
	return _options
}

// SetParameters : Allow user to set Parameters
func (_options *ServiceInstanceProvisionOptions) SetParameters(parameters *Object) *ServiceInstanceProvisionOptions {
	_options.Parameters = parameters
	return _options
}

// SetSpaceGuid : Allow user to set SpaceGuid
func (_options *ServiceInstanceProvisionOptions) SetSpaceGuid(spaceGuid string) *ServiceInstanceProvisionOptions {
	_options.SpaceGuid = core.StringPtr(spaceGuid)
	return _options
}

// SetXBrokerApiOriginatingIdentity : Allow user to set XBrokerApiOriginatingIdentity
func (_options *ServiceInstanceProvisionOptions) SetXBrokerApiOriginatingIdentity(xBrokerApiOriginatingIdentity string) *ServiceInstanceProvisionOptions {
	_options.XBrokerApiOriginatingIdentity = core.StringPtr(xBrokerApiOriginatingIdentity)
	return _options
}

// SetAcceptsIncomplete : Allow user to set AcceptsIncomplete
func (_options *ServiceInstanceProvisionOptions) SetAcceptsIncomplete(acceptsIncomplete bool) *ServiceInstanceProvisionOptions {
	_options.AcceptsIncomplete = core.BoolPtr(acceptsIncomplete)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceInstanceProvisionOptions) SetHeaders(param map[string]string) *ServiceInstanceProvisionOptions {
	options.Headers = param
	return options
}

// ServiceInstanceResource : ServiceInstanceResource struct
type ServiceInstanceResource struct {
	DashboardURL *string `json:"dashboard_url,omitempty"`

	Parameters *Object `json:"parameters,omitempty"`

	PlanID *string `json:"plan_id,omitempty"`

	ServiceID *string `json:"service_id,omitempty"`
}

// UnmarshalServiceInstanceResource unmarshals an instance of ServiceInstanceResource from the specified map of raw messages.
func UnmarshalServiceInstanceResource(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceInstanceResource)
	err = core.UnmarshalPrimitive(m, "dashboard_url", &obj.DashboardURL)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "parameters", &obj.Parameters, UnmarshalObject)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "plan_id", &obj.PlanID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "service_id", &obj.ServiceID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceInstanceSchemaObject : ServiceInstanceSchemaObject struct
type ServiceInstanceSchemaObject struct {
	Create *SchemaParameters `json:"create,omitempty"`

	Update *SchemaParameters `json:"update,omitempty"`
}

// UnmarshalServiceInstanceSchemaObject unmarshals an instance of ServiceInstanceSchemaObject from the specified map of raw messages.
func UnmarshalServiceInstanceSchemaObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(ServiceInstanceSchemaObject)
	err = core.UnmarshalModel(m, "create", &obj.Create, UnmarshalSchemaParameters)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "update", &obj.Update, UnmarshalSchemaParameters)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// ServiceInstanceUpdateOptions : The ServiceInstanceUpdate options.
type ServiceInstanceUpdateOptions struct {
	// version number of the Service Broker API that the Platform will use.
	XBrokerApiVersion *string `json:"X-Broker-API-Version" validate:"required"`

	// instance id of instance to provision.
	InstanceID *string `json:"instance_id" validate:"required,ne="`

	ServiceID *string `json:"service_id" validate:"required"`

	// See [Context
	// Conventions](https://github.com/openservicebrokerapi/servicebroker/blob/master/profile.md#context-object) for more
	// details.
	Context *Context `json:"context,omitempty"`

	Parameters *Object `json:"parameters,omitempty"`

	PlanID *string `json:"plan_id,omitempty"`

	PreviousValues *ServiceInstancePreviousValues `json:"previous_values,omitempty"`

	// identity of the user that initiated the request from the Platform.
	XBrokerApiOriginatingIdentity *string `json:"X-Broker-API-Originating-Identity,omitempty"`

	// asynchronous operations supported.
	AcceptsIncomplete *bool `json:"accepts_incomplete,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewServiceInstanceUpdateOptions : Instantiate ServiceInstanceUpdateOptions
func (*PowervsV1) NewServiceInstanceUpdateOptions(xBrokerApiVersion string, instanceID string, serviceID string) *ServiceInstanceUpdateOptions {
	return &ServiceInstanceUpdateOptions{
		XBrokerApiVersion: core.StringPtr(xBrokerApiVersion),
		InstanceID: core.StringPtr(instanceID),
		ServiceID: core.StringPtr(serviceID),
	}
}

// SetXBrokerApiVersion : Allow user to set XBrokerApiVersion
func (_options *ServiceInstanceUpdateOptions) SetXBrokerApiVersion(xBrokerApiVersion string) *ServiceInstanceUpdateOptions {
	_options.XBrokerApiVersion = core.StringPtr(xBrokerApiVersion)
	return _options
}

// SetInstanceID : Allow user to set InstanceID
func (_options *ServiceInstanceUpdateOptions) SetInstanceID(instanceID string) *ServiceInstanceUpdateOptions {
	_options.InstanceID = core.StringPtr(instanceID)
	return _options
}

// SetServiceID : Allow user to set ServiceID
func (_options *ServiceInstanceUpdateOptions) SetServiceID(serviceID string) *ServiceInstanceUpdateOptions {
	_options.ServiceID = core.StringPtr(serviceID)
	return _options
}

// SetContext : Allow user to set Context
func (_options *ServiceInstanceUpdateOptions) SetContext(context *Context) *ServiceInstanceUpdateOptions {
	_options.Context = context
	return _options
}

// SetParameters : Allow user to set Parameters
func (_options *ServiceInstanceUpdateOptions) SetParameters(parameters *Object) *ServiceInstanceUpdateOptions {
	_options.Parameters = parameters
	return _options
}

// SetPlanID : Allow user to set PlanID
func (_options *ServiceInstanceUpdateOptions) SetPlanID(planID string) *ServiceInstanceUpdateOptions {
	_options.PlanID = core.StringPtr(planID)
	return _options
}

// SetPreviousValues : Allow user to set PreviousValues
func (_options *ServiceInstanceUpdateOptions) SetPreviousValues(previousValues *ServiceInstancePreviousValues) *ServiceInstanceUpdateOptions {
	_options.PreviousValues = previousValues
	return _options
}

// SetXBrokerApiOriginatingIdentity : Allow user to set XBrokerApiOriginatingIdentity
func (_options *ServiceInstanceUpdateOptions) SetXBrokerApiOriginatingIdentity(xBrokerApiOriginatingIdentity string) *ServiceInstanceUpdateOptions {
	_options.XBrokerApiOriginatingIdentity = core.StringPtr(xBrokerApiOriginatingIdentity)
	return _options
}

// SetAcceptsIncomplete : Allow user to set AcceptsIncomplete
func (_options *ServiceInstanceUpdateOptions) SetAcceptsIncomplete(acceptsIncomplete bool) *ServiceInstanceUpdateOptions {
	_options.AcceptsIncomplete = core.BoolPtr(acceptsIncomplete)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *ServiceInstanceUpdateOptions) SetHeaders(param map[string]string) *ServiceInstanceUpdateOptions {
	options.Headers = param
	return options
}

// SharedProcessorPool : SharedProcessorPool struct
type SharedProcessorPool struct {
	// The amount of allocated processor cores for the Shared Processor Pool.
	AllocatedCores *float64 `json:"allocatedCores" validate:"required"`

	// The amount of available processor cores for the Shared Processor Pool.
	AvailableCores *float64 `json:"availableCores" validate:"required"`

	// The host group the host belongs to.
	HostGroup *string `json:"hostGroup,omitempty"`

	// The ID of the host where the Shared Processor Pool resides.
	HostID *int64 `json:"hostID,omitempty"`

	// The id of the Shared Processor Pool.
	ID *string `json:"id" validate:"required"`

	// The name of the Shared Processor Pool.
	Name *string `json:"name" validate:"required"`

	// The amount of reserved processor cores for the Shared Processor Pool.
	ReservedCores *int64 `json:"reservedCores" validate:"required"`

	// list of Shared Processor Pool Placement Groups.
	SharedProcessorPoolPlacementGroups []SharedProcessorPoolPlacementGroup `json:"sharedProcessorPoolPlacementGroups,omitempty"`

	// The status of the Shared Processor Pool.
	Status *string `json:"status,omitempty"`

	// The status details of the Shared Processor Pool.
	StatusDetail *string `json:"statusDetail,omitempty"`
}

// UnmarshalSharedProcessorPool unmarshals an instance of SharedProcessorPool from the specified map of raw messages.
func UnmarshalSharedProcessorPool(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SharedProcessorPool)
	err = core.UnmarshalPrimitive(m, "allocatedCores", &obj.AllocatedCores)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "availableCores", &obj.AvailableCores)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "hostGroup", &obj.HostGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "hostID", &obj.HostID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "reservedCores", &obj.ReservedCores)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sharedProcessorPoolPlacementGroups", &obj.SharedProcessorPoolPlacementGroups, UnmarshalSharedProcessorPoolPlacementGroup)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "statusDetail", &obj.StatusDetail)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SharedProcessorPoolDetail : SharedProcessorPoolDetail struct
type SharedProcessorPoolDetail struct {
	// list of servers deployed in the Shared Processor Pool.
	Servers []SharedProcessorPoolServer `json:"servers" validate:"required"`

	SharedProcessorPool *SharedProcessorPool `json:"sharedProcessorPool" validate:"required"`
}

// UnmarshalSharedProcessorPoolDetail unmarshals an instance of SharedProcessorPoolDetail from the specified map of raw messages.
func UnmarshalSharedProcessorPoolDetail(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SharedProcessorPoolDetail)
	err = core.UnmarshalModel(m, "servers", &obj.Servers, UnmarshalSharedProcessorPoolServer)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sharedProcessorPool", &obj.SharedProcessorPool, UnmarshalSharedProcessorPool)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SharedProcessorPoolPlacementGroup : SharedProcessorPoolPlacementGroup struct
type SharedProcessorPoolPlacementGroup struct {
	// The id of the Shared Processor Pool Placement Group.
	ID *string `json:"id" validate:"required"`

	// The name of the Shared Processor Pool Placement Group.
	Name *string `json:"name" validate:"required"`

	// The Shared Processor Pool Placement Group policy.
	Policy *string `json:"policy" validate:"required"`
}

// UnmarshalSharedProcessorPoolPlacementGroup unmarshals an instance of SharedProcessorPoolPlacementGroup from the specified map of raw messages.
func UnmarshalSharedProcessorPoolPlacementGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SharedProcessorPoolPlacementGroup)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "policy", &obj.Policy)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SharedProcessorPoolServer : SharedProcessorPoolServer struct
type SharedProcessorPoolServer struct {
	// The amount of cpus for the server.
	Cpus *int64 `json:"Cpus,omitempty"`

	// Identifies if uncapped or not.
	Uncapped *bool `json:"Uncapped,omitempty"`

	// Availability zone for the server.
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	// The server ID.
	ID *string `json:"id,omitempty"`

	// The amount of memory for the server.
	Memory *int64 `json:"memory,omitempty"`

	// The server name.
	Name *string `json:"name,omitempty"`

	// Status of the server.
	Status *string `json:"status,omitempty"`

	// The amout of vcpus for the server.
	Vcpus *float64 `json:"vcpus,omitempty"`
}

// UnmarshalSharedProcessorPoolServer unmarshals an instance of SharedProcessorPoolServer from the specified map of raw messages.
func UnmarshalSharedProcessorPoolServer(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SharedProcessorPoolServer)
	err = core.UnmarshalPrimitive(m, "Cpus", &obj.Cpus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "Uncapped", &obj.Uncapped)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "availabilityZone", &obj.AvailabilityZone)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vcpus", &obj.Vcpus)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SharedProcessorPools : SharedProcessorPools struct
type SharedProcessorPools struct {
	// list of Shared Processor Pools.
	SharedProcessorPools []SharedProcessorPool `json:"sharedProcessorPools,omitempty"`
}

// UnmarshalSharedProcessorPools unmarshals an instance of SharedProcessorPools from the specified map of raw messages.
func UnmarshalSharedProcessorPools(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SharedProcessorPools)
	err = core.UnmarshalModel(m, "sharedProcessorPools", &obj.SharedProcessorPools, UnmarshalSharedProcessorPool)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Site : Site struct
type Site struct {
	// true if location is active , otherwise it is false.
	IsActive *bool `json:"isActive,omitempty"`

	// regionZone of the location.
	Location *string `json:"location,omitempty"`
}

// UnmarshalSite unmarshals an instance of Site from the specified map of raw messages.
func UnmarshalSite(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Site)
	err = core.UnmarshalPrimitive(m, "isActive", &obj.IsActive)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Snapshot : Snapshot struct
type Snapshot struct {
	// Action performed on the instance snapshot.
	Action *string `json:"action,omitempty"`

	// Creation Date.
	CreationDate *strfmt.DateTime `json:"creationDate,omitempty"`

	// Description of the PVM instance snapshot.
	Description *string `json:"description,omitempty"`

	// Last Update Date.
	LastUpdateDate *strfmt.DateTime `json:"lastUpdateDate,omitempty"`

	// Name of the PVM instance snapshot.
	Name *string `json:"name" validate:"required"`

	// Snapshot completion percentage.
	PercentComplete *int64 `json:"percentComplete,omitempty"`

	// PCloud PVM Instance ID.
	PvmInstanceID *string `json:"pvmInstanceID" validate:"required"`

	// ID of the PVM instance snapshot.
	SnapshotID *string `json:"snapshotID" validate:"required"`

	// Status of the PVM instancesnapshot.
	Status *string `json:"status,omitempty"`

	// A map of volume snapshots included in the PVM instance snapshot.
	VolumeSnapshots map[string]string `json:"volumeSnapshots" validate:"required"`
}

// UnmarshalSnapshot unmarshals an instance of Snapshot from the specified map of raw messages.
func UnmarshalSnapshot(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Snapshot)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "creationDate", &obj.CreationDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lastUpdateDate", &obj.LastUpdateDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "percentComplete", &obj.PercentComplete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pvmInstanceID", &obj.PvmInstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "snapshotID", &obj.SnapshotID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "volumeSnapshots", &obj.VolumeSnapshots)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SnapshotCreateResponse : SnapshotCreateResponse struct
type SnapshotCreateResponse struct {
	// ID of the PVM instance snapshot.
	SnapshotID *string `json:"snapshotID" validate:"required"`
}

// UnmarshalSnapshotCreateResponse unmarshals an instance of SnapshotCreateResponse from the specified map of raw messages.
func UnmarshalSnapshotCreateResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SnapshotCreateResponse)
	err = core.UnmarshalPrimitive(m, "snapshotID", &obj.SnapshotID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Snapshots : Snapshots struct
type Snapshots struct {
	// List of PVM instance snapshots.
	Snapshots []Snapshot `json:"snapshots" validate:"required"`
}

// UnmarshalSnapshots unmarshals an instance of Snapshots from the specified map of raw messages.
func UnmarshalSnapshots(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Snapshots)
	err = core.UnmarshalModel(m, "snapshots", &obj.Snapshots, UnmarshalSnapshot)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SoftlayerSubscription : Softlayer subscription object.
type SoftlayerSubscription struct {
	// Softlayer ID.
	ID *string `json:"id" validate:"required"`

	// State of softlayer subscription.
	State *string `json:"state" validate:"required"`
}

// UnmarshalSoftlayerSubscription unmarshals an instance of SoftlayerSubscription from the specified map of raw messages.
func UnmarshalSoftlayerSubscription(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SoftlayerSubscription)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SoftwareLicenses : SoftwareLicenses struct
type SoftwareLicenses struct {
	// IBMi Cloud Storage Solution.
	IbmiCss *bool `json:"ibmiCSS,omitempty"`

	// IBMi Cloud Storage Solution.
	IbmiDbq *bool `json:"ibmiDBQ,omitempty"`

	// IBMi Power High Availability.
	IbmiPha *bool `json:"ibmiPHA,omitempty"`

	// IBMi Rational Dev Studio.
	IbmiRds *bool `json:"ibmiRDS,omitempty"`

	// IBMi Rational Dev Studio Number of User Licenses.
	IbmiRdsUsers *int64 `json:"ibmiRDSUsers,omitempty"`
}

// UnmarshalSoftwareLicenses unmarshals an instance of SoftwareLicenses from the specified map of raw messages.
func UnmarshalSoftwareLicenses(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SoftwareLicenses)
	err = core.UnmarshalPrimitive(m, "ibmiCSS", &obj.IbmiCss)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ibmiDBQ", &obj.IbmiDbq)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ibmiPHA", &obj.IbmiPha)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ibmiRDS", &obj.IbmiRds)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ibmiRDSUsers", &obj.IbmiRdsUsers)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Status : Status struct
type Status struct {
	// message detailing current state.
	Message *string `json:"message,omitempty"`

	// progress of a job.
	Progress *string `json:"progress" validate:"required"`

	// state of a job.
	State *string `json:"state" validate:"required"`
}

// UnmarshalStatus unmarshals an instance of Status from the specified map of raw messages.
func UnmarshalStatus(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Status)
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "progress", &obj.Progress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StatusDescription : Status details of the volume group.
type StatusDescription struct {
	// List of descriptive error messages.
	Errors []StatusDescriptionError `json:"errors,omitempty"`
}

// UnmarshalStatusDescription unmarshals an instance of StatusDescription from the specified map of raw messages.
func UnmarshalStatusDescription(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StatusDescription)
	err = core.UnmarshalModel(m, "errors", &obj.Errors, UnmarshalStatusDescriptionError)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StatusDescriptionError : Error status details of a volume group.
type StatusDescriptionError struct {
	// Indicates the volume group error key.
	Key *string `json:"key,omitempty"`

	// Failure message providing more details about the error key.
	Message *string `json:"message,omitempty"`

	// List of volume IDs, which failed to be added/removed to/from the volume-group, with the given error.
	VolIDs []string `json:"volIDs,omitempty"`
}

// UnmarshalStatusDescriptionError unmarshals an instance of StatusDescriptionError from the specified map of raw messages.
func UnmarshalStatusDescriptionError(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StatusDescriptionError)
	err = core.UnmarshalPrimitive(m, "key", &obj.Key)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "volIDs", &obj.VolIDs)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageAffinity : StorageAffinity struct
type StorageAffinity struct {
	// PVM Instance (ID or Name) to base storage affinity policy against; required if requesting storage affinity and
	// affinityVolume is not provided.
	AffinityPvmInstance *string `json:"affinityPVMInstance,omitempty"`

	// Affinity policy for storage pool selection; ignored if storagePool provided; for policy 'affinity' requires one of
	// affinityPVMInstance or affinityVolume to be specified; for policy 'anti-affinity' requires one of
	// antiAffinityPVMInstances or antiAffinityVolumes to be specified.
	AffinityPolicy *string `json:"affinityPolicy,omitempty"`

	// Volume (ID or Name) to base storage affinity policy against; required if requesting storage affinity and
	// affinityPVMInstance is not provided.
	AffinityVolume *string `json:"affinityVolume,omitempty"`

	// List of pvmInstances to base storage anti-affinity policy against; required if requesting storage anti-affinity and
	// antiAffinityVolumes is not provided.
	AntiAffinityPvmInstances []string `json:"antiAffinityPVMInstances,omitempty"`

	// List of volumes to base storage anti-affinity policy against; required if requesting storage anti-affinity and
	// antiAffinityPVMInstances is not provided.
	AntiAffinityVolumes []string `json:"antiAffinityVolumes,omitempty"`
}

// Constants associated with the StorageAffinity.AffinityPolicy property.
// Affinity policy for storage pool selection; ignored if storagePool provided; for policy 'affinity' requires one of
// affinityPVMInstance or affinityVolume to be specified; for policy 'anti-affinity' requires one of
// antiAffinityPVMInstances or antiAffinityVolumes to be specified.
const (
	StorageAffinityAffinityPolicyAffinityConst = "affinity"
	StorageAffinityAffinityPolicyAntiAffinityConst = "anti-affinity"
)

// UnmarshalStorageAffinity unmarshals an instance of StorageAffinity from the specified map of raw messages.
func UnmarshalStorageAffinity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageAffinity)
	err = core.UnmarshalPrimitive(m, "affinityPVMInstance", &obj.AffinityPvmInstance)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "affinityPolicy", &obj.AffinityPolicy)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "affinityVolume", &obj.AffinityVolume)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "antiAffinityPVMInstances", &obj.AntiAffinityPvmInstances)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "antiAffinityVolumes", &obj.AntiAffinityVolumes)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageController : Description of a Storage Controller.
type StorageController struct {
	// Display Name of the Storage Controller.
	DisplayName *string `json:"displayName" validate:"required"`

	// Health status of this storage controller.
	Health *string `json:"health" validate:"required"`

	// Free storage in user pools on this storage controller (GB).
	PoolStorage *float64 `json:"poolStorage" validate:"required"`

	// Total storage capacity of user pools in this storage controller (GB).
	PoolTotalStorage *float64 `json:"poolTotalStorage" validate:"required"`

	// List of storage pools within this storage controller.
	Pools map[string]StoragePoolCombined `json:"pools" validate:"required"`
}

// UnmarshalStorageController unmarshals an instance of StorageController from the specified map of raw messages.
func UnmarshalStorageController(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageController)
	err = core.UnmarshalPrimitive(m, "displayName", &obj.DisplayName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "health", &obj.Health)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "poolStorage", &obj.PoolStorage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "poolTotalStorage", &obj.PoolTotalStorage)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "pools", &obj.Pools, UnmarshalStoragePoolCombined)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageEntities : StorageEntities struct
type StorageEntities struct {
	// threshold value to apply to an existing storage entity.
	ExistingEntity *int64 `json:"existingEntity,omitempty"`

	// threshold value to apply to a new storage entity.
	NewEntity *int64 `json:"newEntity,omitempty"`
}

// UnmarshalStorageEntities unmarshals an instance of StorageEntities from the specified map of raw messages.
func UnmarshalStorageEntities(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageEntities)
	err = core.UnmarshalPrimitive(m, "existingEntity", &obj.ExistingEntity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "newEntity", &obj.NewEntity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StoragePool : StoragePool struct
type StoragePool struct {
	// display name of storage pool.
	DisplayName *string `json:"displayName" validate:"required"`

	// indicates if the storage pool is disaster recovery (dr) enabled.
	DrEnabled *bool `json:"drEnabled" validate:"required"`

	// name of storage pool.
	Name *string `json:"name" validate:"required"`

	// storage threshold settings.
	OverrideThresholds *Thresholds `json:"overrideThresholds,omitempty"`

	// state of storage pool.
	State *string `json:"state" validate:"required"`

	// type of storage pool.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the StoragePool.State property.
// state of storage pool.
const (
	StoragePoolStateClosedConst = "closed"
	StoragePoolStateOpenedConst = "opened"
)

// UnmarshalStoragePool unmarshals an instance of StoragePool from the specified map of raw messages.
func UnmarshalStoragePool(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StoragePool)
	err = core.UnmarshalPrimitive(m, "displayName", &obj.DisplayName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "drEnabled", &obj.DrEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "overrideThresholds", &obj.OverrideThresholds, UnmarshalThresholds)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StoragePoolCapacity : Storage pool capacity.
type StoragePoolCapacity struct {
	// Available/Unused pool capacity (GB).
	AvailableCapacity *int64 `json:"availableCapacity,omitempty"`

	// Maximum allocation storage size (GB).
	MaxAllocationSize *int64 `json:"maxAllocationSize" validate:"required"`

	// Pool name.
	PoolName *string `json:"poolName,omitempty"`

	// true if storage-pool is replication enabled and can be used to manage replication enabled volumes.
	ReplicationEnabled *bool `json:"replicationEnabled,omitempty"`

	// Storage host/controller for this storage pool.
	StorageHost *string `json:"storageHost,omitempty"`

	// Storage type of the storage pool.
	StorageType *string `json:"storageType,omitempty"`

	// Total pool capacity (GB).
	TotalCapacity *int64 `json:"totalCapacity,omitempty"`
}

// UnmarshalStoragePoolCapacity unmarshals an instance of StoragePoolCapacity from the specified map of raw messages.
func UnmarshalStoragePoolCapacity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StoragePoolCapacity)
	err = core.UnmarshalPrimitive(m, "availableCapacity", &obj.AvailableCapacity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "maxAllocationSize", &obj.MaxAllocationSize)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "poolName", &obj.PoolName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replicationEnabled", &obj.ReplicationEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storageHost", &obj.StorageHost)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storageType", &obj.StorageType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "totalCapacity", &obj.TotalCapacity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StoragePoolCombined : Combined Storage Pool Capacity.
type StoragePoolCombined struct {
	// Pool name.
	PoolName *string `json:"poolName" validate:"required"`

	// Available/Unused pool capacity (GB).
	Storage *int64 `json:"storage" validate:"required"`

	// Total pool capacity (GB).
	TotalStorage *int64 `json:"totalStorage" validate:"required"`
}

// UnmarshalStoragePoolCombined unmarshals an instance of StoragePoolCombined from the specified map of raw messages.
func UnmarshalStoragePoolCombined(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StoragePoolCombined)
	err = core.UnmarshalPrimitive(m, "poolName", &obj.PoolName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storage", &obj.Storage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "totalStorage", &obj.TotalStorage)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StoragePoolsCapacity : Storage capacity for all storage pools.
type StoragePoolsCapacity struct {
	// Maximum storage allocation.
	MaximumStorageAllocation *MaximumStorageAllocation `json:"maximumStorageAllocation,omitempty"`

	StoragePoolsCapacity []StoragePoolCapacity `json:"storagePoolsCapacity,omitempty"`
}

// UnmarshalStoragePoolsCapacity unmarshals an instance of StoragePoolsCapacity from the specified map of raw messages.
func UnmarshalStoragePoolsCapacity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StoragePoolsCapacity)
	err = core.UnmarshalModel(m, "maximumStorageAllocation", &obj.MaximumStorageAllocation, UnmarshalMaximumStorageAllocation)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "storagePoolsCapacity", &obj.StoragePoolsCapacity, UnmarshalStoragePoolCapacity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageTier : Storage tier detail.
type StorageTier struct {
	// Description, storage tier label.
	Description *string `json:"description,omitempty"`

	// Name of the storage tier.
	Name *string `json:"name,omitempty"`

	// State of the storage tier (active or inactive).
	State *string `json:"state,omitempty"`
}

// Constants associated with the StorageTier.State property.
// State of the storage tier (active or inactive).
const (
	StorageTierStateActiveConst = "active"
	StorageTierStateInactiveConst = "inactive"
)

// UnmarshalStorageTier unmarshals an instance of StorageTier from the specified map of raw messages.
func UnmarshalStorageTier(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageTier)
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageType : Storage type detail.
type StorageType struct {
	// Identifies if the storage type is the default for a region.
	Default *bool `json:"default,omitempty"`

	// Description, storage type label.
	Description *string `json:"description,omitempty"`

	// State of the storage type (active or inactive).
	State *string `json:"state,omitempty"`

	// Storage type.
	Type *string `json:"type,omitempty"`
}

// Constants associated with the StorageType.State property.
// State of the storage type (active or inactive).
const (
	StorageTypeStateActiveConst = "active"
	StorageTypeStateInactiveConst = "inactive"
)

// UnmarshalStorageType unmarshals an instance of StorageType from the specified map of raw messages.
func UnmarshalStorageType(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageType)
	err = core.UnmarshalPrimitive(m, "default", &obj.Default)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageTypeCapacity : Storage type capacity.
type StorageTypeCapacity struct {
	// Maximum storage allocation.
	MaximumStorageAllocation *MaximumStorageAllocation `json:"maximumStorageAllocation,omitempty"`

	// List of storage pool capacity for storage type.
	StoragePoolsCapacity []StoragePoolCapacity `json:"storagePoolsCapacity,omitempty"`

	// Storage type.
	StorageType *string `json:"storageType,omitempty"`
}

// UnmarshalStorageTypeCapacity unmarshals an instance of StorageTypeCapacity from the specified map of raw messages.
func UnmarshalStorageTypeCapacity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageTypeCapacity)
	err = core.UnmarshalModel(m, "maximumStorageAllocation", &obj.MaximumStorageAllocation, UnmarshalMaximumStorageAllocation)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "storagePoolsCapacity", &obj.StoragePoolsCapacity, UnmarshalStoragePoolCapacity)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "storageType", &obj.StorageType)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// StorageTypesCapacity : Storage types capacity.
type StorageTypesCapacity struct {
	// Maximum storage allocation.
	MaximumStorageAllocation *MaximumStorageAllocation `json:"maximumStorageAllocation,omitempty"`

	StorageTypesCapacity []StorageTypeCapacity `json:"storageTypesCapacity,omitempty"`
}

// UnmarshalStorageTypesCapacity unmarshals an instance of StorageTypesCapacity from the specified map of raw messages.
func UnmarshalStorageTypesCapacity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(StorageTypesCapacity)
	err = core.UnmarshalModel(m, "maximumStorageAllocation", &obj.MaximumStorageAllocation, UnmarshalMaximumStorageAllocation)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "storageTypesCapacity", &obj.StorageTypesCapacity, UnmarshalStorageTypeCapacity)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// System : System struct
type System struct {
	// The host available Processor units.
	AvailableCores *float64 `json:"availableCores,omitempty"`

	// The host available RAM memory in GiB.
	AvailableMemory *int64 `json:"availableMemory,omitempty"`

	// The host available Processor units.
	Cores *float64 `json:"cores" validate:"required"`

	// The host identifier.
	ID *int64 `json:"id,omitempty"`

	// The host total RAM memory in GiB.
	Memory *int64 `json:"memory" validate:"required"`

	// The host total Processor units.
	TotalCores *float64 `json:"totalCores" validate:"required"`

	// The host total RAM memory in GiB.
	TotalMemory *int64 `json:"totalMemory" validate:"required"`
}

// UnmarshalSystem unmarshals an instance of System from the specified map of raw messages.
func UnmarshalSystem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(System)
	err = core.UnmarshalPrimitive(m, "availableCores", &obj.AvailableCores)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "availableMemory", &obj.AvailableMemory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cores", &obj.Cores)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "totalCores", &obj.TotalCores)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "totalMemory", &obj.TotalMemory)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SystemPool : Hardware platform detailing its limits and statistics.
type SystemPool struct {
	Capacity *System `json:"capacity,omitempty"`

	// Processor to Memory (GB) Ratio.
	CoreMemoryRatio *float64 `json:"coreMemoryRatio,omitempty"`

	MaxAvailable *System `json:"maxAvailable,omitempty"`

	MaxCoresAvailable *System `json:"maxCoresAvailable,omitempty"`

	MaxMemoryAvailable *System `json:"maxMemoryAvailable,omitempty"`

	SharedCoreRatio *MinMaxDefault `json:"sharedCoreRatio,omitempty"`

	// The DataCenter list of servers and their available resources.
	Systems []System `json:"systems,omitempty"`

	// Type of system hardware.
	Type *string `json:"type,omitempty"`
}

// UnmarshalSystemPool unmarshals an instance of SystemPool from the specified map of raw messages.
func UnmarshalSystemPool(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SystemPool)
	err = core.UnmarshalModel(m, "capacity", &obj.Capacity, UnmarshalSystem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "coreMemoryRatio", &obj.CoreMemoryRatio)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "maxAvailable", &obj.MaxAvailable, UnmarshalSystem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "maxCoresAvailable", &obj.MaxCoresAvailable, UnmarshalSystem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "maxMemoryAvailable", &obj.MaxMemoryAvailable, UnmarshalSystem)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sharedCoreRatio", &obj.SharedCoreRatio, UnmarshalMinMaxDefault)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "systems", &obj.Systems, UnmarshalSystem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// SystemPoolCapacity : Description of a System Pool's Capacity.
type SystemPoolCapacity struct {
	// Number of available cores in the System Pool.
	Cores *float64 `json:"cores" validate:"required"`

	// Amount of available memory in the System Pool (GB).
	Memory *int64 `json:"memory" validate:"required"`

	// The DataCenter list of servers and their available resources.
	Systems []System `json:"systems,omitempty"`

	// Total number of cores in the System Pool.
	TotalCores *float64 `json:"totalCores" validate:"required"`

	// Total amount of memory in the System Pool (GB).
	TotalMemory *int64 `json:"totalMemory" validate:"required"`
}

// UnmarshalSystemPoolCapacity unmarshals an instance of SystemPoolCapacity from the specified map of raw messages.
func UnmarshalSystemPoolCapacity(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(SystemPoolCapacity)
	err = core.UnmarshalPrimitive(m, "cores", &obj.Cores)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memory", &obj.Memory)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "systems", &obj.Systems, UnmarshalSystem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "totalCores", &obj.TotalCores)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "totalMemory", &obj.TotalMemory)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TargetObject : List of available capabilities for a specific service.
type TargetObject struct {
	// The name of the target.
	Name *string `json:"name" validate:"required"`

	// The type of the target.
	Type *string `json:"type" validate:"required"`
}

// UnmarshalTargetObject unmarshals an instance of TargetObject from the specified map of raw messages.
func UnmarshalTargetObject(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TargetObject)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Task : Task struct
type Task struct {
	// Cloud Instance ID of task owner.
	CloudInstanceID *string `json:"cloudInstanceID" validate:"required"`

	// the component id of the task.
	ComponentID *string `json:"componentID" validate:"required"`

	// the component type of the task.
	ComponentType *string `json:"componentType" validate:"required"`

	// Creation Date.
	CreationDate *strfmt.DateTime `json:"creationDate" validate:"required"`

	// Last Update Date.
	LastUpdateDate *strfmt.DateTime `json:"lastUpdateDate" validate:"required"`

	// Task Operation.
	Operation *string `json:"operation" validate:"required"`

	// status code of the task.
	Status *string `json:"status" validate:"required"`

	// status detail of the task.
	StatusDetail *string `json:"statusDetail" validate:"required"`

	// Pcloud Task ID.
	TaskID *string `json:"taskID" validate:"required"`
}

// UnmarshalTask unmarshals an instance of Task from the specified map of raw messages.
func UnmarshalTask(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Task)
	err = core.UnmarshalPrimitive(m, "cloudInstanceID", &obj.CloudInstanceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "componentID", &obj.ComponentID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "componentType", &obj.ComponentType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "creationDate", &obj.CreationDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lastUpdateDate", &obj.LastUpdateDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "operation", &obj.Operation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "statusDetail", &obj.StatusDetail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "taskID", &obj.TaskID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TaskReference : TaskReference struct
type TaskReference struct {
	// Link to Task resource.
	Href *string `json:"href" validate:"required"`

	// ID of Task used to get status of long running operation.
	TaskID *string `json:"taskID" validate:"required"`
}

// UnmarshalTaskReference unmarshals an instance of TaskReference from the specified map of raw messages.
func UnmarshalTaskReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TaskReference)
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "taskID", &obj.TaskID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Tenant : Tenant struct
type Tenant struct {
	// Cloud Instances owned by the Tenant.
	CloudInstances []CloudInstanceReference `json:"cloudInstances" validate:"required"`

	// Date of Tenant creation.
	CreationDate *strfmt.DateTime `json:"creationDate" validate:"required"`

	// Indicates if the tenant is enabled.
	Enabled *bool `json:"enabled" validate:"required"`

	// IBM Customer Number.
	Icn *string `json:"icn,omitempty"`

	// Peering Network Information (optional).
	PeeringNetworks []PeeringNetwork `json:"peeringNetworks,omitempty"`

	// Tenant SSH Keys.
	SshKeys []SshKey `json:"sshKeys,omitempty"`

	// Tenant ID.
	TenantID *string `json:"tenantID" validate:"required"`
}

// UnmarshalTenant unmarshals an instance of Tenant from the specified map of raw messages.
func UnmarshalTenant(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Tenant)
	err = core.UnmarshalModel(m, "cloudInstances", &obj.CloudInstances, UnmarshalCloudInstanceReference)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "creationDate", &obj.CreationDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "enabled", &obj.Enabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "icn", &obj.Icn)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "peeringNetworks", &obj.PeeringNetworks, UnmarshalPeeringNetwork)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "sshKeys", &obj.SshKeys, UnmarshalSshKey)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "tenantID", &obj.TenantID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Thresholds : storage threshold settings.
type Thresholds struct {
	Capacity *StorageEntities `json:"capacity,omitempty"`

	Overcommit *StorageEntities `json:"overcommit,omitempty"`

	PhysicalCapacity *StorageEntities `json:"physicalCapacity,omitempty"`

	VdiskCapacity *StorageEntities `json:"vdiskCapacity,omitempty"`

	VdiskLimit *StorageEntities `json:"vdiskLimit,omitempty"`
}

// UnmarshalThresholds unmarshals an instance of Thresholds from the specified map of raw messages.
func UnmarshalThresholds(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Thresholds)
	err = core.UnmarshalModel(m, "capacity", &obj.Capacity, UnmarshalStorageEntities)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "overcommit", &obj.Overcommit, UnmarshalStorageEntities)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "physicalCapacity", &obj.PhysicalCapacity, UnmarshalStorageEntities)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vdiskCapacity", &obj.VdiskCapacity, UnmarshalStorageEntities)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "vdiskLimit", &obj.VdiskLimit, UnmarshalStorageEntities)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Token : Token struct
type Token struct {
	// AccessToken.
	AccessToken *string `json:"accessToken" validate:"required"`

	// Token Expires.
	Expires *strfmt.DateTime `json:"expires" validate:"required"`

	// Refresh Token.
	RefreshToken *string `json:"refreshToken" validate:"required"`

	// Token Type.
	Type *string `json:"type" validate:"required"`
}

// UnmarshalToken unmarshals an instance of Token from the specified map of raw messages.
func UnmarshalToken(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Token)
	err = core.UnmarshalPrimitive(m, "accessToken", &obj.AccessToken)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "expires", &obj.Expires)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "refreshToken", &obj.RefreshToken)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TokenExtra : TokenExtra struct
type TokenExtra struct {
	// Number of seconds token will expire.
	ExpiresIn *float64 `json:"expiresIn" validate:"required"`

	// Time on the service broker.
	ServerTime *strfmt.DateTime `json:"serverTime" validate:"required"`

	Token *Token `json:"token" validate:"required"`

	// Is this token valid.
	Valid *bool `json:"valid" validate:"required"`
}

// UnmarshalTokenExtra unmarshals an instance of TokenExtra from the specified map of raw messages.
func UnmarshalTokenExtra(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TokenExtra)
	err = core.UnmarshalPrimitive(m, "expiresIn", &obj.ExpiresIn)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serverTime", &obj.ServerTime)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "token", &obj.Token, UnmarshalToken)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "valid", &obj.Valid)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitConnectionErrorItem : TransitConnectionErrorItem struct
type TransitConnectionErrorItem struct {
	// The status code of the transit connection.
	Code *string `json:"code" validate:"required"`

	// The trace id for debugging purposes.
	Message *string `json:"message" validate:"required"`

	// List of available capabilities for a specific service.
	Target *TargetObject `json:"target,omitempty"`
}

// UnmarshalTransitConnectionErrorItem unmarshals an instance of TransitConnectionErrorItem from the specified map of raw messages.
func UnmarshalTransitConnectionErrorItem(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitConnectionErrorItem)
	err = core.UnmarshalPrimitive(m, "code", &obj.Code)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "message", &obj.Message)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "target", &obj.Target, UnmarshalTargetObject)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayInstance : TransitGatewayInstance struct
type TransitGatewayInstance struct {
	Errors []TransitConnectionErrorItem `json:"errors,omitempty"`

	// IBM Resource Group ID associated with the PowerVS Service Instance.
	ResourceGroupID *string `json:"resourceGroupId,omitempty"`

	// The route distinguisher for a network.
	RouteDistinguisher *string `json:"routeDistinguisher,omitempty"`

	// The route target for a network.
	RouteTarget *string `json:"routeTarget,omitempty"`

	// The PowerVS Service Instance CRN.
	ServiceCRN *string `json:"serviceCrn,omitempty"`

	// The PowerVS Service Instance ID.
	ServiceID *string `json:"serviceId,omitempty"`

	// The trace id for debugging purposes.
	Trace *string `json:"trace,omitempty"`
}

// UnmarshalTransitGatewayInstance unmarshals an instance of TransitGatewayInstance from the specified map of raw messages.
func UnmarshalTransitGatewayInstance(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayInstance)
	err = core.UnmarshalModel(m, "errors", &obj.Errors, UnmarshalTransitConnectionErrorItem)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "resourceGroupId", &obj.ResourceGroupID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "routeDistinguisher", &obj.RouteDistinguisher)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "routeTarget", &obj.RouteTarget)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serviceCrn", &obj.ServiceCRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "serviceId", &obj.ServiceID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "trace", &obj.Trace)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayLocation : The PER enabled PowerVS Service Location.
type TransitGatewayLocation struct {
	// The Location of the PowerVS Service.
	Location *string `json:"location" validate:"required"`

	// Location Type of the PowerVS Service.
	LocationType *string `json:"locationType" validate:"required"`

	// The PowerVS Location URL path to access specific service instance information.
	LocationURL *string `json:"locationUrl" validate:"required"`
}

// Constants associated with the TransitGatewayLocation.LocationType property.
// Location Type of the PowerVS Service.
const (
	TransitGatewayLocationLocationTypeDataCenterConst = "data-center"
	TransitGatewayLocationLocationTypeRegionConst = "region"
	TransitGatewayLocationLocationTypeZoneConst = "zone"
)

// UnmarshalTransitGatewayLocation unmarshals an instance of TransitGatewayLocation from the specified map of raw messages.
func UnmarshalTransitGatewayLocation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayLocation)
	err = core.UnmarshalPrimitive(m, "location", &obj.Location)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "locationType", &obj.LocationType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "locationUrl", &obj.LocationURL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// TransitGatewayLocations : TransitGatewayLocations struct
type TransitGatewayLocations struct {
	// The List of PER enabled PowerVS Service Locations.
	TransitGatewayLocations []TransitGatewayLocation `json:"transitGatewayLocations" validate:"required"`
}

// UnmarshalTransitGatewayLocations unmarshals an instance of TransitGatewayLocations from the specified map of raw messages.
func UnmarshalTransitGatewayLocations(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(TransitGatewayLocations)
	err = core.UnmarshalModel(m, "transitGatewayLocations", &obj.TransitGatewayLocations, UnmarshalTransitGatewayLocation)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// UserInfo : UserInfo struct
type UserInfo struct {
	// User Email.
	Email *string `json:"email" validate:"required"`

	// User ID.
	ID *string `json:"id" validate:"required"`

	// User Image URL.
	ImageURL *string `json:"imageURL,omitempty"`

	// Member of the following tenants.
	MemberOf []string `json:"memberOf,omitempty"`

	// User Name.
	Name *string `json:"name" validate:"required"`
}

// UnmarshalUserInfo unmarshals an instance of UserInfo from the specified map of raw messages.
func UnmarshalUserInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(UserInfo)
	err = core.UnmarshalPrimitive(m, "email", &obj.Email)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "imageURL", &obj.ImageURL)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "memberOf", &obj.MemberOf)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// V1DatacentersGetOptions : The DatacentersGet options.
type V1DatacentersGetOptions struct {
	// Datacenter Region.
	DatacenterRegion *string `json:"datacenter_region" validate:"required,ne="`

	// The type of the response: application/json, capabilities, location, status, or type.
	Accept *string `json:"Accept,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV1DatacentersGetOptions : Instantiate V1DatacentersGetOptions
func (*PowervsV1) NewV1DatacentersGetOptions(datacenterRegion string) *V1DatacentersGetOptions {
	return &V1DatacentersGetOptions{
		DatacenterRegion: core.StringPtr(datacenterRegion),
	}
}

// SetDatacenterRegion : Allow user to set DatacenterRegion
func (_options *V1DatacentersGetOptions) SetDatacenterRegion(datacenterRegion string) *V1DatacentersGetOptions {
	_options.DatacenterRegion = core.StringPtr(datacenterRegion)
	return _options
}

// SetAccept : Allow user to set Accept
func (_options *V1DatacentersGetOptions) SetAccept(accept string) *V1DatacentersGetOptions {
	_options.Accept = core.StringPtr(accept)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *V1DatacentersGetOptions) SetHeaders(param map[string]string) *V1DatacentersGetOptions {
	options.Headers = param
	return options
}

// V1DatacentersGetallOptions : The DatacentersGetall options.
type V1DatacentersGetallOptions struct {
	// The type of the response: application/json or applicaton/json.
	Accept *string `json:"Accept,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV1DatacentersGetallOptions : Instantiate V1DatacentersGetallOptions
func (*PowervsV1) NewV1DatacentersGetallOptions() *V1DatacentersGetallOptions {
	return &V1DatacentersGetallOptions{}
}

// SetAccept : Allow user to set Accept
func (_options *V1DatacentersGetallOptions) SetAccept(accept string) *V1DatacentersGetallOptions {
	_options.Accept = core.StringPtr(accept)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *V1DatacentersGetallOptions) SetHeaders(param map[string]string) *V1DatacentersGetallOptions {
	options.Headers = param
	return options
}

// V1WorkspacesGetOptions : The WorkspacesGet options.
type V1WorkspacesGetOptions struct {
	// Workspace ID.
	WorkspaceID *string `json:"workspace_id" validate:"required,ne="`

	// The type of the response: application/json or applicaton/json.
	Accept *string `json:"Accept,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV1WorkspacesGetOptions : Instantiate V1WorkspacesGetOptions
func (*PowervsV1) NewV1WorkspacesGetOptions(workspaceID string) *V1WorkspacesGetOptions {
	return &V1WorkspacesGetOptions{
		WorkspaceID: core.StringPtr(workspaceID),
	}
}

// SetWorkspaceID : Allow user to set WorkspaceID
func (_options *V1WorkspacesGetOptions) SetWorkspaceID(workspaceID string) *V1WorkspacesGetOptions {
	_options.WorkspaceID = core.StringPtr(workspaceID)
	return _options
}

// SetAccept : Allow user to set Accept
func (_options *V1WorkspacesGetOptions) SetAccept(accept string) *V1WorkspacesGetOptions {
	_options.Accept = core.StringPtr(accept)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *V1WorkspacesGetOptions) SetHeaders(param map[string]string) *V1WorkspacesGetOptions {
	options.Headers = param
	return options
}

// V1WorkspacesGetallOptions : The WorkspacesGetall options.
type V1WorkspacesGetallOptions struct {
	// The type of the response: application/json or applicaton/json.
	Accept *string `json:"Accept,omitempty"`

	// Allows users to set headers on API requests
	Headers map[string]string
}

// NewV1WorkspacesGetallOptions : Instantiate V1WorkspacesGetallOptions
func (*PowervsV1) NewV1WorkspacesGetallOptions() *V1WorkspacesGetallOptions {
	return &V1WorkspacesGetallOptions{}
}

// SetAccept : Allow user to set Accept
func (_options *V1WorkspacesGetallOptions) SetAccept(accept string) *V1WorkspacesGetallOptions {
	_options.Accept = core.StringPtr(accept)
	return _options
}

// SetHeaders : Allow user to set Headers
func (options *V1WorkspacesGetallOptions) SetHeaders(param map[string]string) *V1WorkspacesGetallOptions {
	options.Headers = param
	return options
}

// VPNConnection : VPNConnection struct
type VPNConnection struct {
	// Dead Peer Detection of the VPN Connection.
	DeadPeerDetection *DeadPeerDetection `json:"deadPeerDetection" validate:"required"`

	// unique identifier for VPN Connection.
	ID *string `json:"id" validate:"required"`

	// IKE Policy reference object.
	IkePolicy *IkePolicyRef `json:"ikePolicy" validate:"required"`

	// IPSec Policy reference object.
	IPSecPolicy *IPSecPolicyRef `json:"ipSecPolicy" validate:"required"`

	// local Gateway address, only in 'route' mode.
	LocalGatewayAddress *string `json:"localGatewayAddress" validate:"required"`

	// Mode used by this VPNConnection, either policy-based, or route-based, this attribute is set at the creation and
	// cannot be updated later.
	Mode *string `json:"mode" validate:"required"`

	// VPN Connection name.
	Name *string `json:"name" validate:"required"`

	// an array of network IDs.
	NetworkIDs []string `json:"networkIDs" validate:"required"`

	// IP address of the Peer Gateway attached to this VPNConnection.
	PeerGatewayAddress *string `json:"peerGatewayAddress" validate:"required"`

	// an array of strings containing CIDR of peer subnets.
	PeerSubnets []string `json:"peerSubnets" validate:"required"`

	// status of the VPN connection.
	Status *string `json:"status" validate:"required"`

	// public IP address of the VPN Gateway (vSRX) attached to this VPNConnection.
	VPNGatewayAddress *string `json:"vpnGatewayAddress" validate:"required"`
}

// Constants associated with the VPNConnection.Mode property.
// Mode used by this VPNConnection, either policy-based, or route-based, this attribute is set at the creation and
// cannot be updated later.
const (
	VPNConnectionModePolicyConst = "policy"
	VPNConnectionModeRouteConst = "route"
)

// Constants associated with the VPNConnection.Status property.
// status of the VPN connection.
const (
	VPNConnectionStatusActiveConst = "active"
	VPNConnectionStatusDisabledConst = "disabled"
	VPNConnectionStatusWarningConst = "warning"
)

// UnmarshalVPNConnection unmarshals an instance of VPNConnection from the specified map of raw messages.
func UnmarshalVPNConnection(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNConnection)
	err = core.UnmarshalModel(m, "deadPeerDetection", &obj.DeadPeerDetection, UnmarshalDeadPeerDetection)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ikePolicy", &obj.IkePolicy, UnmarshalIkePolicyRef)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ipSecPolicy", &obj.IPSecPolicy, UnmarshalIPSecPolicyRef)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "localGatewayAddress", &obj.LocalGatewayAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "networkIDs", &obj.NetworkIDs)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peerGatewayAddress", &obj.PeerGatewayAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peerSubnets", &obj.PeerSubnets)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vpnGatewayAddress", &obj.VPNGatewayAddress)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNConnectionCreateResponse : VPNConnectionCreateResponse struct
type VPNConnectionCreateResponse struct {
	// Dead Peer Detection of the VPN Connection.
	DeadPeerDetection *DeadPeerDetection `json:"deadPeerDetection" validate:"required"`

	// unique identifier for VPN Connection.
	ID *string `json:"id" validate:"required"`

	// IKE Policy reference object.
	IkePolicy *IkePolicyRef `json:"ikePolicy" validate:"required"`

	// IPSec Policy reference object.
	IPSecPolicy *IPSecPolicyRef `json:"ipSecPolicy" validate:"required"`

	// local Gateway address, only in 'route' mode.
	LocalGatewayAddress *string `json:"localGatewayAddress" validate:"required"`

	// Mode used by this VPNConnection, either policy-based, or route-based, this attribute is set at the creation and
	// cannot be updated later.
	Mode *string `json:"mode" validate:"required"`

	// VPN Connection name.
	Name *string `json:"name" validate:"required"`

	// an array of network IDs.
	NetworkIDs []string `json:"networkIDs" validate:"required"`

	// IP address of the Peer Gateway attached to this VPNConnection.
	PeerGatewayAddress *string `json:"peerGatewayAddress" validate:"required"`

	// an array of strings containing CIDR of peer subnets.
	PeerSubnets []string `json:"peerSubnets" validate:"required"`

	// status of the VPN connection.
	Status *string `json:"status" validate:"required"`

	// public IP address of the VPN Gateway (vSRX) attached to this VPNConnection.
	VPNGatewayAddress *string `json:"vpnGatewayAddress" validate:"required"`

	JobRef *JobReference `json:"jobRef,omitempty"`
}

// Constants associated with the VPNConnectionCreateResponse.Mode property.
// Mode used by this VPNConnection, either policy-based, or route-based, this attribute is set at the creation and
// cannot be updated later.
const (
	VPNConnectionCreateResponseModePolicyConst = "policy"
	VPNConnectionCreateResponseModeRouteConst = "route"
)

// Constants associated with the VPNConnectionCreateResponse.Status property.
// status of the VPN connection.
const (
	VPNConnectionCreateResponseStatusActiveConst = "active"
	VPNConnectionCreateResponseStatusDisabledConst = "disabled"
	VPNConnectionCreateResponseStatusWarningConst = "warning"
)

// UnmarshalVPNConnectionCreateResponse unmarshals an instance of VPNConnectionCreateResponse from the specified map of raw messages.
func UnmarshalVPNConnectionCreateResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNConnectionCreateResponse)
	err = core.UnmarshalModel(m, "deadPeerDetection", &obj.DeadPeerDetection, UnmarshalDeadPeerDetection)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ikePolicy", &obj.IkePolicy, UnmarshalIkePolicyRef)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "ipSecPolicy", &obj.IPSecPolicy, UnmarshalIPSecPolicyRef)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "localGatewayAddress", &obj.LocalGatewayAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mode", &obj.Mode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "networkIDs", &obj.NetworkIDs)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peerGatewayAddress", &obj.PeerGatewayAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "peerSubnets", &obj.PeerSubnets)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "vpnGatewayAddress", &obj.VPNGatewayAddress)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "jobRef", &obj.JobRef, UnmarshalJobReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNConnectionUpdate : VPN Connection object to send during the update.
type VPNConnectionUpdate struct {
	// unique identifier of IKEPolicy selected for this VPNConnection.
	IkePolicy *string `json:"ikePolicy,omitempty"`

	// unique identifier of IPSecPolicy selected for this VPNConnection.
	IPSecPolicy *string `json:"ipSecPolicy,omitempty"`

	// VPN Connection name.
	Name *string `json:"name,omitempty"`

	// IP address of the Peer Gateway attached to this VPNConnection.
	PeerGatewayAddress *string `json:"peerGatewayAddress,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// SetProperty allows the user to set an arbitrary property on an instance of VPNConnectionUpdate
func (o *VPNConnectionUpdate) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of VPNConnectionUpdate
func (o *VPNConnectionUpdate) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of VPNConnectionUpdate
func (o *VPNConnectionUpdate) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of VPNConnectionUpdate
func (o *VPNConnectionUpdate) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of VPNConnectionUpdate
func (o *VPNConnectionUpdate) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.IkePolicy != nil {
		m["ikePolicy"] = o.IkePolicy
	}
	if o.IPSecPolicy != nil {
		m["ipSecPolicy"] = o.IPSecPolicy
	}
	if o.Name != nil {
		m["name"] = o.Name
	}
	if o.PeerGatewayAddress != nil {
		m["peerGatewayAddress"] = o.PeerGatewayAddress
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalVPNConnectionUpdate unmarshals an instance of VPNConnectionUpdate from the specified map of raw messages.
func UnmarshalVPNConnectionUpdate(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNConnectionUpdate)
	err = core.UnmarshalPrimitive(m, "ikePolicy", &obj.IkePolicy)
	if err != nil {
		return
	}
	delete(m, "ikePolicy")
	err = core.UnmarshalPrimitive(m, "ipSecPolicy", &obj.IPSecPolicy)
	if err != nil {
		return
	}
	delete(m, "ipSecPolicy")
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	delete(m, "name")
	err = core.UnmarshalPrimitive(m, "peerGatewayAddress", &obj.PeerGatewayAddress)
	if err != nil {
		return
	}
	delete(m, "peerGatewayAddress")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VPNConnections : VPNConnections struct
type VPNConnections struct {
	// an array of VPN Connections.
	VPNConnections []VPNConnection `json:"vpnConnections,omitempty"`
}

// UnmarshalVPNConnections unmarshals an instance of VPNConnections from the specified map of raw messages.
func UnmarshalVPNConnections(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VPNConnections)
	err = core.UnmarshalModel(m, "vpnConnections", &obj.VPNConnections, UnmarshalVPNConnection)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Version : Version struct
type Version struct {
	// Returns the build time.
	BuildDate *string `json:"buildDate,omitempty"`

	// Returns the current go runtime version.
	GoVersion *string `json:"goVersion,omitempty"`

	// Hostname of the responding system.
	Hostname *string `json:"hostname,omitempty"`

	// Returns the git versioning information.
	Version *string `json:"version,omitempty"`
}

// UnmarshalVersion unmarshals an instance of Version from the specified map of raw messages.
func UnmarshalVersion(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Version)
	err = core.UnmarshalPrimitive(m, "buildDate", &obj.BuildDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "goVersion", &obj.GoVersion)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "hostname", &obj.Hostname)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "version", &obj.Version)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VirtualCores : VirtualCores struct
type VirtualCores struct {
	// The active virtual Cores.
	Assigned *int64 `json:"assigned" validate:"required"`

	// The maximum DLPAR range for virtual Cores (Display only support).
	Max *int64 `json:"max,omitempty"`

	// The minimum DLPAR range for virtual Cores (Display only support).
	Min *int64 `json:"min,omitempty"`
}

// NewVirtualCores : Instantiate VirtualCores (Generic Model Constructor)
func (*PowervsV1) NewVirtualCores(assigned int64) (_model *VirtualCores, err error) {
	_model = &VirtualCores{
		Assigned: core.Int64Ptr(assigned),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalVirtualCores unmarshals an instance of VirtualCores from the specified map of raw messages.
func UnmarshalVirtualCores(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VirtualCores)
	err = core.UnmarshalPrimitive(m, "assigned", &obj.Assigned)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "max", &obj.Max)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "min", &obj.Min)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Volume : Volume struct
type Volume struct {
	// Auxiliary volume name at storage host level.
	AuxVolumeName *string `json:"auxVolumeName,omitempty"`

	// true if volume is auxiliary otherwise false.
	Auxiliary *bool `json:"auxiliary,omitempty"`

	// Indicates if the volume is the server's boot volume.
	BootVolume *bool `json:"bootVolume,omitempty"`

	// Indicates if the volume is boot capable.
	Bootable *bool `json:"bootable,omitempty"`

	// Consistency Group Name if volume is a part of volume group.
	ConsistencyGroupName *string `json:"consistencyGroupName,omitempty"`

	// Creation Date.
	CreationDate *strfmt.DateTime `json:"creationDate" validate:"required"`

	// Indicates if the volume should be deleted when the server terminates.
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty"`

	// Type of Disk.
	DiskType *string `json:"diskType,omitempty"`

	// Volume Group ID.
	GroupID *string `json:"groupID,omitempty"`

	// Amount of iops assigned to the volume.
	IoThrottleRate *string `json:"ioThrottleRate,omitempty"`

	// Last Update Date.
	LastUpdateDate *strfmt.DateTime `json:"lastUpdateDate" validate:"required"`

	// Master volume name at storage host level.
	MasterVolumeName *string `json:"masterVolumeName,omitempty"`

	// Mirroring state for replication enabled volume.
	MirroringState *string `json:"mirroringState,omitempty"`

	// Volume Name.
	Name *string `json:"name" validate:"required"`

	// true if volume does not exist on storage controller, as volume has been deleted by deleting its paired volume from
	// the mapped replication site.
	OutOfBandDeleted *bool `json:"outOfBandDeleted,omitempty"`

	// indicates whether master/aux volume is playing the primary role.
	PrimaryRole *string `json:"primaryRole,omitempty"`

	// List of PCloud PVM Instance attached to the volume.
	PvmInstanceIDs []string `json:"pvmInstanceIDs,omitempty"`

	// True if volume is replication enabled otherwise false.
	ReplicationEnabled *bool `json:"replicationEnabled,omitempty"`

	// Replication status of a volume.
	ReplicationStatus *string `json:"replicationStatus,omitempty"`

	// type of replication(metro,global).
	ReplicationType *string `json:"replicationType,omitempty"`

	// Indicates if the volume is shareable between VMs.
	Shareable *bool `json:"shareable,omitempty"`

	// Volume Size.
	Size *float64 `json:"size" validate:"required"`

	// Volume State.
	State *string `json:"state,omitempty"`

	// Volume ID.
	VolumeID *string `json:"volumeID" validate:"required"`

	// Volume pool, name of storage pool where the volume is located.
	VolumePool *string `json:"volumePool,omitempty"`

	// Volume type, name of storage template used to create the volume.
	VolumeType *string `json:"volumeType,omitempty"`

	// Volume world wide name.
	Wwn *string `json:"wwn,omitempty"`
}

// Constants associated with the Volume.PrimaryRole property.
// indicates whether master/aux volume is playing the primary role.
const (
	VolumePrimaryRoleAuxConst = "aux"
	VolumePrimaryRoleMasterConst = "master"
)

// UnmarshalVolume unmarshals an instance of Volume from the specified map of raw messages.
func UnmarshalVolume(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Volume)
	err = core.UnmarshalPrimitive(m, "auxVolumeName", &obj.AuxVolumeName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auxiliary", &obj.Auxiliary)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bootVolume", &obj.BootVolume)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bootable", &obj.Bootable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "consistencyGroupName", &obj.ConsistencyGroupName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "creationDate", &obj.CreationDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "deleteOnTermination", &obj.DeleteOnTermination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "diskType", &obj.DiskType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "groupID", &obj.GroupID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ioThrottleRate", &obj.IoThrottleRate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lastUpdateDate", &obj.LastUpdateDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterVolumeName", &obj.MasterVolumeName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mirroringState", &obj.MirroringState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "outOfBandDeleted", &obj.OutOfBandDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "primaryRole", &obj.PrimaryRole)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pvmInstanceIDs", &obj.PvmInstanceIDs)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replicationEnabled", &obj.ReplicationEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replicationStatus", &obj.ReplicationStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replicationType", &obj.ReplicationType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "shareable", &obj.Shareable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "size", &obj.Size)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "volumeID", &obj.VolumeID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "volumePool", &obj.VolumePool)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "volumeType", &obj.VolumeType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "wwn", &obj.Wwn)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeGroup : VolumeGroup struct
type VolumeGroup struct {
	// The name of consistencyGroup at storage host level.
	ConsistencyGroupName *string `json:"consistencyGroupName,omitempty"`

	// The ID of the volume group.
	ID *string `json:"id" validate:"required"`

	// The name of the volume group.
	Name *string `json:"name" validate:"required"`

	// Replication status of volume group.
	ReplicationStatus *string `json:"replicationStatus,omitempty"`

	// Status of the volume group.
	Status *string `json:"status,omitempty"`

	// Status details of the volume group.
	StatusDescription *StatusDescription `json:"statusDescription,omitempty"`
}

// UnmarshalVolumeGroup unmarshals an instance of VolumeGroup from the specified map of raw messages.
func UnmarshalVolumeGroup(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeGroup)
	err = core.UnmarshalPrimitive(m, "consistencyGroupName", &obj.ConsistencyGroupName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replicationStatus", &obj.ReplicationStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "statusDescription", &obj.StatusDescription, UnmarshalStatusDescription)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeGroupAction : Performs an action (start stop reset ) on a volume group(one at a time).
type VolumeGroupAction struct {
	// Performs reset action on the volume group to update its status value.
	Reset *VolumeGroupActionReset `json:"reset,omitempty"`

	// Performs start action on a volume group.
	Start *VolumeGroupActionStart `json:"start,omitempty"`

	// Performs stop action on a volume group.
	Stop *VolumeGroupActionStop `json:"stop,omitempty"`

	// Allows users to set arbitrary properties
	additionalProperties map[string]interface{}
}

// SetProperty allows the user to set an arbitrary property on an instance of VolumeGroupAction
func (o *VolumeGroupAction) SetProperty(key string, value interface{}) {
	if o.additionalProperties == nil {
		o.additionalProperties = make(map[string]interface{})
	}
	o.additionalProperties[key] = value
}

// SetProperties allows the user to set a map of arbitrary properties on an instance of VolumeGroupAction
func (o *VolumeGroupAction) SetProperties(m map[string]interface{}) {
	o.additionalProperties = make(map[string]interface{})
	for k, v := range m {
		o.additionalProperties[k] = v
	}
}

// GetProperty allows the user to retrieve an arbitrary property from an instance of VolumeGroupAction
func (o *VolumeGroupAction) GetProperty(key string) interface{} {
	return o.additionalProperties[key]
}

// GetProperties allows the user to retrieve the map of arbitrary properties from an instance of VolumeGroupAction
func (o *VolumeGroupAction) GetProperties() map[string]interface{} {
	return o.additionalProperties
}

// MarshalJSON performs custom serialization for instances of VolumeGroupAction
func (o *VolumeGroupAction) MarshalJSON() (buffer []byte, err error) {
	m := make(map[string]interface{})
	if len(o.additionalProperties) > 0 {
		for k, v := range o.additionalProperties {
			m[k] = v
		}
	}
	if o.Reset != nil {
		m["reset"] = o.Reset
	}
	if o.Start != nil {
		m["start"] = o.Start
	}
	if o.Stop != nil {
		m["stop"] = o.Stop
	}
	buffer, err = json.Marshal(m)
	return
}

// UnmarshalVolumeGroupAction unmarshals an instance of VolumeGroupAction from the specified map of raw messages.
func UnmarshalVolumeGroupAction(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeGroupAction)
	err = core.UnmarshalModel(m, "reset", &obj.Reset, UnmarshalVolumeGroupActionReset)
	if err != nil {
		return
	}
	delete(m, "reset")
	err = core.UnmarshalModel(m, "start", &obj.Start, UnmarshalVolumeGroupActionStart)
	if err != nil {
		return
	}
	delete(m, "start")
	err = core.UnmarshalModel(m, "stop", &obj.Stop, UnmarshalVolumeGroupActionStop)
	if err != nil {
		return
	}
	delete(m, "stop")
	for k := range m {
		var v interface{}
		e := core.UnmarshalPrimitive(m, k, &v)
		if e != nil {
			err = e
			return
		}
		obj.SetProperty(k, v)
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeGroupActionReset : Performs reset action on the volume group to update its status value.
type VolumeGroupActionReset struct {
	// New status to be set for a volume group.
	Status *string `json:"status" validate:"required"`
}

// Constants associated with the VolumeGroupActionReset.Status property.
// New status to be set for a volume group.
const (
	VolumeGroupActionResetStatusAvailableConst = "available"
)

// NewVolumeGroupActionReset : Instantiate VolumeGroupActionReset (Generic Model Constructor)
func (*PowervsV1) NewVolumeGroupActionReset(status string) (_model *VolumeGroupActionReset, err error) {
	_model = &VolumeGroupActionReset{
		Status: core.StringPtr(status),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalVolumeGroupActionReset unmarshals an instance of VolumeGroupActionReset from the specified map of raw messages.
func UnmarshalVolumeGroupActionReset(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeGroupActionReset)
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeGroupActionStart : Performs start action on a volume group.
type VolumeGroupActionStart struct {
	// Indicates the source of the action.
	Source *string `json:"source" validate:"required"`
}

// Constants associated with the VolumeGroupActionStart.Source property.
// Indicates the source of the action.
const (
	VolumeGroupActionStartSourceAuxConst = "aux"
	VolumeGroupActionStartSourceMasterConst = "master"
)

// NewVolumeGroupActionStart : Instantiate VolumeGroupActionStart (Generic Model Constructor)
func (*PowervsV1) NewVolumeGroupActionStart(source string) (_model *VolumeGroupActionStart, err error) {
	_model = &VolumeGroupActionStart{
		Source: core.StringPtr(source),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalVolumeGroupActionStart unmarshals an instance of VolumeGroupActionStart from the specified map of raw messages.
func UnmarshalVolumeGroupActionStart(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeGroupActionStart)
	err = core.UnmarshalPrimitive(m, "source", &obj.Source)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeGroupActionStop : Performs stop action on a volume group.
type VolumeGroupActionStop struct {
	// Indicates the access mode of aux volumes.
	Access *bool `json:"access" validate:"required"`
}

// NewVolumeGroupActionStop : Instantiate VolumeGroupActionStop (Generic Model Constructor)
func (*PowervsV1) NewVolumeGroupActionStop(access bool) (_model *VolumeGroupActionStop, err error) {
	_model = &VolumeGroupActionStop{
		Access: core.BoolPtr(access),
	}
	err = core.ValidateStruct(_model, "required parameters")
	return
}

// UnmarshalVolumeGroupActionStop unmarshals an instance of VolumeGroupActionStop from the specified map of raw messages.
func UnmarshalVolumeGroupActionStop(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeGroupActionStop)
	err = core.UnmarshalPrimitive(m, "access", &obj.Access)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeGroupCreateResponse : VolumeGroupCreateResponse struct
type VolumeGroupCreateResponse struct {
	// The ID of the volume group.
	ID *string `json:"id" validate:"required"`

	// The name of the volume group.
	Name *string `json:"name" validate:"required"`

	// Status of the volume group.
	Status *string `json:"status" validate:"required"`

	// Status details of the volume group.
	StatusDetail *string `json:"statusDetail,omitempty"`
}

// UnmarshalVolumeGroupCreateResponse unmarshals an instance of VolumeGroupCreateResponse from the specified map of raw messages.
func UnmarshalVolumeGroupCreateResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeGroupCreateResponse)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "statusDetail", &obj.StatusDetail)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeGroupDetails : VolumeGroupDetails struct
type VolumeGroupDetails struct {
	// The name of volume group at storage host level.
	ConsistencyGroupName *string `json:"consistencyGroupName,omitempty"`

	// The ID of the volume group.
	ID *string `json:"id" validate:"required"`

	// The name of the volume group.
	Name *string `json:"name" validate:"required"`

	// Replication status of volume group.
	ReplicationStatus *string `json:"replicationStatus,omitempty"`

	// Status of the volume group.
	Status *string `json:"status,omitempty"`

	// Status details of the volume group.
	StatusDescription *StatusDescription `json:"statusDescription,omitempty"`

	// List of volume IDs,member of VolumeGroup.
	VolumeIDs []string `json:"volumeIDs,omitempty"`
}

// UnmarshalVolumeGroupDetails unmarshals an instance of VolumeGroupDetails from the specified map of raw messages.
func UnmarshalVolumeGroupDetails(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeGroupDetails)
	err = core.UnmarshalPrimitive(m, "consistencyGroupName", &obj.ConsistencyGroupName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replicationStatus", &obj.ReplicationStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "statusDescription", &obj.StatusDescription, UnmarshalStatusDescription)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "volumeIDs", &obj.VolumeIDs)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeGroupRemoteCopyRelationships : VolumeGroupRemoteCopyRelationships struct
type VolumeGroupRemoteCopyRelationships struct {
	// The ID of the volume group.
	ID *string `json:"id,omitempty"`

	// List of remote copy relationships.
	RemoteCopyRelationships []RemoteCopyRelationship `json:"remoteCopyRelationships,omitempty"`
}

// UnmarshalVolumeGroupRemoteCopyRelationships unmarshals an instance of VolumeGroupRemoteCopyRelationships from the specified map of raw messages.
func UnmarshalVolumeGroupRemoteCopyRelationships(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeGroupRemoteCopyRelationships)
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "remoteCopyRelationships", &obj.RemoteCopyRelationships, UnmarshalRemoteCopyRelationship)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeGroupStorageDetails : VolumeGroupStorageDetails struct
type VolumeGroupStorageDetails struct {
	// The name of consistency group at storage controller level.
	ConsistencyGroupName *string `json:"consistencyGroupName" validate:"required"`

	// Indicates the minimum period in seconds between multiple cycles.
	CyclePeriodSeconds *int64 `json:"cyclePeriodSeconds,omitempty"`

	// Indicates the type of cycling mode used.
	CyclingMode *string `json:"cyclingMode,omitempty"`

	// Number of volumes in volume group.
	NumOfvols *int64 `json:"numOfvols,omitempty"`

	// Indicates whether master/aux volume is playing the primary role.
	PrimaryRole *string `json:"primaryRole,omitempty"`

	// List of remote-copy relationship names in a volume group.
	RemoteCopyRelationshipNames []string `json:"remoteCopyRelationshipNames,omitempty"`

	// Type of replication(metro,global).
	ReplicationType *string `json:"replicationType,omitempty"`

	// Indicates the relationship state.
	State *string `json:"state,omitempty"`

	// Indicates whether the relationship is synchronized.
	Sync *string `json:"sync,omitempty"`
}

// UnmarshalVolumeGroupStorageDetails unmarshals an instance of VolumeGroupStorageDetails from the specified map of raw messages.
func UnmarshalVolumeGroupStorageDetails(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeGroupStorageDetails)
	err = core.UnmarshalPrimitive(m, "consistencyGroupName", &obj.ConsistencyGroupName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cyclePeriodSeconds", &obj.CyclePeriodSeconds)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cyclingMode", &obj.CyclingMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "numOfvols", &obj.NumOfvols)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "primaryRole", &obj.PrimaryRole)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remoteCopyRelationshipNames", &obj.RemoteCopyRelationshipNames)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replicationType", &obj.ReplicationType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sync", &obj.Sync)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeGroups : VolumeGroups struct
type VolumeGroups struct {
	// The list of volume groups.
	VolumeGroups []VolumeGroup `json:"volumeGroups" validate:"required"`
}

// UnmarshalVolumeGroups unmarshals an instance of VolumeGroups from the specified map of raw messages.
func UnmarshalVolumeGroups(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeGroups)
	err = core.UnmarshalModel(m, "volumeGroups", &obj.VolumeGroups, UnmarshalVolumeGroup)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeGroupsDetails : VolumeGroupsDetails struct
type VolumeGroupsDetails struct {
	// The list of volume groups with details.
	VolumeGroups []VolumeGroupDetails `json:"volumeGroups" validate:"required"`
}

// UnmarshalVolumeGroupsDetails unmarshals an instance of VolumeGroupsDetails from the specified map of raw messages.
func UnmarshalVolumeGroupsDetails(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeGroupsDetails)
	err = core.UnmarshalModel(m, "volumeGroups", &obj.VolumeGroups, UnmarshalVolumeGroupDetails)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeInfo : VolumeInfo struct
type VolumeInfo struct {
	// Name of the volume.
	Name *string `json:"name,omitempty"`

	// ID of the volume.
	VolumeID *string `json:"volumeID,omitempty"`
}

// UnmarshalVolumeInfo unmarshals an instance of VolumeInfo from the specified map of raw messages.
func UnmarshalVolumeInfo(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeInfo)
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "volumeID", &obj.VolumeID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeOnboarding : VolumeOnboarding struct
type VolumeOnboarding struct {
	// Description of the volume onboarding operation.
	Description *string `json:"description,omitempty"`

	// Indicates the volume onboarding operation id.
	ID *string `json:"id" validate:"required"`

	// List of volumes requested to be onboarded.
	InputVolumes []string `json:"inputVolumes,omitempty"`

	// Indicates the status of volume onboarding operation.
	Status *string `json:"status,omitempty"`

	// Indicates the create-time of volume onboarding operation.
	CreationTimestamp *strfmt.DateTime `json:"creationTimestamp,omitempty"`

	// Indicates the progress of volume onboarding operation.
	Progress *float64 `json:"progress,omitempty"`

	Results *VolumeOnboardingResults `json:"results,omitempty"`
}

// UnmarshalVolumeOnboarding unmarshals an instance of VolumeOnboarding from the specified map of raw messages.
func UnmarshalVolumeOnboarding(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeOnboarding)
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "inputVolumes", &obj.InputVolumes)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "creationTimestamp", &obj.CreationTimestamp)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "progress", &obj.Progress)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "results", &obj.Results, UnmarshalVolumeOnboardingResults)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeOnboardingCommon : VolumeOnboardingCommon struct
type VolumeOnboardingCommon struct {
	// Description of the volume onboarding operation.
	Description *string `json:"description,omitempty"`

	// Indicates the volume onboarding operation id.
	ID *string `json:"id" validate:"required"`

	// List of volumes requested to be onboarded.
	InputVolumes []string `json:"inputVolumes,omitempty"`

	// Indicates the status of volume onboarding operation.
	Status *string `json:"status,omitempty"`
}

// UnmarshalVolumeOnboardingCommon unmarshals an instance of VolumeOnboardingCommon from the specified map of raw messages.
func UnmarshalVolumeOnboardingCommon(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeOnboardingCommon)
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "inputVolumes", &obj.InputVolumes)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeOnboardingCreateResponse : VolumeOnboardingCreateResponse struct
type VolumeOnboardingCreateResponse struct {
	// Description of the volume onboarding operation.
	Description *string `json:"description,omitempty"`

	// Indicates the volume onboarding operation id.
	ID *string `json:"id,omitempty"`
}

// UnmarshalVolumeOnboardingCreateResponse unmarshals an instance of VolumeOnboardingCreateResponse from the specified map of raw messages.
func UnmarshalVolumeOnboardingCreateResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeOnboardingCreateResponse)
	err = core.UnmarshalPrimitive(m, "description", &obj.Description)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeOnboardingFailure : VolumeOnboardingFailure struct
type VolumeOnboardingFailure struct {
	// The failure reason for the volumes which have failed to be onboarded.
	FailureMessage *string `json:"failureMessage,omitempty"`

	// List of volumes which have failed to be onboarded.
	Volumes []string `json:"volumes,omitempty"`
}

// UnmarshalVolumeOnboardingFailure unmarshals an instance of VolumeOnboardingFailure from the specified map of raw messages.
func UnmarshalVolumeOnboardingFailure(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeOnboardingFailure)
	err = core.UnmarshalPrimitive(m, "failureMessage", &obj.FailureMessage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "volumes", &obj.Volumes)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeOnboardingResults : VolumeOnboardingResults struct
type VolumeOnboardingResults struct {
	// List of volumes which are onboarded successfully.
	OnboardedVolumes []string `json:"onboardedVolumes,omitempty"`

	VolumeOnboardingFailures []VolumeOnboardingFailure `json:"volumeOnboardingFailures,omitempty"`
}

// UnmarshalVolumeOnboardingResults unmarshals an instance of VolumeOnboardingResults from the specified map of raw messages.
func UnmarshalVolumeOnboardingResults(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeOnboardingResults)
	err = core.UnmarshalPrimitive(m, "onboardedVolumes", &obj.OnboardedVolumes)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "volumeOnboardingFailures", &obj.VolumeOnboardingFailures, UnmarshalVolumeOnboardingFailure)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeOnboardings : VolumeOnboardings struct
type VolumeOnboardings struct {
	// The list of volume onboardings.
	Onboardings []VolumeOnboardingCommon `json:"onboardings" validate:"required"`
}

// UnmarshalVolumeOnboardings unmarshals an instance of VolumeOnboardings from the specified map of raw messages.
func UnmarshalVolumeOnboardings(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeOnboardings)
	err = core.UnmarshalModel(m, "onboardings", &obj.Onboardings, UnmarshalVolumeOnboardingCommon)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeReference : VolumeReference struct
type VolumeReference struct {
	// Auxiliary volume name at storage host level.
	AuxVolumeName *string `json:"auxVolumeName,omitempty"`

	// true if volume is auxiliary otherwise false.
	Auxiliary *bool `json:"auxiliary,omitempty"`

	// Indicates if the volume is the server's boot volume.
	BootVolume *bool `json:"bootVolume,omitempty"`

	// Indicates if the volume is boot capable.
	Bootable *bool `json:"bootable" validate:"required"`

	// Consistency Group Name if volume is a part of volume group.
	ConsistencyGroupName *string `json:"consistencyGroupName,omitempty"`

	// Creation Date.
	CreationDate *strfmt.DateTime `json:"creationDate" validate:"required"`

	// Indicates if the volume should be deleted when the server terminates.
	DeleteOnTermination *bool `json:"deleteOnTermination,omitempty"`

	// Type of Disk.
	DiskType *string `json:"diskType" validate:"required"`

	// Volume Group ID.
	GroupID *string `json:"groupID,omitempty"`

	// Link to Volume resource.
	Href *string `json:"href" validate:"required"`

	// Amount of iops assigned to the volume.
	IoThrottleRate *string `json:"ioThrottleRate,omitempty"`

	// Last Update Date.
	LastUpdateDate *strfmt.DateTime `json:"lastUpdateDate" validate:"required"`

	// Master volume name at storage host level.
	MasterVolumeName *string `json:"masterVolumeName,omitempty"`

	// mirroring state for replication enabled volume.
	MirroringState *string `json:"mirroringState,omitempty"`

	// Volume Name.
	Name *string `json:"name" validate:"required"`

	// true if volume does not exist on storage controller, as volume has been deleted by deleting its paired volume from
	// the mapped replication site.
	OutOfBandDeleted *bool `json:"outOfBandDeleted,omitempty"`

	// indicates whether master/aux volume is playing the primary role.
	PrimaryRole *string `json:"primaryRole,omitempty"`

	// List of PCloud PVM Instance attached to the volume.
	PvmInstanceIDs []string `json:"pvmInstanceIDs,omitempty"`

	// True if volume is replication enabled otherwise false.
	ReplicationEnabled *bool `json:"replicationEnabled,omitempty"`

	// shows the replication status of a volume.
	ReplicationStatus *string `json:"replicationStatus,omitempty"`

	// type of replication(metro, global)s.
	ReplicationType *string `json:"replicationType,omitempty"`

	// Indicates if the volume is shareable between VMs.
	Shareable *bool `json:"shareable" validate:"required"`

	// Volume Size.
	Size *float64 `json:"size" validate:"required"`

	// Volume State.
	State *string `json:"state" validate:"required"`

	// Volume ID.
	VolumeID *string `json:"volumeID" validate:"required"`

	// Volume pool, name of storage pool where the volume is located.
	VolumePool *string `json:"volumePool,omitempty"`

	// Volume type, name of storage template used to create the volume.
	VolumeType *string `json:"volumeType,omitempty"`

	// Volume world wide name.
	Wwn *string `json:"wwn" validate:"required"`
}

// Constants associated with the VolumeReference.PrimaryRole property.
// indicates whether master/aux volume is playing the primary role.
const (
	VolumeReferencePrimaryRoleAuxConst = "aux"
	VolumeReferencePrimaryRoleMasterConst = "master"
)

// UnmarshalVolumeReference unmarshals an instance of VolumeReference from the specified map of raw messages.
func UnmarshalVolumeReference(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeReference)
	err = core.UnmarshalPrimitive(m, "auxVolumeName", &obj.AuxVolumeName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auxiliary", &obj.Auxiliary)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bootVolume", &obj.BootVolume)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "bootable", &obj.Bootable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "consistencyGroupName", &obj.ConsistencyGroupName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "creationDate", &obj.CreationDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "deleteOnTermination", &obj.DeleteOnTermination)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "diskType", &obj.DiskType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "groupID", &obj.GroupID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "ioThrottleRate", &obj.IoThrottleRate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lastUpdateDate", &obj.LastUpdateDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterVolumeName", &obj.MasterVolumeName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "mirroringState", &obj.MirroringState)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "outOfBandDeleted", &obj.OutOfBandDeleted)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "primaryRole", &obj.PrimaryRole)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "pvmInstanceIDs", &obj.PvmInstanceIDs)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replicationEnabled", &obj.ReplicationEnabled)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replicationStatus", &obj.ReplicationStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "replicationType", &obj.ReplicationType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "shareable", &obj.Shareable)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "size", &obj.Size)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "volumeID", &obj.VolumeID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "volumePool", &obj.VolumePool)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "volumeType", &obj.VolumeType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "wwn", &obj.Wwn)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumeRemoteCopyRelationship : VolumeRemoteCopyRelationship struct
type VolumeRemoteCopyRelationship struct {
	// Name of the volume that is acting as the auxiliary change volume for the relationship.
	AuxChangedVolumeName *string `json:"auxChangedVolumeName,omitempty"`

	// Auxiliary volume name at storage host level.
	AuxVolumeName *string `json:"auxVolumeName,omitempty"`

	// Consistency Group Name if volume is a part of volume group.
	ConsistencyGroupName *string `json:"consistencyGroupName,omitempty"`

	// Indicates the copy type.
	CopyType *string `json:"copyType,omitempty"`

	// Indicates the type of cycling mode used.
	CyclingMode *string `json:"cyclingMode,omitempty"`

	// Freeze time of remote copy relationship.
	FreezeTime *strfmt.DateTime `json:"freezeTime,omitempty"`

	// Name of the volume that is acting as the master change volume for the relationship.
	MasterChangedVolumeName *string `json:"masterChangedVolumeName,omitempty"`

	// Master volume name at storage host level.
	MasterVolumeName *string `json:"masterVolumeName,omitempty"`

	// Remote copy relationship name.
	Name *string `json:"name" validate:"required"`

	// Indicates whether master/aux volume is playing the primary role.
	PrimaryRole *string `json:"primaryRole,omitempty"`

	// Indicates the relationship progress.
	Progress *int64 `json:"progress,omitempty"`

	// Remote copy relationship ID.
	RemoteCopyID *string `json:"remoteCopyID" validate:"required"`

	// Indicates the relationship state.
	State *string `json:"state,omitempty"`

	// Indicates whether the relationship is synchronized.
	Sync *string `json:"sync,omitempty"`

	// Indicates the minimum period in seconds between multiple cycles.
	CyclePeriodSeconds *int64 `json:"cyclePeriodSeconds,omitempty"`

	// Volume ID.
	ID *string `json:"id,omitempty"`
}

// UnmarshalVolumeRemoteCopyRelationship unmarshals an instance of VolumeRemoteCopyRelationship from the specified map of raw messages.
func UnmarshalVolumeRemoteCopyRelationship(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumeRemoteCopyRelationship)
	err = core.UnmarshalPrimitive(m, "auxChangedVolumeName", &obj.AuxChangedVolumeName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "auxVolumeName", &obj.AuxVolumeName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "consistencyGroupName", &obj.ConsistencyGroupName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "copyType", &obj.CopyType)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cyclingMode", &obj.CyclingMode)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "freezeTime", &obj.FreezeTime)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterChangedVolumeName", &obj.MasterChangedVolumeName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "masterVolumeName", &obj.MasterVolumeName)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "primaryRole", &obj.PrimaryRole)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "progress", &obj.Progress)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "remoteCopyID", &obj.RemoteCopyID)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "sync", &obj.Sync)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "cyclePeriodSeconds", &obj.CyclePeriodSeconds)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Volumes : Volumes struct
type Volumes struct {
	// Volumes.
	Volumes []VolumeReference `json:"volumes" validate:"required"`
}

// UnmarshalVolumes unmarshals an instance of Volumes from the specified map of raw messages.
func UnmarshalVolumes(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Volumes)
	err = core.UnmarshalModel(m, "volumes", &obj.Volumes, UnmarshalVolumeReference)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumesAttachmentResponse : VolumesAttachmentResponse struct
type VolumesAttachmentResponse struct {
	// status summary for volume attachment to a PVM Instance.
	Summary *string `json:"summary" validate:"required"`
}

// UnmarshalVolumesAttachmentResponse unmarshals an instance of VolumesAttachmentResponse from the specified map of raw messages.
func UnmarshalVolumesAttachmentResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumesAttachmentResponse)
	err = core.UnmarshalPrimitive(m, "summary", &obj.Summary)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumesClone : VolumesClone struct
type VolumesClone struct {
	// Current action performed for the volumes-clone request.
	Action *string `json:"action,omitempty"`

	// Creation Date.
	CreationDate *strfmt.DateTime `json:"creationDate,omitempty"`

	// Failure reason for a failed volumes-clone request.
	FailureMessage *string `json:"failureMessage,omitempty"`

	// Last Update Date.
	LastUpdateDate *strfmt.DateTime `json:"lastUpdateDate,omitempty"`

	// Name assigned to a volumes-clone request.
	Name *string `json:"name,omitempty"`

	// The percent completion for the current action.
	PercentComplete *int64 `json:"percentComplete" validate:"required"`

	// Current status of the volumes-clone request.
	Status *string `json:"status,omitempty"`

	// ID assigned to a volumes-clone request.
	VolumesCloneID *string `json:"volumesCloneID,omitempty"`
}

// UnmarshalVolumesClone unmarshals an instance of VolumesClone from the specified map of raw messages.
func UnmarshalVolumesClone(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumesClone)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "creationDate", &obj.CreationDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "failureMessage", &obj.FailureMessage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lastUpdateDate", &obj.LastUpdateDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "percentComplete", &obj.PercentComplete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "volumesCloneID", &obj.VolumesCloneID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumesCloneDetail : VolumesCloneDetail struct
type VolumesCloneDetail struct {
	// Current action performed for the volumes-clone request.
	Action *string `json:"action,omitempty"`

	// List of cloned volumes created from the volumes-clone request.
	ClonedVolumes []ClonedVolumeDetail `json:"clonedVolumes,omitempty"`

	// Creation Date.
	CreationDate *strfmt.DateTime `json:"creationDate,omitempty"`

	// Failure reason for a failed volumes-clone request.
	FailureMessage *string `json:"failureMessage,omitempty"`

	// Last Update Date.
	LastUpdateDate *strfmt.DateTime `json:"lastUpdateDate,omitempty"`

	// Name assigned to a volumes-clone request.
	Name *string `json:"name,omitempty"`

	// The percent completion for the current action.
	PercentComplete *int64 `json:"percentComplete" validate:"required"`

	// Current status of the volumes-clone request.
	Status *string `json:"status,omitempty"`

	// ID assigned to a volumes-clone request.
	VolumesCloneID *string `json:"volumesCloneID,omitempty"`
}

// UnmarshalVolumesCloneDetail unmarshals an instance of VolumesCloneDetail from the specified map of raw messages.
func UnmarshalVolumesCloneDetail(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumesCloneDetail)
	err = core.UnmarshalPrimitive(m, "action", &obj.Action)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "clonedVolumes", &obj.ClonedVolumes, UnmarshalClonedVolumeDetail)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "creationDate", &obj.CreationDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "failureMessage", &obj.FailureMessage)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "lastUpdateDate", &obj.LastUpdateDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "percentComplete", &obj.PercentComplete)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "volumesCloneID", &obj.VolumesCloneID)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumesCloneResponse : VolumesCloneResponse struct
type VolumesCloneResponse struct {
	// ID of the new cloned volume.
	AdditionalProperties *string `json:"additionalProperties,omitempty"`

	// A map of volume IDs to cloned volume IDs.
	ClonedVolumes map[string]interface{} `json:"clonedVolumes,omitempty"`
}

// UnmarshalVolumesCloneResponse unmarshals an instance of VolumesCloneResponse from the specified map of raw messages.
func UnmarshalVolumesCloneResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumesCloneResponse)
	err = core.UnmarshalPrimitive(m, "additionalProperties", &obj.AdditionalProperties)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "clonedVolumes", &obj.ClonedVolumes)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumesClones : VolumesClones struct
type VolumesClones struct {
	// list of volumes-clone requests.
	VolumesClone []VolumesClone `json:"volumesClone,omitempty"`
}

// UnmarshalVolumesClones unmarshals an instance of VolumesClones from the specified map of raw messages.
func UnmarshalVolumesClones(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumesClones)
	err = core.UnmarshalModel(m, "volumesClone", &obj.VolumesClone, UnmarshalVolumesClone)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumesDeleteResponse : VolumesDeleteResponse struct
type VolumesDeleteResponse struct {
	// status summary for volumes deletion request.
	Summary *string `json:"summary,omitempty"`
}

// UnmarshalVolumesDeleteResponse unmarshals an instance of VolumesDeleteResponse from the specified map of raw messages.
func UnmarshalVolumesDeleteResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumesDeleteResponse)
	err = core.UnmarshalPrimitive(m, "summary", &obj.Summary)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// VolumesDetachmentResponse : VolumesDetachmentResponse struct
type VolumesDetachmentResponse struct {
	// status summary for volume detachment from a PVM Instance.
	Summary *string `json:"summary" validate:"required"`
}

// UnmarshalVolumesDetachmentResponse unmarshals an instance of VolumesDetachmentResponse from the specified map of raw messages.
func UnmarshalVolumesDetachmentResponse(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(VolumesDetachmentResponse)
	err = core.UnmarshalPrimitive(m, "summary", &obj.Summary)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Workspace : Workspace struct
type Workspace struct {
	// Workspace Capabilities.
	Capabilities map[string]bool `json:"capabilities" validate:"required"`

	Details *WorkspaceDetails `json:"details" validate:"required"`

	// Workspace ID.
	ID *string `json:"id" validate:"required"`

	Location *WorkspaceLocation `json:"location" validate:"required"`

	// The Workspace name.
	Name *string `json:"name" validate:"required"`

	// The Workspace status.
	Status *string `json:"status" validate:"required"`

	// The Workspace type.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the Workspace.Type property.
// The Workspace type.
const (
	WorkspaceTypeOffPremisesConst = "off-premises"
	WorkspaceTypeOnPremisesConst = "on-premises"
)

// UnmarshalWorkspace unmarshals an instance of Workspace from the specified map of raw messages.
func UnmarshalWorkspace(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Workspace)
	err = core.UnmarshalPrimitive(m, "capabilities", &obj.Capabilities)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "details", &obj.Details, UnmarshalWorkspaceDetails)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "id", &obj.ID)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "location", &obj.Location, UnmarshalWorkspaceLocation)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "name", &obj.Name)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "status", &obj.Status)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// WorkspaceDetails : WorkspaceDetails struct
type WorkspaceDetails struct {
	// Workspace creation date.
	CreationDate *strfmt.DateTime `json:"creationDate" validate:"required"`

	// The Workspace crn.
	CRN *string `json:"crn" validate:"required"`

	// Link to Workspace Resource.
	Href *string `json:"href,omitempty"`

	PowerEdgeRouter *WorkspacePowerEdgeRouterDetails `json:"powerEdgeRouter,omitempty"`
}

// UnmarshalWorkspaceDetails unmarshals an instance of WorkspaceDetails from the specified map of raw messages.
func UnmarshalWorkspaceDetails(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(WorkspaceDetails)
	err = core.UnmarshalPrimitive(m, "creationDate", &obj.CreationDate)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "crn", &obj.CRN)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "href", &obj.Href)
	if err != nil {
		return
	}
	err = core.UnmarshalModel(m, "powerEdgeRouter", &obj.PowerEdgeRouter, UnmarshalWorkspacePowerEdgeRouterDetails)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// WorkspaceLocation : WorkspaceLocation struct
type WorkspaceLocation struct {
	// The Workspace location region zone.
	Region *string `json:"region" validate:"required"`

	// The Workspace location region type.
	Type *string `json:"type,omitempty"`

	// The Workspace location region url.
	URL *string `json:"url,omitempty"`
}

// UnmarshalWorkspaceLocation unmarshals an instance of WorkspaceLocation from the specified map of raw messages.
func UnmarshalWorkspaceLocation(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(WorkspaceLocation)
	err = core.UnmarshalPrimitive(m, "region", &obj.Region)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "url", &obj.URL)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// WorkspacePowerEdgeRouterDetails : WorkspacePowerEdgeRouterDetails struct
type WorkspacePowerEdgeRouterDetails struct {
	// The migration status of a Power Edge Router.
	MigrationStatus *string `json:"migrationStatus,omitempty"`

	// The state of a Power Edge Router.
	State *string `json:"state" validate:"required"`

	// The Power Edge Router type.
	Type *string `json:"type" validate:"required"`
}

// Constants associated with the WorkspacePowerEdgeRouterDetails.MigrationStatus property.
// The migration status of a Power Edge Router.
const (
	WorkspacePowerEdgeRouterDetailsMigrationStatusCompletedConst = "completed"
	WorkspacePowerEdgeRouterDetailsMigrationStatusDeletedConst = "deleted"
	WorkspacePowerEdgeRouterDetailsMigrationStatusIntializingConst = "intializing"
	WorkspacePowerEdgeRouterDetailsMigrationStatusMigratingConst = "migrating"
)

// Constants associated with the WorkspacePowerEdgeRouterDetails.State property.
// The state of a Power Edge Router.
const (
	WorkspacePowerEdgeRouterDetailsStateActiveConst = "active"
	WorkspacePowerEdgeRouterDetailsStateConfiguringConst = "configuring"
	WorkspacePowerEdgeRouterDetailsStateErrorConst = "error"
	WorkspacePowerEdgeRouterDetailsStateInactiveConst = "inactive"
	WorkspacePowerEdgeRouterDetailsStateRemovingConst = "removing"
	WorkspacePowerEdgeRouterDetailsStateWarningConst = "warning"
)

// Constants associated with the WorkspacePowerEdgeRouterDetails.Type property.
// The Power Edge Router type.
const (
	WorkspacePowerEdgeRouterDetailsTypeAutomatedConst = "automated"
	WorkspacePowerEdgeRouterDetailsTypeManualConst = "manual"
)

// UnmarshalWorkspacePowerEdgeRouterDetails unmarshals an instance of WorkspacePowerEdgeRouterDetails from the specified map of raw messages.
func UnmarshalWorkspacePowerEdgeRouterDetails(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(WorkspacePowerEdgeRouterDetails)
	err = core.UnmarshalPrimitive(m, "migrationStatus", &obj.MigrationStatus)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "state", &obj.State)
	if err != nil {
		return
	}
	err = core.UnmarshalPrimitive(m, "type", &obj.Type)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}

// Workspaces : Workspaces struct
type Workspaces struct {
	// The list of available workspaces.
	Workspaces []Workspace `json:"workspaces" validate:"required"`
}

// UnmarshalWorkspaces unmarshals an instance of Workspaces from the specified map of raw messages.
func UnmarshalWorkspaces(m map[string]json.RawMessage, result interface{}) (err error) {
	obj := new(Workspaces)
	err = core.UnmarshalModel(m, "workspaces", &obj.Workspaces, UnmarshalWorkspace)
	if err != nil {
		return
	}
	reflect.ValueOf(result).Elem().Set(reflect.ValueOf(obj))
	return
}
